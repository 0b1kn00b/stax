<haxe>
	<class path="haxe.io.BytesBuffer" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/haxe/io/BytesBuffer.hx">
		<b><e path="Void"/></b>
		<addByte public="1" get="inline" set="null" line="55"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<add public="1" get="inline" set="null" line="69"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addBytes public="1" get="inline" set="null" line="84"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="106">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>
		Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.
	</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="41"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.reactive.Collections" params="" file="../src/main/haxe/haxe/reactive/Collections.hx">
		<toStream public="1" params="T" set="method" line="31" static="1">
			<f a="collection:time">
				<t path="Iterable"><c path="toStream.T"/></t>
				<c path="Int"/>
				<c path="haxe.reactive.Stream"><c path="toStream.T"/></c>
			</f>
			<haxe_doc>
     * Converts a collection to a stream, whose events are separated by the 
     * specified amount of time.
     *
     * @param collection    The collection.
     * @param time          The time, in milliseconds.
     *
     </haxe_doc>
		</toStream>
		<toStreamS public="1" params="T" set="method" line="43" static="1">
			<f a="collection:time">
				<t path="Iterable"><c path="toStreamS.T"/></t>
				<c path="haxe.reactive.Signal"><c path="Int"/></c>
				<c path="haxe.reactive.Stream"><c path="toStreamS.T"/></c>
			</f>
			<haxe_doc>
     * Converts a collection to a stream, whose events are separated by the 
     * specified amount of time.
     *
     * @param collection    The collection.
     * @param time          The time, as a signal, in milliseconds.
     *
     </haxe_doc>
		</toStreamS>
		<new set="method" line="21"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="haxe.test._Dispatcher.EventException" params="" file="../src/main/haxe/haxe/test/Dispatcher.hx" private="1" module="haxe.test.Dispatcher"><StopPropagation/></enum>
	<class path="haxe.test.Dispatcher" params="T" file="../src/main/haxe/haxe/test/Dispatcher.hx">
		<stop public="1" set="method" line="65" static="1"><f a=""><e path="Void"/></f></stop>
		<handlers><c path="Array"><f a="">
	<c path="haxe.test.Dispatcher.T"/>
	<e path="Void"/>
</f></c></handlers>
		<add public="1" set="method" line="33"><f a="h">
	<f a="">
		<c path="haxe.test.Dispatcher.T"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="haxe.test.Dispatcher.T"/>
		<e path="Void"/>
	</f>
</f></add>
		<remove public="1" set="method" line="38"><f a="h">
	<f a="">
		<c path="haxe.test.Dispatcher.T"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="haxe.test.Dispatcher.T"/>
		<e path="Void"/>
	</f>
</f></remove>
		<clear public="1" set="method" line="45"><f a=""><e path="Void"/></f></clear>
		<dispatch public="1" set="method" line="49"><f a="e">
	<c path="haxe.test.Dispatcher.T"/>
	<e path="Bool"/>
</f></dispatch>
		<has public="1" set="method" line="61"><f a=""><e path="Bool"/></f></has>
		<new public="1" set="method" line="29"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
* @todo add documentation
</haxe_doc>
	</class>
	<class path="haxe.test.Notifier" params="" file="../src/main/haxe/haxe/test/Dispatcher.hx" module="haxe.test.Dispatcher">
		<stop public="1" set="method" line="110" static="1"><f a=""><e path="Void"/></f></stop>
		<handlers><c path="Array"><f a=""><e path="Void"/></f></c></handlers>
		<add public="1" set="method" line="78"><f a="h">
	<f a=""><e path="Void"/></f>
	<f a=""><e path="Void"/></f>
</f></add>
		<remove public="1" set="method" line="83"><f a="h">
	<f a=""><e path="Void"/></f>
	<f a=""><e path="Void"/></f>
</f></remove>
		<clear public="1" set="method" line="90"><f a=""><e path="Void"/></f></clear>
		<dispatch public="1" set="method" line="94"><f a=""><e path="Bool"/></f></dispatch>
		<has public="1" set="method" line="106"><f a=""><e path="Bool"/></f></has>
		<new public="1" set="method" line="74"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="haxe.net.Url" params="" file="../src/main/haxe/haxe/net/Url.hx"><c path="String"/></typedef>
	<typedef path="haxe.net.ParsedUrl" params="" file="../src/main/haxe/haxe/net/Url.hx" module="haxe.net.Url">
		<a>
			<search><c path="String"/></search>
			<protocol><c path="String"/></protocol>
			<port><c path="String"/></port>
			<pathname><c path="String"/></pathname>
			<href><c path="String"/></href>
			<hostname><c path="String"/></hostname>
			<host><c path="String"/></host>
			<hash><c path="String"/></hash>
		</a>
		<haxe_doc> A parsed representation of a url chosen to match the DOM's Location 
 * object. The meaning of the fields are the same as those of Location.
 </haxe_doc>
	</typedef>
	<typedef path="haxe.net.QueryParameters" params="" file="../src/main/haxe/haxe/net/Url.hx" module="haxe.net.Url"><c path="haxe.data.collections.Map">
	<c path="String"/>
	<c path="String"/>
</c></typedef>
	<enum path="haxe.framework.BindingType" params="" file="../src/main/haxe/haxe/framework/Injector.hx" module="haxe.framework.Injector">
		<OneToOne/>
		<OneToMany/>
	</enum>
	<typedef path="haxe.framework.Binder" params="T:S" file="../src/main/haxe/haxe/framework/Injector.hx" module="haxe.framework.Injector"><a>
	<bindF set="method"><f a="interf:f:?b">
	<c path="Class"><c path="haxe.framework.Binder.T"/></c>
	<f a=""><c path="haxe.framework.Binder.T"/></f>
	<e path="haxe.framework.BindingType"/>
	<c path="haxe.framework.Binder.S"/>
</f></bindF>
	<bind set="method"><f a="interf:c:?b">
	<c path="Class"><c path="haxe.framework.Binder.T"/></c>
	<c path="Class"><d/></c>
	<e path="haxe.framework.BindingType"/>
	<c path="haxe.framework.Binder.S"/>
</f></bind>
</a></typedef>
	<class path="haxe.framework.InjectorConfig" params="" file="../src/main/haxe/haxe/framework/Injector.hx" module="haxe.framework.Injector" interface="1">
		<bind public="1" params="T" set="method">
			<f a="interf:c:?b">
				<c path="Class"><c path="bind.T"/></c>
				<c path="Class"><d/></c>
				<e path="haxe.framework.BindingType"/>
				<c path="haxe.framework.InjectorConfig"/>
			</f>
			<haxe_doc> Binds the interface to the specified implementation class.
   </haxe_doc>
		</bind>
		<bindF public="1" params="T" set="method">
			<f a="interf:f:?b">
				<c path="Class"><c path="bindF.T"/></c>
				<f a=""><c path="bindF.T"/></f>
				<e path="haxe.framework.BindingType"/>
				<c path="haxe.framework.InjectorConfig"/>
			</f>
			<haxe_doc> Binds the interface to the specified factory. The factory will 
   * be used for creating instances of the specified type.
   </haxe_doc>
		</bindF>
		<inClass public="1" params="T" set="method">
			<f a="c">
				<c path="Class"><d/></c>
				<t path="haxe.framework.Binder">
					<c path="inClass.T"/>
					<c path="haxe.framework.InjectorConfig"/>
				</t>
			</f>
			<haxe_doc> Retrieves a binder that operates only in the scope of the specified class. 
   * This can be used to provide fine-grained control over implementations in
   * the scope of a particular class.
   </haxe_doc>
		</inClass>
		<inModule public="1" params="T" set="method">
			<f a="m">
				<c path="String"/>
				<t path="haxe.framework.Binder">
					<c path="inModule.T"/>
					<c path="haxe.framework.InjectorConfig"/>
				</t>
			</f>
			<haxe_doc> Retrieves a binder that operates only in the scope of the specified module. 
   * This can be used to provide fine-grained control over implementations in
   * the scope of a particular module.
   </haxe_doc>
		</inModule>
		<inPackage public="1" params="T" set="method">
			<f a="p">
				<c path="String"/>
				<t path="haxe.framework.Binder">
					<c path="inPackage.T"/>
					<c path="haxe.framework.InjectorConfig"/>
				</t>
			</f>
			<haxe_doc> Retrieves a binder that operates only in the scope of the specified package. 
   * This can be used to provide fine-grained control over implementations in
   * the scope of a particular package.
   </haxe_doc>
		</inPackage>
		<haxe_doc> An interface used to configure dependencies. </haxe_doc>
	</class>
	<class path="haxe.framework.Injector" params="" file="../src/main/haxe/haxe/framework/Injector.hx">
		<inject public="1" params="T" set="method" line="103" static="1">
			<f a="interf:?pos">
				<c path="Class"><c path="inject.T"/></c>
				<t path="haxe.PosInfos"/>
				<c path="inject.T"/>
			</f>
			<haxe_doc> Injects an implementation of the specified interface. The implementation 
   * will be chosen based on the current bindings.
   </haxe_doc>
		</inject>
		<enter public="1" params="T" set="method" line="113" static="1">
			<f a="f">
				<f a="">
					<c path="haxe.framework.InjectorConfig"/>
					<c path="enter.T"/>
				</f>
				<c path="enter.T"/>
			</f>
			<haxe_doc> The entry point for a module. This is how an application specifies the 
   * configuration.
   *
   * @param f The module, which should specify the configuration and run the
   *          associated code.
   </haxe_doc>
		</enter>
		<forever public="1" params="T" set="method" line="117" static="1"><f a="f">
	<f a="">
		<c path="haxe.framework.InjectorConfig"/>
		<c path="forever.T"/>
	</f>
	<c path="forever.T"/>
</f></forever>
		<haxe_doc><![CDATA[ Featherweight injection library.
 * <pre>
 * import haxe.framework.Injector;
 *
 * ...
 *
 * Injector.enter(
 *  function(config) {
 *    config.bind(Clock, SystemClock, OneToMany);
 *    config.inClass(ClockConsumer).bind(Clock, MockClock);
 *
 *    myApp.run();
 *
 *    return Unit;
 *  }
 * );
 * </pre>
 * Interfaces can specify a default implementation by adding the following metadata to the interface itself:
 * <pre>
 * @DefaultImplementation("full.path.to.ImplementationClass")
 * </pre>
 * By default the BindingType is OneToMany but you can specify the desired type as the second parameter:
 * <pre>
 * @DefaultImplementation("full.path.to.ImplementationClass", "OneToOne")
 * </pre>
 * Note that due to limitations in the metadata system both the arguments must be passed as String values.
 ]]></haxe_doc>
	</class>
	<typedef path="haxe.framework._Injector.Bindings" params="" file="../src/main/haxe/haxe/framework/Injector.hx" private="1" module="haxe.framework.Injector"><a>
	<packageBindings><c path="Hash"><c path="Hash"><f a=""><d/></f></c></c></packageBindings>
	<moduleBindings><c path="Hash"><c path="Hash"><f a=""><d/></f></c></c></moduleBindings>
	<globalBindings><c path="Hash"><f a=""><d/></f></c></globalBindings>
	<defaultBindings><c path="Hash"><e path="Option"><f a=""><d/></f></e></c></defaultBindings>
	<classBindings><c path="Hash"><c path="Hash"><f a=""><d/></f></c></c></classBindings>
</a></typedef>
	<class path="haxe.framework._Injector.InjectorImpl" params="" file="../src/main/haxe/haxe/framework/Injector.hx" private="1" module="haxe.framework.Injector">
		<state line="132" static="1"><c path="Array"><t path="haxe.framework._Injector.Bindings"/></c></state>
		<classBindingsExtractor line="134" static="1"><f a="b">
	<t path="haxe.framework._Injector.Bindings"/>
	<c path="Hash"><c path="Hash"><f a=""><d/></f></c></c>
</f></classBindingsExtractor>
		<moduleBindingsExtractor line="135" static="1"><f a="b">
	<t path="haxe.framework._Injector.Bindings"/>
	<c path="Hash"><c path="Hash"><f a=""><d/></f></c></c>
</f></moduleBindingsExtractor>
		<packageBindingsExtractor line="136" static="1"><f a="b">
	<t path="haxe.framework._Injector.Bindings"/>
	<c path="Hash"><c path="Hash"><f a=""><d/></f></c></c>
</f></packageBindingsExtractor>
		<inject public="1" params="T" set="method" line="138" static="1"><f a="interf:?pos">
	<c path="Class"><c path="inject.T"/></c>
	<t path="haxe.PosInfos"/>
	<c path="inject.T"/>
</f></inject>
		<forever public="1" params="T" set="method" line="146" static="1"><f a="f">
	<f a="">
		<c path="haxe.framework.InjectorConfig"/>
		<c path="forever.T"/>
	</f>
	<c path="forever.T"/>
</f></forever>
		<enter public="1" params="T" set="method" line="158" static="1"><f a="f">
	<f a="">
		<c path="haxe.framework.InjectorConfig"/>
		<c path="enter.T"/>
	</f>
	<c path="enter.T"/>
</f></enter>
		<bindTo public="1" params="T:S" set="method" line="185" static="1">
			<f a="interf:impl:?bindingType">
				<c path="Class"><c path="bindTo.T"/></c>
				<c path="Class"><c path="bindTo.S"/></c>
				<e path="haxe.framework.BindingType"/>
				<e path="Void"/>
			</f>
			<haxe_doc> Globally binds the interface to the specified implementation.
   </haxe_doc>
		</bindTo>
		<bindToF public="1" params="T" set="method" line="191" static="1">
			<f a="interf:f:?bindingType">
				<c path="Class"><c path="bindToF.T"/></c>
				<f a=""><c path="bindToF.T"/></f>
				<e path="haxe.framework.BindingType"/>
				<e path="Void"/>
			</f>
			<haxe_doc> Globally binds the interface to the specified factory.
   </haxe_doc>
		</bindToF>
		<globally public="1" params="T" set="method" line="195" static="1"><f a=""><a>
	<bindToF><f a="interf:f:?bindingType">
	<c path="Class"><c path="globally.T"/></c>
	<f a=""><c path="globally.T"/></f>
	<e path="haxe.framework.BindingType"/>
	<e path="Void"/>
</f></bindToF>
	<bindTo><f a="interf:impl:?bindingType">
	<c path="Class"><c path="globally.T"/></c>
	<c path="Class"><d/></c>
	<e path="haxe.framework.BindingType"/>
	<e path="Void"/>
</f></bindTo>
</a></f></globally>
		<inClass public="1" params="T" set="method" line="215" static="1"><f a="c">
	<c path="Class"><d/></c>
	<a>
		<bindToF><f a="interf:f:?bindingType">
	<c path="Class"><c path="inClass.T"/></c>
	<f a=""><c path="inClass.T"/></f>
	<e path="haxe.framework.BindingType"/>
	<e path="Void"/>
</f></bindToF>
		<bindTo><f a="interf:impl:?bindingType">
	<c path="Class"><c path="inClass.T"/></c>
	<c path="Class"><d/></c>
	<e path="haxe.framework.BindingType"/>
	<e path="Void"/>
</f></bindTo>
	</a>
</f></inClass>
		<inModule public="1" params="T" set="method" line="227" static="1"><f a="moduleName">
	<c path="String"/>
	<a>
		<bindToF><f a="interf:f:?bindingType">
	<c path="Class"><c path="inModule.T"/></c>
	<f a=""><c path="inModule.T"/></f>
	<e path="haxe.framework.BindingType"/>
	<e path="Void"/>
</f></bindToF>
		<bindTo><f a="interf:impl:?bindingType">
	<c path="Class"><c path="inModule.T"/></c>
	<c path="Class"><d/></c>
	<e path="haxe.framework.BindingType"/>
	<e path="Void"/>
</f></bindTo>
	</a>
</f></inModule>
		<inPackage public="1" params="T" set="method" line="239" static="1"><f a="packageName">
	<c path="String"/>
	<a>
		<bindToF><f a="interf:f:?bindingType">
	<c path="Class"><c path="inPackage.T"/></c>
	<f a=""><c path="inPackage.T"/></f>
	<e path="haxe.framework.BindingType"/>
	<e path="Void"/>
</f></bindToF>
		<bindTo><f a="interf:impl:?bindingType">
	<c path="Class"><c path="inPackage.T"/></c>
	<c path="Class"><d/></c>
	<e path="haxe.framework.BindingType"/>
	<e path="Void"/>
</f></bindTo>
	</a>
</f></inPackage>
		<bindForSpecificF params="T" set="method" line="251" static="1"><f a="extractor:interf:specific:f:bindingType">
	<f a="">
		<t path="haxe.framework._Injector.Bindings"/>
		<c path="Hash"><c path="Hash"><f a=""><d/></f></c></c>
	</f>
	<c path="Class"><c path="bindForSpecificF.T"/></c>
	<c path="String"/>
	<f a=""><c path="bindForSpecificF.T"/></f>
	<e path="haxe.framework.BindingType"/>
	<e path="Void"/>
</f></bindForSpecificF>
		<getMostSpecificBinding set="method" line="261" static="1"><f a="c:pos">
	<c path="Class"><d/></c>
	<t path="haxe.PosInfos"/>
	<e path="Option"><f a=""><d/></f></e>
</f></getMostSpecificBinding>
		<getDefaultImplementationBinding set="method" line="269" static="1"><f a="c">
	<c path="Class"><d/></c>
	<e path="Option"><f a=""><d/></f></e>
</f></getDefaultImplementationBinding>
		<getGlobalBinding set="method" line="290" static="1"><f a="c">
	<c path="Class"><d/></c>
	<e path="Option"><f a=""><d/></f></e>
</f></getGlobalBinding>
		<getClassBinding set="method" line="298" static="1"><f a="c:className">
	<c path="Class"><d/></c>
	<c path="String"/>
	<e path="Option"><f a=""><d/></f></e>
</f></getClassBinding>
		<getModuleBinding set="method" line="302" static="1"><f a="c:moduleName">
	<c path="Class"><d/></c>
	<c path="String"/>
	<e path="Option"><f a=""><d/></f></e>
</f></getModuleBinding>
		<getPackageBinding set="method" line="306" static="1"><f a="c:packageName">
	<c path="Class"><d/></c>
	<c path="String"/>
	<e path="Option"><f a=""><d/></f></e>
</f></getPackageBinding>
		<addGlobalBinding set="method" line="310" static="1"><f a="c:f">
	<c path="Class"><d/></c>
	<f a=""><d/></f>
	<e path="Void"/>
</f></addGlobalBinding>
		<existsDefaultBinding set="method" line="314" static="1"><f a="c">
	<c path="Class"><d/></c>
	<e path="Bool"/>
</f></existsDefaultBinding>
		<addDefaultBinding set="method" line="318" static="1"><f a="c:f">
	<c path="Class"><d/></c>
	<e path="Option"><f a=""><d/></f></e>
	<e path="Void"/>
</f></addDefaultBinding>
		<getDefaultBinding set="method" line="322" static="1"><f a="c">
	<c path="Class"><d/></c>
	<e path="Option"><f a=""><d/></f></e>
</f></getDefaultBinding>
		<getSpecificBinding set="method" line="326" static="1"><f a="extractor:c:specific">
	<f a="">
		<t path="haxe.framework._Injector.Bindings"/>
		<c path="Hash"><c path="Hash"><f a=""><d/></f></c></c>
	</f>
	<c path="Class"><d/></c>
	<c path="String"/>
	<e path="Option"><f a=""><d/></f></e>
</f></getSpecificBinding>
		<addSpecificBinding set="method" line="340" static="1"><f a="bindings:c:specific:f">
	<c path="Hash"><c path="Hash"><f a=""><d/></f></c></c>
	<c path="Class"><d/></c>
	<c path="String"/>
	<f a=""><d/></f>
	<e path="Void"/>
</f></addSpecificBinding>
		<classOf set="method" line="352" static="1"><f a="pos">
	<t path="haxe.PosInfos"/>
	<c path="String"/>
</f></classOf>
		<packageOf set="method" line="356" static="1"><f a="pos">
	<t path="haxe.PosInfos"/>
	<c path="String"/>
</f></packageOf>
		<moduleOf set="method" line="360" static="1"><f a="pos">
	<t path="haxe.PosInfos"/>
	<c path="String"/>
</f></moduleOf>
		<factoryFor params="T" set="method" line="368" static="1"><f a="impl">
	<c path="Class"><c path="factoryFor.T"/></c>
	<f a=""><c path="factoryFor.T"/></f>
</f></factoryFor>
		<bindingTypeDef set="method" line="374" static="1"><f a="bindingType">
	<e path="haxe.framework.BindingType"/>
	<e path="haxe.framework.BindingType"/>
</f></bindingTypeDef>
	</class>
	<class path="haxe.framework._Injector.InjectorConfigImpl" params="" file="../src/main/haxe/haxe/framework/Injector.hx" private="1" module="haxe.framework.Injector">
		<implements path="haxe.framework.InjectorConfig"/>
		<bind public="1" params="T" set="method" line="384"><f a="interf:impl:?b">
	<c path="Class"><c path="bind.T"/></c>
	<c path="Class"><d/></c>
	<e path="haxe.framework.BindingType"/>
	<c path="haxe.framework.InjectorConfig"/>
</f></bind>
		<bindF public="1" params="T" set="method" line="390"><f a="interf:f:?b">
	<c path="Class"><c path="bindF.T"/></c>
	<f a=""><c path="bindF.T"/></f>
	<e path="haxe.framework.BindingType"/>
	<c path="haxe.framework.InjectorConfig"/>
</f></bindF>
		<inClass public="1" params="T" set="method" line="396"><f a="c">
	<c path="Class"><d/></c>
	<t path="haxe.framework.Binder">
		<c path="inClass.T"/>
		<c path="haxe.framework.InjectorConfig"/>
	</t>
</f></inClass>
		<inPackage public="1" params="T" set="method" line="414"><f a="p">
	<c path="String"/>
	<t path="haxe.framework.Binder">
		<c path="inPackage.T"/>
		<c path="haxe.framework.InjectorConfig"/>
	</t>
</f></inPackage>
		<inModule public="1" params="T" set="method" line="432"><f a="m">
	<c path="String"/>
	<t path="haxe.framework.Binder">
		<c path="inModule.T"/>
		<c path="haxe.framework.InjectorConfig"/>
	</t>
</f></inModule>
		<new public="1" set="method" line="381"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="neko.Lib" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/Lib.hx">
		<load public="1" set="method" line="32" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>
		Load and return a Neko primitive from a NDLL library.
	</haxe_doc>
		</load>
		<loadLazy public="1" set="method" line="36" static="1"><f a="lib:prim:nargs">
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
	<d/>
</f></loadLazy>
		<print public="1" set="method" line="47" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output.
	</haxe_doc>
		</print>
		<println public="1" set="method" line="54" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output followed by a newline character.
	</haxe_doc>
		</println>
		<rethrow public="1" set="method" line="62" static="1">
			<f a="e">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		Rethrow an exception. This is useful when manually filtering an exception in order
		to keep the previous exception stack.
	</haxe_doc>
		</rethrow>
		<serialize public="1" set="method" line="70" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Serialize using native Neko serialization. This will return a Binary string that can be
		stored for long term usage. The serialized data is optimized for speed and not for size.
	</haxe_doc>
		</serialize>
		<unserialize public="1" set="method" line="77" static="1">
			<f a="s">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a string using native Neko serialization. See [serialize].
	</haxe_doc>
		</unserialize>
		<localUnserialize public="1" set="method" line="88" static="1">
			<f a="s">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a string using native Neko serialization. See [serialize].
		This function assume that all the serialized data was serialized with current
		module, even if the module name was different. This can happen if you are unserializing
		some data into mod_neko that was serialized on a different server using a different
		file path.
	</haxe_doc>
		</localUnserialize>
		<nekoToHaxe public="1" set="method" line="98" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		Converts a Neko value to its haXe equivalent. Used for wrapping String and Arrays raw values into haXe Objects.
	</haxe_doc>
		</nekoToHaxe>
		<haxeToNeko public="1" set="method" line="130" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>
		Converts a Neko value to its haXe equivalent. Used to unwrap String and Arrays Objects into raw Neko values.
	</haxe_doc>
		</haxeToNeko>
		<getClasses public="1" set="method" line="165" static="1">
			<f a=""><d/></f>
			<haxe_doc>
		Returns an object containing all compiled packages and classes.
	</haxe_doc>
		</getClasses>
		<stringReference public="1" get="inline" set="null" line="172" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a string referencing the data contains in bytes.
	</haxe_doc>
		</stringReference>
		<bytesReference public="1" get="inline" set="null" line="179" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>
		Returns bytes referencing the content of a string.
	</haxe_doc>
		</bytesReference>
		<__serialize line="183" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></__serialize>
		<__unserialize line="184" static="1"><f a=":">
	<unknown/>
	<a>
		<loadprim><f a="p:n">
	<unknown/>
	<unknown/>
	<unknown/>
</f></loadprim>
		<loadmodule><f a="m:l">
	<unknown/>
	<unknown/>
	<unknown/>
</f></loadmodule>
	</a>
	<unknown/>
</f></__unserialize>
	</class>
	<class path="String" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/String.hx">
		<__is_String static="1"><e path="Bool"/></__is_String>
		<__split line="29" static="1"><d/></__split>
		<fromCharCode public="1" set="method" line="180" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<charAt public="1" set="method" line="46">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method" line="58">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method" line="64">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method" line="73">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method" line="88">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method" line="104">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toLowerCase public="1" set="method" line="130">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method" line="146">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toString public="1" set="method" line="162">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<__compare set="method" line="168"><f a="o">
	<c path="String"/>
	<c path="Int"/>
</f></__compare>
		<__add set="method" line="172"><f a="s">
	<d/>
	<c path="String"/>
</f></__add>
		<__radd set="method" line="176"><f a="s">
	<d/>
	<c path="String"/>
</f></__radd>
		<new public="1" set="method" line="37"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="haxe.text.json.JValueExtensions" params="" file="../src/main/haxe/haxe/text/json/JValueExtensions.hx">
		<fold public="1" params="T" set="method" line="26" static="1"><f a="v:initial:f">
	<e path="haxe.text.json.JValue"/>
	<c path="fold.T"/>
	<f a=":">
		<c path="fold.T"/>
		<e path="haxe.text.json.JValue"/>
		<c path="fold.T"/>
	</f>
	<c path="fold.T"/>
</f></fold>
		<path public="1" set="method" line="34" static="1"><f a="v:s">
	<e path="haxe.text.json.JValue"/>
	<c path="String"/>
	<e path="haxe.text.json.JValue"/>
</f></path>
		<map public="1" set="method" line="40" static="1"><f a="v:f">
	<e path="haxe.text.json.JValue"/>
	<f a="">
		<e path="haxe.text.json.JValue"/>
		<e path="haxe.text.json.JValue"/>
	</f>
	<e path="haxe.text.json.JValue"/>
</f></map>
		<getOption public="1" set="method" line="50" static="1"><f a="v:k">
	<e path="haxe.text.json.JValue"/>
	<c path="String"/>
	<e path="Option"><e path="haxe.text.json.JValue"/></e>
</f></getOption>
		<get public="1" set="method" line="61" static="1"><f a="v:k">
	<e path="haxe.text.json.JValue"/>
	<c path="String"/>
	<e path="haxe.text.json.JValue"/>
</f></get>
		<getOrElse public="1" set="method" line="67" static="1"><f a="v:k:def">
	<e path="haxe.text.json.JValue"/>
	<c path="String"/>
	<t path="Thunk"><e path="haxe.text.json.JValue"/></t>
	<e path="haxe.text.json.JValue"/>
</f></getOrElse>
		<extractString public="1" set="method" line="73" static="1"><f a="v">
	<e path="haxe.text.json.JValue"/>
	<c path="String"/>
</f></extractString>
		<extractNumber public="1" set="method" line="80" static="1"><f a="v">
	<e path="haxe.text.json.JValue"/>
	<c path="Float"/>
</f></extractNumber>
		<extractBool public="1" set="method" line="87" static="1"><f a="v">
	<e path="haxe.text.json.JValue"/>
	<e path="Bool"/>
</f></extractBool>
		<extractKey public="1" set="method" line="94" static="1"><f a="v">
	<e path="haxe.text.json.JValue"/>
	<c path="String"/>
</f></extractKey>
		<extractValue public="1" set="method" line="97" static="1"><f a="v">
	<e path="haxe.text.json.JValue"/>
	<e path="haxe.text.json.JValue"/>
</f></extractValue>
		<extractField public="1" set="method" line="100" static="1"><f a="v">
	<e path="haxe.text.json.JValue"/>
	<c path="Tuple2">
		<c path="String"/>
		<e path="haxe.text.json.JValue"/>
	</c>
</f></extractField>
		<extractHash public="1" set="method" line="107" static="1"><f a="v">
	<e path="haxe.text.json.JValue"/>
	<c path="Hash"><e path="haxe.text.json.JValue"/></c>
</f></extractHash>
		<extractFields public="1" set="method" line="123" static="1"><f a="v">
	<e path="haxe.text.json.JValue"/>
	<c path="Array"><c path="Tuple2">
	<c path="String"/>
	<e path="haxe.text.json.JValue"/>
</c></c>
</f></extractFields>
		<extractArray public="1" set="method" line="132" static="1"><f a="v">
	<e path="haxe.text.json.JValue"/>
	<c path="Array"><e path="haxe.text.json.JValue"/></c>
</f></extractArray>
	</class>
	<class path="haxe.functional.Foldable" params="A:B" file="../src/main/haxe/haxe/functional/Foldable.hx" interface="1">
		<empty public="1" params="C:D" set="method">
			<f a=""><c path="haxe.functional.Foldable">
	<c path="empty.C"/>
	<c path="empty.D"/>
</c></f>
			<haxe_doc> Creates an "empty" version of the foldable structure. </haxe_doc>
		</empty>
		<append public="1" set="method">
			<f a="b">
				<c path="haxe.functional.Foldable.B"/>
				<c path="haxe.functional.Foldable.A"/>
			</f>
			<haxe_doc> Append a value to the specified foldable and returns the result. </haxe_doc>
		</append>
		<foldl public="1" params="T" set="method">
			<f a="t:f">
				<c path="foldl.T"/>
				<f a=":">
					<c path="foldl.T"/>
					<c path="haxe.functional.Foldable.B"/>
					<c path="foldl.T"/>
				</f>
				<c path="foldl.T"/>
			</f>
			<haxe_doc> Left folds over the structure. </haxe_doc>
		</foldl>
		<haxe_doc><![CDATA[ A structure that can be folded over. The type system cannot enforce it, but
 * a structure that implements this interface should specify its own type as the
 * first type parameter; e.g.: Set<T> implements Foldable<Set<T>, T>
 ]]></haxe_doc>
	</class>
	<class path="haxe.data.collections.Collection" params="C:T" file="../src/main/haxe/haxe/data/collections/Collection.hx" interface="1">
		<implements path="haxe.functional.Foldable">
			<c path="haxe.data.collections.Collection.C"/>
			<c path="haxe.data.collections.Collection.T"/>
		</implements>
		<size public="1" set="method"><f a=""><c path="Int"/></f></size>
		<contains public="1" set="method"><f a="t">
	<c path="haxe.data.collections.Collection.T"/>
	<e path="Bool"/>
</f></contains>
		<add public="1" set="method"><f a="t">
	<c path="haxe.data.collections.Collection.T"/>
	<c path="haxe.data.collections.Collection.C"/>
</f></add>
		<addAll public="1" set="method"><f a="t">
	<t path="Iterable"><c path="haxe.data.collections.Collection.T"/></t>
	<c path="haxe.data.collections.Collection.C"/>
</f></addAll>
		<remove public="1" set="method"><f a="t">
	<c path="haxe.data.collections.Collection.T"/>
	<c path="haxe.data.collections.Collection.C"/>
</f></remove>
		<removeAll public="1" set="method"><f a="t">
	<t path="Iterable"><c path="haxe.data.collections.Collection.T"/></t>
	<c path="haxe.data.collections.Collection.C"/>
</f></removeAll>
		<haxe_doc> A collection is a foldable data structure with additional methods to add 
 * and remove elements, determine the size of the collection, and evaluate 
 * equality predicates on elements in the collection.
 </haxe_doc>
	</class>
	<class path="haxe.data.collections.List" params="T" file="../src/main/haxe/haxe/data/collections/List.hx">
		<implements path="haxe.data.collections.Collection">
			<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
			<c path="haxe.data.collections.List.T"/>
		</implements>
		<nil public="1" params="T" set="method" line="49" static="1"><f a="?order:?equal:?hash:?show">
	<t path="OrderFunction"><c path="nil.T"/></t>
	<t path="EqualFunction"><c path="nil.T"/></t>
	<t path="HashFunction"><c path="nil.T"/></t>
	<t path="ShowFunction"><c path="nil.T"/></t>
	<c path="haxe.data.collections.List"><c path="nil.T"/></c>
</f></nil>
		<create public="1" params="T" set="method" line="53" static="1"><f a="?order:?equal:?hash:?show">
	<t path="OrderFunction"><c path="create.T"/></t>
	<t path="EqualFunction"><c path="create.T"/></t>
	<t path="HashFunction"><c path="create.T"/></t>
	<t path="ShowFunction"><c path="create.T"/></t>
	<c path="haxe.data.collections.List"><c path="create.T"/></c>
</f></create>
		<factory public="1" params="T" set="method" line="58" static="1">
			<f a="?order:?equal:?hash:?show">
				<t path="OrderFunction"><c path="factory.T"/></t>
				<t path="EqualFunction"><c path="factory.T"/></t>
				<t path="HashFunction"><c path="factory.T"/></t>
				<t path="ShowFunction"><c path="factory.T"/></t>
				<t path="Factory"><c path="haxe.data.collections.List"><c path="factory.T"/></c></t>
			</f>
			<haxe_doc> Creates a factory for lists of the specified type. </haxe_doc>
		</factory>
		<extract public="1" params="A" set="method" line="394" static="1"><f a="v:e:?order:?equal:?hash:?show">
	<e path="haxe.text.json.JValue"/>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.A"/></t>
	<t path="OrderFunction"><c path="extract.A"/></t>
	<t path="EqualFunction"><c path="extract.A"/></t>
	<t path="HashFunction"><c path="extract.A"/></t>
	<t path="ShowFunction"><c path="extract.A"/></t>
	<c path="haxe.data.collections.List"><c path="extract.A"/></c>
</f></extract>
		<head public="1" get="getHead" set="null"><c path="haxe.data.collections.List.T"/></head>
		<tail public="1" get="getTail" set="null"><c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c></tail>
		<first public="1" get="getHead" set="null"><c path="haxe.data.collections.List.T"/></first>
		<last public="1" get="getLast" set="null"><c path="haxe.data.collections.List.T"/></last>
		<headOption public="1" get="getHeadOption" set="null"><e path="Option"><c path="haxe.data.collections.List.T"/></e></headOption>
		<firstOption public="1" get="getHeadOption" set="null"><e path="Option"><c path="haxe.data.collections.List.T"/></e></firstOption>
		<lastOption public="1" get="getLastOption" set="null"><e path="Option"><c path="haxe.data.collections.List.T"/></e></lastOption>
		<equal public="1" get="getEqual" set="null"><t path="EqualFunction"><c path="haxe.data.collections.List.T"/></t></equal>
		<order public="1" get="getOrder" set="null"><t path="OrderFunction"><c path="haxe.data.collections.List.T"/></t></order>
		<hash public="1" get="getHash" set="null"><t path="HashFunction"><c path="haxe.data.collections.List.T"/></t></hash>
		<show public="1" get="getShow" set="null"><t path="ShowFunction"><c path="haxe.data.collections.List.T"/></t></show>
		<empty public="1" params="C:D" set="method" line="71"><f a=""><c path="haxe.functional.Foldable">
	<c path="empty.C"/>
	<c path="empty.D"/>
</c></f></empty>
		<cons public="1" set="method" line="79">
			<f a="head">
				<c path="haxe.data.collections.List.T"/>
				<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
			</f>
			<haxe_doc> Prepends an element to the list. This method is dramatically faster than
   * appending an element to the end of the list. In general, you should
   * construct lists by prepending, and then reverse at the end if necessary.
   </haxe_doc>
		</cons>
		<prepend public="1" set="method" line="84">
			<f a="head">
				<c path="haxe.data.collections.List.T"/>
				<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
			</f>
			<haxe_doc> Synonym for cons. </haxe_doc>
		</prepend>
		<prependAll public="1" set="method" line="88"><f a="iterable">
	<t path="Iterable"><c path="haxe.data.collections.List.T"/></t>
	<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
</f></prependAll>
		<prependAllR public="1" set="method" line="100"><f a="iterable">
	<t path="Iterable"><c path="haxe.data.collections.List.T"/></t>
	<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
</f></prependAllR>
		<append public="1" set="method" line="108"><f a="b">
	<c path="haxe.data.collections.List.T"/>
	<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
</f></append>
		<foldl public="1" params="Z" set="method" line="112"><f a="z:f">
	<c path="foldl.Z"/>
	<f a=":">
		<c path="foldl.Z"/>
		<c path="haxe.data.collections.List.T"/>
		<c path="foldl.Z"/>
	</f>
	<c path="foldl.Z"/>
</f></foldl>
		<foldr public="1" params="Z" set="method" line="128">
			<f a="z:f">
				<c path="foldr.Z"/>
				<f a=":">
					<c path="haxe.data.collections.List.T"/>
					<c path="foldr.Z"/>
					<c path="foldr.Z"/>
				</f>
				<c path="foldr.Z"/>
			</f>
			<haxe_doc> A right fold. Right folds are much more efficient when folding to
   * another list.
   </haxe_doc>
		</foldr>
		<contains public="1" set="method" line="142"><f a="t">
	<c path="haxe.data.collections.List.T"/>
	<e path="Bool"/>
</f></contains>
		<add public="1" set="method" line="156">
			<f a="t">
				<c path="haxe.data.collections.List.T"/>
				<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
			</f>
			<haxe_doc> Adds an item to the end of the list. This is a slow method; for high performance,
   * the cons() method should be used to grow the list.
   </haxe_doc>
		</add>
		<addAll public="1" set="method" line="162"><f a="i">
	<t path="Iterable"><c path="haxe.data.collections.List.T"/></t>
	<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
</f></addAll>
		<remove public="1" set="method" line="178"><f a="t">
	<c path="haxe.data.collections.List.T"/>
	<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
</f></remove>
		<removeAll public="1" set="method" line="207"><f a="i">
	<t path="Iterable"><c path="haxe.data.collections.List.T"/></t>
	<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
</f></removeAll>
		<concat public="1" set="method" line="216">
			<f a="l">
				<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
				<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
			</f>
			<haxe_doc> Override Foldable to provide higher performance: </haxe_doc>
		</concat>
		<drop public="1" set="method" line="221">
			<f a="n">
				<c path="Int"/>
				<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
			</f>
			<haxe_doc> Override Foldable to provide higher performance: </haxe_doc>
		</drop>
		<dropWhile public="1" set="method" line="232">
			<f a="pred">
				<f a="">
					<c path="haxe.data.collections.List.T"/>
					<e path="Bool"/>
				</f>
				<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
			</f>
			<haxe_doc> Override Foldable to provide higher performance: </haxe_doc>
		</dropWhile>
		<take public="1" set="method" line="245">
			<f a="n">
				<c path="Int"/>
				<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
			</f>
			<haxe_doc> Override Foldable to provide higher performance: </haxe_doc>
		</take>
		<map public="1" params="B" set="method" line="250">
			<f a="f">
				<f a="">
					<c path="haxe.data.collections.List.T"/>
					<c path="map.B"/>
				</f>
				<c path="haxe.data.collections.List"><c path="map.B"/></c>
			</f>
			<haxe_doc> Override Foldable to provide higher performance: </haxe_doc>
		</map>
		<flatMap public="1" params="B" set="method" line="255">
			<f a="f">
				<f a="">
					<c path="haxe.data.collections.List.T"/>
					<t path="Iterable"><c path="flatMap.B"/></t>
				</f>
				<c path="haxe.data.collections.List"><c path="flatMap.B"/></c>
			</f>
			<haxe_doc> Override Foldable to provide higher performance: </haxe_doc>
		</flatMap>
		<filter public="1" set="method" line="260">
			<f a="f">
				<f a="">
					<c path="haxe.data.collections.List.T"/>
					<e path="Bool"/>
				</f>
				<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
			</f>
			<haxe_doc> Override Foldable to provide higher performance: </haxe_doc>
		</filter>
		<reverse public="1" set="method" line="266">
			<f a=""><c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c></f>
			<haxe_doc> Returns a list that contains all the elements of this list in reverse
   * order </haxe_doc>
		</reverse>
		<zip public="1" params="U" set="method" line="271">
			<f a="that">
				<c path="haxe.data.collections.List"><c path="zip.U"/></c>
				<c path="haxe.data.collections.List"><c path="Tuple2">
	<c path="haxe.data.collections.List.T"/>
	<c path="zip.U"/>
</c></c>
			</f>
			<haxe_doc> Zips this list and the specified list into a list of tuples. </haxe_doc>
		</zip>
		<gaps public="1" params="G" set="method" line="290">
			<f a="f:?equal">
				<f a=":">
					<c path="haxe.data.collections.List.T"/>
					<c path="haxe.data.collections.List.T"/>
					<c path="haxe.data.collections.List"><c path="gaps.G"/></c>
				</f>
				<t path="EqualFunction"><c path="gaps.G"/></t>
				<c path="haxe.data.collections.List"><c path="gaps.G"/></c>
			</f>
			<haxe_doc> Retrieves a list of gaps in this sequence.
   *
   * @param f Called with every two consecutive elements to retrieve a list of gaps.
   </haxe_doc>
		</gaps>
		<sort public="1" set="method" line="297">
			<f a=""><c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c></f>
			<haxe_doc> Returns a list that contains all the elements of this list, sorted by
   * the ordering function.
   </haxe_doc>
		</sort>
		<iterator public="1" set="method" line="309"><f a=""><t path="Iterator"><c path="haxe.data.collections.List.T"/></t></f></iterator>
		<withOrderFunction public="1" set="method" line="313"><f a="order">
	<t path="OrderFunction"><c path="haxe.data.collections.List.T"/></t>
	<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
</f></withOrderFunction>
		<withEqualFunction public="1" set="method" line="317"><f a="equal">
	<t path="EqualFunction"><c path="haxe.data.collections.List.T"/></t>
	<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
</f></withEqualFunction>
		<withHashFunction public="1" set="method" line="321"><f a="hash">
	<t path="HashFunction"><c path="haxe.data.collections.List.T"/></t>
	<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
</f></withHashFunction>
		<withShowFunction public="1" set="method" line="325"><f a="show">
	<t path="ShowFunction"><c path="haxe.data.collections.List.T"/></t>
	<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
</f></withShowFunction>
		<_equal><t path="EqualFunction"><c path="haxe.data.collections.List.T"/></t></_equal>
		<_order><t path="OrderFunction"><c path="haxe.data.collections.List.T"/></t></_order>
		<_hash><t path="HashFunction"><c path="haxe.data.collections.List.T"/></t></_hash>
		<_show><t path="ShowFunction"><c path="haxe.data.collections.List.T"/></t></_show>
		<getOrder set="method" line="333"><f a=""><t path="OrderFunction"><c path="haxe.data.collections.List.T"/></t></f></getOrder>
		<getEqual set="method" line="342"><f a=""><t path="EqualFunction"><c path="haxe.data.collections.List.T"/></t></f></getEqual>
		<getHash set="method" line="351"><f a=""><t path="HashFunction"><c path="haxe.data.collections.List.T"/></t></f></getHash>
		<getShow set="method" line="360"><f a=""><t path="ShowFunction"><c path="haxe.data.collections.List.T"/></t></f></getShow>
		<equals public="1" set="method" line="369"><f a="other">
	<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
	<e path="Bool"/>
</f></equals>
		<compare public="1" set="method" line="373"><f a="other">
	<c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c>
	<c path="Int"/>
</f></compare>
		<hashCode public="1" set="method" line="377"><f a=""><c path="Int"/></f></hashCode>
		<toString public="1" set="method" line="382"><f a=""><c path="String"/></f></toString>
		<size public="1" set="method" line="386"><f a=""><c path="Int"/></f></size>
		<decompose public="1" set="method" line="390"><f a=""><e path="haxe.text.json.JValue"/></f></decompose>
		<getHead set="method" line="402"><f a=""><c path="haxe.data.collections.List.T"/></f></getHead>
		<getLast set="method" line="406"><f a=""><c path="haxe.data.collections.List.T"/></f></getLast>
		<getHeadOption set="method" line="410"><f a=""><e path="Option"><c path="haxe.data.collections.List.T"/></e></f></getHeadOption>
		<getLastOption set="method" line="414"><f a=""><e path="Option"><c path="haxe.data.collections.List.T"/></e></f></getLastOption>
		<getTail set="method" line="418"><f a=""><c path="haxe.data.collections.List"><c path="haxe.data.collections.List.T"/></c></f></getTail>
		<new set="method" line="64"><f a="order:equal:hash:show">
	<t path="OrderFunction"><c path="haxe.data.collections.List.T"/></t>
	<t path="EqualFunction"><c path="haxe.data.collections.List.T"/></t>
	<t path="HashFunction"><c path="haxe.data.collections.List.T"/></t>
	<t path="ShowFunction"><c path="haxe.data.collections.List.T"/></t>
	<e path="Void"/>
</f></new>
		<haxe_doc> A classic immutable list built from cons and nil elements. </haxe_doc>
	</class>
	<class path="haxe.data.collections._List.Cons" params="T" file="../src/main/haxe/haxe/data/collections/List.hx" private="1" module="haxe.data.collections.List">
		<extends path="haxe.data.collections.List"><c path="haxe.data.collections._List.Cons.T"/></extends>
		<_head><c path="haxe.data.collections._List.Cons.T"/></_head>
		<_tail><c path="haxe.data.collections.List"><c path="haxe.data.collections._List.Cons.T"/></c></_tail>
		<_size><c path="Int"/></_size>
		<getHead set="method" line="435" override="1"><f a=""><c path="haxe.data.collections._List.Cons.T"/></f></getHead>
		<getLast set="method" line="439" override="1"><f a=""><c path="haxe.data.collections._List.Cons.T"/></f></getLast>
		<getTail set="method" line="449" override="1"><f a=""><c path="haxe.data.collections.List"><c path="haxe.data.collections._List.Cons.T"/></c></f></getTail>
		<getHeadOption set="method" line="453" override="1"><f a=""><e path="Option"><c path="haxe.data.collections._List.Cons.T"/></e></f></getHeadOption>
		<getLastOption set="method" line="457" override="1"><f a=""><e path="Option"><c path="haxe.data.collections._List.Cons.T"/></e></f></getLastOption>
		<size public="1" set="method" line="461" override="1"><f a=""><c path="Int"/></f></size>
		<new public="1" set="method" line="428"><f a="order:equal:hash:show:head:tail">
	<t path="OrderFunction"><c path="haxe.data.collections._List.Cons.T"/></t>
	<t path="EqualFunction"><c path="haxe.data.collections._List.Cons.T"/></t>
	<t path="HashFunction"><c path="haxe.data.collections._List.Cons.T"/></t>
	<t path="ShowFunction"><c path="haxe.data.collections._List.Cons.T"/></t>
	<c path="haxe.data.collections._List.Cons.T"/>
	<c path="haxe.data.collections.List"><c path="haxe.data.collections._List.Cons.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.data.collections._List.Nil" params="T" file="../src/main/haxe/haxe/data/collections/List.hx" private="1" module="haxe.data.collections.List">
		<extends path="haxe.data.collections.List"><c path="haxe.data.collections._List.Nil.T"/></extends>
		<new public="1" set="method" line="467"><f a="order:equal:hash:show">
	<t path="OrderFunction"><c path="haxe.data.collections._List.Nil.T"/></t>
	<t path="EqualFunction"><c path="haxe.data.collections._List.Nil.T"/></t>
	<t path="HashFunction"><c path="haxe.data.collections._List.Nil.T"/></t>
	<t path="ShowFunction"><c path="haxe.data.collections._List.Nil.T"/></t>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.reactive.SignalSignal" params="" file="../src/main/haxe/haxe/reactive/SignalSignal.hx">
		<switchS public="1" params="T" set="method" line="32" static="1">
			<f a="signal">
				<c path="haxe.reactive.Signal"><c path="haxe.reactive.Signal"><c path="switchS.T"/></c></c>
				<c path="haxe.reactive.Signal"><c path="switchS.T"/></c>
			</f>
			<haxe_doc>
     * Converts an Signal of Signals into
     * a single Signal, whose values represent 
     * those of the last Signal to have an Event.
     *
     * @param   streams     The Signal of 
     *                      Signals to be
     *                      flattened.
     </haxe_doc>
		</switchS>
		<join public="1" params="T" set="method" line="45" static="1">
			<f a="signal">
				<c path="haxe.reactive.Signal"><c path="haxe.reactive.Signal"><c path="join.T"/></c></c>
				<c path="haxe.reactive.Signal"><c path="join.T"/></c>
			</f>
			<haxe_doc>
     * Converts an Signal of Signals into
     * a single Signal, whose values represent 
     * those of the last Signal to have an Event.
     *
     * @param   streams     The Signal of 
     *                      Signals to be
     *                      flattened.
     </haxe_doc>
		</join>
		<flatten public="1" params="T" set="method" line="58" static="1">
			<f a="signal">
				<c path="haxe.reactive.Signal"><c path="haxe.reactive.Signal"><c path="flatten.T"/></c></c>
				<c path="haxe.reactive.Signal"><c path="flatten.T"/></c>
			</f>
			<haxe_doc>
     * Converts an Signal of Signals into
     * a single Signal, whose values represent 
     * those of the last Signal to have an Event.
     *
     * @param   streams     The Signal of 
     *                      Signals to be
     *                      flattened.
     </haxe_doc>
		</flatten>
		<new set="method" line="21"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.net.HttpResponseCodeExtensions" params="" file="../src/main/haxe/haxe/net/HttpResponseCodeExtensions.hx">
		<toHttpResponseCode public="1" set="method" line="23" static="1"><f a="code">
	<c path="Int"/>
	<e path="haxe.net.HttpResponseCode"/>
</f></toHttpResponseCode>
		<isNormal public="1" set="method" line="88" static="1"><f a="response">
	<e path="haxe.net.HttpResponseCode"/>
	<e path="Bool"/>
</f></isNormal>
		<isInformational public="1" set="method" line="96" static="1"><f a="response">
	<e path="haxe.net.HttpResponseCode"/>
	<e path="Bool"/>
</f></isInformational>
		<isSuccess public="1" set="method" line="108" static="1"><f a="response">
	<e path="haxe.net.HttpResponseCode"/>
	<e path="Bool"/>
</f></isSuccess>
		<isRedirection public="1" set="method" line="120" static="1"><f a="response">
	<e path="haxe.net.HttpResponseCode"/>
	<e path="Bool"/>
</f></isRedirection>
		<isError public="1" set="method" line="132" static="1"><f a="response">
	<e path="haxe.net.HttpResponseCode"/>
	<e path="Bool"/>
</f></isError>
		<isClientError public="1" set="method" line="140" static="1"><f a="response">
	<e path="haxe.net.HttpResponseCode"/>
	<e path="Bool"/>
</f></isClientError>
		<isServerError public="1" set="method" line="152" static="1"><f a="response">
	<e path="haxe.net.HttpResponseCode"/>
	<e path="Bool"/>
</f></isServerError>
		<toStatusCode public="1" set="method" line="164" static="1"><f a="response">
	<e path="haxe.net.HttpResponseCode"/>
	<c path="Int"/>
</f></toStatusCode>
	</class>
	<class path="neko.Sys" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/Sys.hx">
		<args public="1" set="method" line="29" static="1"><f a=""><c path="Array"><c path="String"/></c></f></args>
		<getEnv public="1" set="method" line="44" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></getEnv>
		<putEnv public="1" set="method" line="51" static="1"><f a="s:v">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></putEnv>
		<sleep public="1" set="method" line="55" static="1"><f a="seconds">
	<c path="Float"/>
	<e path="Void"/>
</f></sleep>
		<setTimeLocale public="1" set="method" line="59" static="1"><f a="loc">
	<c path="String"/>
	<e path="Bool"/>
</f></setTimeLocale>
		<getCwd public="1" set="method" line="63" static="1"><f a=""><c path="String"/></f></getCwd>
		<setCwd public="1" set="method" line="67" static="1"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></setCwd>
		<systemName public="1" set="method" line="71" static="1"><f a=""><c path="String"/></f></systemName>
		<escapeArgument public="1" set="method" line="75" static="1"><f a="arg">
	<c path="String"/>
	<c path="String"/>
</f></escapeArgument>
		<command public="1" set="method" line="89" static="1"><f a="cmd:?args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="Int"/>
</f></command>
		<exit public="1" set="method" line="98" static="1"><f a="code">
	<c path="Int"/>
	<e path="Void"/>
</f></exit>
		<time public="1" set="method" line="102" static="1"><f a=""><c path="Float"/></f></time>
		<cpuTime public="1" set="method" line="106" static="1"><f a=""><c path="Float"/></f></cpuTime>
		<executablePath public="1" set="method" line="110" static="1"><f a=""><c path="String"/></f></executablePath>
		<environment public="1" set="method" line="114" static="1"><f a=""><c path="Hash"><c path="String"/></c></f></environment>
		<get_env line="124" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></get_env>
		<put_env line="125" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<unknown/>
</f></put_env>
		<_sleep line="126" static="1"><f a="">
	<c path="Float"/>
	<unknown/>
</f></_sleep>
		<set_time_locale line="127" static="1"><f a="">
	<unknown/>
	<e path="Bool"/>
</f></set_time_locale>
		<get_cwd line="128" static="1"><f a=""><c path="String"/></f></get_cwd>
		<set_cwd line="129" static="1"><f a="">
	<unknown/>
	<unknown/>
</f></set_cwd>
		<sys_string line="130" static="1"><f a=""><c path="String"/></f></sys_string>
		<sys_command line="131" static="1"><f a="">
	<unknown/>
	<c path="Int"/>
</f></sys_command>
		<sys_exit line="132" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></sys_exit>
		<sys_time line="133" static="1"><f a=""><c path="Float"/></f></sys_time>
		<sys_cpu_time line="134" static="1"><f a=""><c path="Float"/></f></sys_cpu_time>
		<sys_exe_path line="135" static="1"><f a=""><c path="String"/></f></sys_exe_path>
		<sys_env line="136" static="1"><f a=""><c path="Array"><d/></c></f></sys_env>
	</class>
	<class path="haxe.test.TestCase" params="" file="../src/main/haxe/haxe/test/TestCase.hx">
		<before public="1" set="method" line="30"><f a=""><e path="Void"/></f></before>
		<after public="1" set="method" line="33"><f a=""><e path="Void"/></f></after>
		<beforeAll public="1" set="method" line="36"><f a=""><e path="Void"/></f></beforeAll>
		<afterAll public="1" set="method" line="39"><f a=""><e path="Void"/></f></afterAll>
		<not public="1" params="T" set="method" line="42"><f a="c">
	<t path="haxe.test.MustMatcher"><c path="not.T"/></t>
	<t path="haxe.test.MustMatcher"><c path="not.T"/></t>
</f></not>
		<assertThat public="1" params="T" set="method" line="46"><f a="obj:cond:?msg:?pos">
	<c path="assertThat.T"/>
	<t path="haxe.test.MustMatcher"><c path="assertThat.T"/></t>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertThat>
		<assertTrue public="1" set="method" line="50"><f a="cond:?msg:?pos">
	<e path="Bool"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertTrue>
		<assertFalse public="1" set="method" line="54"><f a="value:?msg:?pos">
	<e path="Bool"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertFalse>
		<assertNull public="1" set="method" line="58"><f a="value:?msg:?pos">
	<d/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertNull>
		<assertNotNull public="1" set="method" line="62"><f a="value:?msg:?pos">
	<d/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertNotNull>
		<assertIs public="1" set="method" line="66"><f a="value:type:?msg:?pos">
	<d/>
	<d/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertIs>
		<assertNotEquals public="1" set="method" line="70"><f a="expected:value:?msg:?pos">
	<d/>
	<d/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertNotEquals>
		<assertEquals public="1" params="T" set="method" line="74"><f a="expected:value:?equal:?msg:?pos">
	<c path="assertEquals.T"/>
	<c path="assertEquals.T"/>
	<f a=":">
		<c path="assertEquals.T"/>
		<c path="assertEquals.T"/>
		<e path="Bool"/>
	</f>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertEquals>
		<assertMatches public="1" set="method" line="83"><f a="pattern:value:?msg:?pos">
	<c path="EReg"/>
	<d/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertMatches>
		<assertFloatEquals public="1" set="method" line="87"><f a="expected:value:?approx:?msg:?pos">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertFloatEquals>
		<assertLooksLike public="1" set="method" line="91"><f a="expected:value:?recursive:?msg:?pos">
	<a/>
	<a/>
	<e path="Bool"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertLooksLike>
		<assertThrowsException public="1" set="method" line="95"><f a="method:?type:?msg:?pos">
	<f a=""><e path="Void"/></f>
	<c path="Class"><d/></c>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertThrowsException>
		<assertEqualsOneOf public="1" params="T" set="method" line="99"><f a="value:possibilities:?msg:?pos">
	<c path="assertEqualsOneOf.T"/>
	<c path="Array"><c path="assertEqualsOneOf.T"/></c>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertEqualsOneOf>
		<assertContains public="1" params="T" set="method" line="103"><f a="values:match:?msg:?pos">
	<t path="Iterable"><c path="assertContains.T"/></t>
	<c path="assertContains.T"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertContains>
		<assertNotContains public="1" params="T" set="method" line="107"><f a="values:match:?msg:?pos">
	<t path="Iterable"><c path="assertNotContains.T"/></t>
	<c path="assertNotContains.T"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertNotContains>
		<assertStringContains public="1" set="method" line="111"><f a="match:value:?msg:?pos">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertStringContains>
		<assertStringSequence public="1" set="method" line="115"><f a="sequence:value:?msg:?pos">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertStringSequence>
		<assertDelivered public="1" params="T" set="method" line="119"><f a="future:assertions:?timeout">
	<c path="Future"><c path="assertDelivered.T"/></c>
	<f a="">
		<c path="assertDelivered.T"/>
		<e path="Void"/>
	</f>
	<c path="Int"/>
	<e path="Void"/>
</f></assertDelivered>
		<assertCanceled public="1" params="T" set="method" line="123"><f a="future:assertions:?timeout">
	<c path="Future"><c path="assertCanceled.T"/></c>
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<e path="Void"/>
</f></assertCanceled>
		<assertNotDelivered public="1" params="T" set="method" line="127"><f a="future:?timeout:?pos">
	<c path="Future"><c path="assertNotDelivered.T"/></c>
	<c path="Int"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assertNotDelivered>
		<fail public="1" set="method" line="131"><f a="?msg:?pos">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></fail>
		<warn public="1" set="method" line="135"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></warn>
		<new public="1" set="method" line="27"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.test.TestResult" params="" file="../src/main/haxe/haxe/test/TestResult.hx">
		<ofHandler public="1" set="method" line="33" static="1"><f a="handler">
	<c path="haxe.test.TestHandler"><d/></c>
	<c path="haxe.test.TestResult"/>
</f></ofHandler>
		<pack public="1"><c path="String"/></pack>
		<cls public="1"><c path="String"/></cls>
		<method public="1"><c path="String"/></method>
		<setup public="1"><c path="String"/></setup>
		<teardown public="1"><c path="String"/></teardown>
		<assertations public="1"><c path="List"><e path="haxe.test.Assertation"/></c></assertations>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
* @todo add documentation
</haxe_doc>
	</class>
	<class path="List" params="T" file="C:\World\Stack\os\win\programs\lingos\haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" set="method" line="80">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" set="method" line="88">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" set="method" line="98">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" set="method" line="193">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" set="method" line="212">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="228">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<enum path="Void" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="C:\World\Stack\os\win\programs\lingos\haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="C:\World\Stack\os\win\programs\lingos\haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="C:\World\Stack\os\win\programs\lingos\haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\World\Stack\os\win\programs\lingos\haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\World\Stack\os\win\programs\lingos\haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<class path="neko.Web" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/Web.hx">
		<getParams public="1" set="method" line="36" static="1">
			<f a=""><c path="Hash"><c path="String"/></c></f>
			<haxe_doc>
		Returns the GET and POST parameters.
	</haxe_doc>
		</getParams>
		<getParamValues public="1" set="method" line="53" static="1">
			<f a="param">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns an Array of Strings built using GET / POST values.
		If you have in your URL the parameters [a[]=foo;a[]=hello;a[5]=bar;a[3]=baz] then
		[neko.Web.getParamValues("a")] will return [["foo","hello",null,"baz",null,"bar"]]
	</haxe_doc>
		</getParamValues>
		<getHostName public="1" set="method" line="80" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the local server host name
	</haxe_doc>
		</getHostName>
		<getClientIP public="1" set="method" line="87" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Surprisingly returns the client IP address.
	</haxe_doc>
		</getClientIP>
		<getURI public="1" set="method" line="94" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the original request URL (before any server internal redirections)
	</haxe_doc>
		</getURI>
		<redirect public="1" set="method" line="101" static="1">
			<f a="url">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Tell the client to redirect to the given url ("Location" header)
	</haxe_doc>
		</redirect>
		<setHeader public="1" set="method" line="109" static="1">
			<f a="h:v">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an output header value. If some data have been printed, the headers have
		already been sent so this will raise an exception.
	</haxe_doc>
		</setHeader>
		<setReturnCode public="1" set="method" line="116" static="1">
			<f a="r">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the HTTP return code. Same remark as setHeader.
	</haxe_doc>
		</setReturnCode>
		<getClientHeader public="1" set="method" line="123" static="1">
			<f a="k">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Retrieve a client header value sent with the request.
	</haxe_doc>
		</getClientHeader>
		<getClientHeaders public="1" set="method" line="133" static="1">
			<f a=""><c path="List"><a>
	<value><c path="String"/></value>
	<header><c path="String"/></header>
</a></c></f>
			<haxe_doc>
		Retrieve all the client headers.
	</haxe_doc>
		</getClientHeaders>
		<getParamsString public="1" set="method" line="146" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns all the GET parameters String
	</haxe_doc>
		</getParamsString>
		<getPostData public="1" set="method" line="159" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns all the POST data. POST Data is always parsed as
		being application/x-www-form-urlencoded and is stored into
		the getParams hashtable. POST Data is maximimized to 256K
		unless the content type is multipart/form-data. In that
		case, you will have to use [getMultipart] or [parseMultipart]
		methods.
	</haxe_doc>
		</getPostData>
		<getCookies public="1" set="method" line="170" static="1">
			<f a=""><c path="Hash"><c path="String"/></c></f>
			<haxe_doc>
		Returns an hashtable of all Cookies sent by the client.
		Modifying the hashtable will not modify the cookie, use setCookie instead.
	</haxe_doc>
		</getCookies>
		<setCookie public="1" set="method" line="186" static="1">
			<f a="key:value:?expire:?domain:?path:?secure">
				<c path="String"/>
				<c path="String"/>
				<c path="Date"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a Cookie value in the HTTP headers. Same remark as setHeader.
	</haxe_doc>
		</setCookie>
		<addPair set="method" line="197" static="1"><f a="buf:name:value">
	<c path="StringBuf"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></addPair>
		<getAuthorization public="1" set="method" line="207" static="1">
			<f a=""><a>
	<user><c path="String"/></user>
	<pass><c path="String"/></pass>
</a></f>
			<haxe_doc>
		Returns an object with the authorization sent by the client (Basic scheme only).
	</haxe_doc>
		</getAuthorization>
		<getCwd public="1" set="method" line="225" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Get the current script directory in the local filesystem.
	</haxe_doc>
		</getCwd>
		<cacheModule public="1" set="method" line="233" static="1">
			<f a="f">
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the main entry point function used to handle requests.
		Setting it back to null will disable code caching.
	</haxe_doc>
		</cacheModule>
		<getMultipart public="1" set="method" line="241" static="1">
			<f a="maxSize">
				<c path="Int"/>
				<c path="Hash"><c path="String"/></c>
			</f>
			<haxe_doc>
		Get the multipart parameters as an hashtable. The data
		cannot exceed the maximum size specified.
	</haxe_doc>
		</getMultipart>
		<parseMultipart public="1" set="method" line="270" static="1">
			<f a="onPart:onData">
				<f a=":">
					<c path="String"/>
					<c path="String"/>
					<e path="Void"/>
				</f>
				<f a="::">
					<c path="haxe.io.Bytes"/>
					<c path="Int"/>
					<c path="Int"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Parse the multipart data. Call [onPart] when a new part is found
		with the part name and the filename if present
		and [onData] when some part data is readed. You can this way
		directly save the data on hard drive in the case of a file upload.
	</haxe_doc>
		</parseMultipart>
		<flush public="1" set="method" line="281" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Flush the data sent to the client. By default on Apache, outgoing data is buffered so
		this can be useful for displaying some long operation progress.
	</haxe_doc>
		</flush>
		<getMethod public="1" set="method" line="288" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Get the HTTP method used by the client. This api requires Neko 1.7.1+
	</haxe_doc>
		</getMethod>
		<logMessage public="1" set="method" line="295" static="1">
			<f a="msg">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Write a message into the web server log file. This api requires Neko 1.7.1+
	</haxe_doc>
		</logMessage>
		<isModNeko public="1" set="null" static="1"><e path="Bool"/></isModNeko>
		<isTora public="1" set="null" static="1"><e path="Bool"/></isTora>
		<_set_main static="1"><d/></_set_main>
		<_get_host_name static="1"><d/></_get_host_name>
		<_get_client_ip static="1"><d/></_get_client_ip>
		<_get_uri static="1"><d/></_get_uri>
		<_cgi_redirect static="1"><d/></_cgi_redirect>
		<_cgi_set_header static="1"><d/></_cgi_set_header>
		<_set_return_code static="1"><d/></_set_return_code>
		<_get_client_header static="1"><d/></_get_client_header>
		<_get_params_string static="1"><d/></_get_params_string>
		<_get_post_data static="1"><d/></_get_post_data>
		<_get_params static="1"><d/></_get_params>
		<_get_cookies static="1"><d/></_get_cookies>
		<_set_cookie static="1"><d/></_set_cookie>
		<_get_cwd static="1"><d/></_get_cwd>
		<_parse_multipart static="1"><d/></_parse_multipart>
		<_flush static="1"><d/></_flush>
		<_get_client_headers static="1"><d/></_get_client_headers>
		<_get_http_method static="1"><d/></_get_http_method>
		<_base_decode line="320" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<c path="String"/>
</f></_base_decode>
		<_log_message static="1"><d/></_log_message>
		<haxe_doc>
	This class is used for accessing the local Web server and the current
	client request and informations.
</haxe_doc>
	</class>
	<typedef path="haxe.io.http.HttpResponse" params="T" file="../src/main/haxe/haxe/io/http/Http.hx" module="haxe.io.http.Http"><a>
	<headers><c path="haxe.data.collections.Map">
	<c path="String"/>
	<c path="String"/>
</c></headers>
	<code><e path="haxe.net.HttpResponseCode"/></code>
	<body><e path="Option"><c path="haxe.io.http.HttpResponse.T"/></e></body>
</a></typedef>
	<class path="haxe.io.http.Http" params="T" file="../src/main/haxe/haxe/io/http/Http.hx" interface="1">
		<get public="1" set="method"><f a="url:?params:?headers">
	<t path="haxe.net.Url"/>
	<t path="haxe.net.QueryParameters"/>
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="String"/>
	</c>
	<c path="Future"><t path="haxe.io.http.HttpResponse"><c path="haxe.io.http.Http.T"/></t></c>
</f></get>
		<post public="1" set="method"><f a="url:data:?params:?headers">
	<t path="haxe.net.Url"/>
	<c path="haxe.io.http.Http.T"/>
	<t path="haxe.net.QueryParameters"/>
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="String"/>
	</c>
	<c path="Future"><t path="haxe.io.http.HttpResponse"><c path="haxe.io.http.Http.T"/></t></c>
</f></post>
		<put public="1" set="method"><f a="url:data:?params:?headers">
	<t path="haxe.net.Url"/>
	<c path="haxe.io.http.Http.T"/>
	<t path="haxe.net.QueryParameters"/>
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="String"/>
	</c>
	<c path="Future"><t path="haxe.io.http.HttpResponse"><c path="haxe.io.http.Http.T"/></t></c>
</f></put>
		<delete public="1" set="method"><f a="url:?params:?headers">
	<t path="haxe.net.Url"/>
	<t path="haxe.net.QueryParameters"/>
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="String"/>
	</c>
	<c path="Future"><t path="haxe.io.http.HttpResponse"><c path="haxe.io.http.Http.T"/></t></c>
</f></delete>
		<custom public="1" set="method"><f a="request:url:data:?params:?headers">
	<c path="String"/>
	<t path="haxe.net.Url"/>
	<c path="haxe.io.http.Http.T"/>
	<t path="haxe.net.QueryParameters"/>
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="String"/>
	</c>
	<c path="Future"><t path="haxe.io.http.HttpResponse"><c path="haxe.io.http.Http.T"/></t></c>
</f></custom>
		<haxe_doc> An interface for performing HTTP requests - GET, POST, PUT, and DELETE. The
 * interface is generic in the type of the request/response data, because some
 * implementations (e.g. JSONP on the JavaScript target) can only deal with 
 * certain kinds of data.
 </haxe_doc>
	</class>
	<class path="haxe.reactive.Streams" params="" file="../src/main/haxe/haxe/reactive/Streams.hx">
		<create public="1" params="I:O" set="method" line="36" static="1">
			<f a="updater:?sources">
				<f a="">
					<c path="haxe.reactive.Pulse"><c path="create.I"/></c>
					<e path="haxe.reactive.Propagation"><c path="create.O"/></e>
				</f>
				<t path="Iterable"><c path="haxe.reactive.Stream"><c path="create.I"/></c></t>
				<c path="haxe.reactive.Stream"><c path="create.O"/></c>
			</f>
			<haxe_doc>
     * Creates a new stream with the specified updater and optional sources.
     *
     * @param updater   The updater.
     * @param sources   (Optional) The sources.
     *
     </haxe_doc>
		</create>
		<identity public="1" params="T" set="method" line="46" static="1">
			<f a="?sources">
				<t path="Iterable"><c path="haxe.reactive.Stream"><c path="identity.T"/></c></t>
				<c path="haxe.reactive.Stream"><c path="identity.T"/></c>
			</f>
			<haxe_doc>
     * Creates a new stream that merely propagates all pulses it receives.
     *
     * @param sources
     </haxe_doc>
		</identity>
		<zero public="1" params="T" set="method" line="55" static="1">
			<f a=""><c path="haxe.reactive.Stream"><c path="zero.T"/></c></f>
			<haxe_doc>
     * Creates an event stream that will never have any events. Calling 
     * sendEvent() on such a stream will throw an exception.
     </haxe_doc>
		</zero>
		<one public="1" params="T" set="method" line="62" static="1">
			<f a="val">
				<c path="one.T"/>
				<c path="haxe.reactive.Stream"><c path="one.T"/></c>
			</f>
			<haxe_doc>
     * Creates an event stream that will send a single value.
     </haxe_doc>
		</one>
		<merge public="1" params="T" set="method" line="86" static="1">
			<f a="streams">
				<t path="Iterable"><c path="haxe.reactive.Stream"><c path="merge.T"/></c></t>
				<c path="haxe.reactive.Stream"><c path="merge.T"/></c>
			</f>
			<haxe_doc>
     * Merges the specified streams, or returns a zero stream if there are no 
     * streams.
     </haxe_doc>
		</merge>
		<constant public="1" params="I:O" set="method" line="98" static="1">
			<f a="value:?sources">
				<c path="constant.O"/>
				<t path="Iterable"><c path="haxe.reactive.Stream"><c path="constant.I"/></c></t>
				<c path="haxe.reactive.Stream"><c path="constant.O"/></c>
			</f>
			<haxe_doc>
     * Retrieves a constant stream. If sources are specified, events from the
     * sources will be mapped to the constant.
     *
     * @param value     The constant.
     * @param sources   (Optional) Source streams.
     </haxe_doc>
		</constant>
		<receiver public="1" set="method" line="111" static="1">
			<f a=""><c path="haxe.reactive.Stream"><unknown/></c></f>
			<haxe_doc>
     * Creates a "receiver" stream whose sole purpose is to be used in 
     * combination with sendEvent().
     </haxe_doc>
		</receiver>
		<cond public="1" params="T" set="method" line="129" static="1">
			<f a="conditions">
				<t path="Iterable"><c path="Tuple2">
	<c path="haxe.reactive.Stream"><e path="Bool"/></c>
	<c path="haxe.reactive.Stream"><c path="cond.T"/></c>
</c></t>
				<c path="haxe.reactive.Stream"><c path="cond.T"/></c>
			</f>
			<haxe_doc><![CDATA[
     * Switches off of an Stream of Bools, returning
     * the specified Stream<T> when true
     * 
     *
     * @param conditions    An Iterable of Tuple2s, composed of a
     *                      true/false Stream and an 'if true' 
     *                      Stream that will be returned if 
     *                      Tuple._1 == 'true.'
     *
     * @return              If 'conditions' contains aTuple2._1 
     *                      == 'true', Stream<T> else a
     *                      zero Stream.
     ]]></haxe_doc>
		</cond>
		<timer public="1" set="method" line="142" static="1">
			<f a="time">
				<c path="Int"/>
				<c path="haxe.reactive.Stream"><c path="Int"/></c>
			</f>
			<haxe_doc>
     * Creates a stream of time events, spaced out by the specified number of
     * milliseconds.
     *
     * @param time The number of milliseconds.
     </haxe_doc>
		</timer>
		<timerS public="1" set="method" line="152" static="1">
			<f a="time">
				<c path="haxe.reactive.Signal"><c path="Int"/></c>
				<c path="haxe.reactive.Stream"><c path="Int"/></c>
			</f>
			<haxe_doc>
     * Creates a stream of time events, spaced out by the specified number of
     * milliseconds.
     *
     * @param time The number of milliseconds.
     </haxe_doc>
		</timerS>
		<zipN public="1" params="T" set="method" line="180" static="1">
			<f a="streams">
				<t path="Iterable"><c path="haxe.reactive.Stream"><c path="zipN.T"/></c></t>
				<c path="haxe.reactive.Stream"><t path="Iterable"><c path="zipN.T"/></t></c>
			</f>
			<haxe_doc>
     * Zips together the specified streams.
     </haxe_doc>
		</zipN>
		<randomS public="1" set="method" line="219" static="1">
			<f a="time">
				<c path="haxe.reactive.Signal"><c path="Int"/></c>
				<c path="haxe.reactive.Stream"><c path="Float"/></c>
			</f>
			<haxe_doc>
     * Creates a stream of random number events, separated by the specified 
     * number of milliseconds.
     </haxe_doc>
		</randomS>
		<random public="1" set="method" line="227" static="1">
			<f a="time">
				<c path="Int"/>
				<c path="haxe.reactive.Stream"><c path="Float"/></c>
			</f>
			<haxe_doc>
     * Creates a stream of random number events, separated by the specified 
     * number of milliseconds.
     </haxe_doc>
		</random>
		<new set="method" line="27"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="haxe.concurrent.ActorStatus" params="" file="../src/main/haxe/haxe/concurrent/Actor.hx" module="haxe.concurrent.Actor">
		<Stopped/>
		<Running/>
		<Failed/>
	</enum>
	<class path="haxe.concurrent.Actor" params="T:S" file="../src/main/haxe/haxe/concurrent/Actor.hx" interface="1">
		<status public="1" set="method">
			<f a=""><e path="haxe.concurrent.ActorStatus"/></f>
			<haxe_doc> The status of the actor. </haxe_doc>
		</status>
		<start public="1" set="method">
			<f a=""><c path="Future"><c path="haxe.concurrent.Actor">
	<c path="haxe.concurrent.Actor.T"/>
	<c path="haxe.concurrent.Actor.S"/>
</c></c></f>
			<haxe_doc> Starts the actor, if it is not already running. </haxe_doc>
		</start>
		<stop public="1" set="method">
			<f a=""><c path="Future"><c path="haxe.concurrent.Actor">
	<c path="haxe.concurrent.Actor.T"/>
	<c path="haxe.concurrent.Actor.S"/>
</c></c></f>
			<haxe_doc> Stops the actor, if it is not already running. </haxe_doc>
		</stop>
		<load public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc> Returns a number from 0 to 1 indicating load on the actor. </haxe_doc>
		</load>
		<send public="1" set="method">
			<f a="data">
				<c path="haxe.concurrent.Actor.T"/>
				<c path="Future"><c path="haxe.concurrent.Actor.S"/></c>
			</f>
			<haxe_doc> Sends data to the actor, and returns a future of the response. </haxe_doc>
		</send>
		<haxe_doc> An actor.
 </haxe_doc>
	</class>
	<typedef path="haxe.concurrent.Coalescer" params="T" file="../src/main/haxe/haxe/concurrent/Actor.hx" module="haxe.concurrent.Actor"><a>
	<commutes><f a=":">
	<c path="haxe.concurrent.Coalescer.T"/>
	<c path="haxe.concurrent.Coalescer.T"/>
	<e path="Bool"/>
</f></commutes>
	<coalesce><f a=":">
	<c path="haxe.concurrent.Coalescer.T"/>
	<c path="haxe.concurrent.Coalescer.T"/>
	<e path="Option"><c path="haxe.concurrent.Coalescer.T"/></e>
</f></coalesce>
</a></typedef>
	<class path="haxe.concurrent.ActorFactory" params="T:S" file="../src/main/haxe/haxe/concurrent/Actor.hx" module="haxe.concurrent.Actor" interface="1">
		<create public="1" params="X" set="method">
			<f a="handler:?coalescer">
				<f a=":">
					<c path="create.X"/>
					<c path="haxe.concurrent.ActorFactory.T"/>
					<c path="Tuple2">
						<c path="create.X"/>
						<c path="Future"><c path="haxe.concurrent.ActorFactory.S"/></c>
					</c>
				</f>
				<t path="haxe.concurrent.Coalescer"><c path="haxe.concurrent.ActorFactory.T"/></t>
				<c path="haxe.concurrent.Actor">
					<c path="haxe.concurrent.ActorFactory.T"/>
					<c path="haxe.concurrent.ActorFactory.S"/>
				</c>
			</f>
			<haxe_doc> Creates an actor using a function that will be called to handle every 
   * message the actor receives. The function should not enclose any variables
   * and should maintain state exclusively through its parameter and return value.
   *
   * @param handler   The message handler. This function will be passed the 
   *                  current state and the current message, and should return
   *                  the next state and a future of the response.
   *
   * @param coalescer An optional function to coalesce adjacent messages in 
   *                  the actor's queue.
   </haxe_doc>
		</create>
		<createStateless public="1" set="method">
			<f a="loop:?coalescer">
				<f a="">
					<c path="haxe.concurrent.ActorFactory.T"/>
					<c path="Future"><c path="haxe.concurrent.ActorFactory.S"/></c>
				</f>
				<t path="haxe.concurrent.Coalescer"><c path="haxe.concurrent.ActorFactory.T"/></t>
				<c path="haxe.concurrent.Actor">
					<c path="haxe.concurrent.ActorFactory.T"/>
					<c path="haxe.concurrent.ActorFactory.S"/>
				</c>
			</f>
			<haxe_doc> Creates a stateless actor (an actor that requires no initial state, and 
   * does not produce any state.
   </haxe_doc>
		</createStateless>
		<haxe_doc> Tries to coalesce the two elements into a single element </haxe_doc>
	</class>
	<class path="haxe.test.ui.common.IReport" params="T" file="../src/main/haxe/haxe/test/ui/common/IReport.hx" interface="1">
		<displaySuccessResults public="1"><e path="haxe.test.ui.common.SuccessResultsDisplayMode"/></displaySuccessResults>
		<displayHeader public="1"><e path="haxe.test.ui.common.HeaderDisplayMode"/></displayHeader>
		<setHandler public="1" set="method"><f a="handler">
	<f a="">
		<c path="haxe.test.ui.common.IReport.T"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setHandler>
	</class>
	<class path="haxe.test.ui.text.HtmlReport" params="" file="../src/main/haxe/haxe/test/ui/text/HtmlReport.hx">
		<implements path="haxe.test.ui.common.IReport"><c path="haxe.test.ui.text.HtmlReport"/></implements>
		<platform line="48" static="1"><c path="String"/></platform>
		<traceRedirected public="1" set="null"><e path="Bool"/></traceRedirected>
		<displaySuccessResults public="1"><e path="haxe.test.ui.common.SuccessResultsDisplayMode"/></displaySuccessResults>
		<displayHeader public="1"><e path="haxe.test.ui.common.HeaderDisplayMode"/></displayHeader>
		<handler public="1"><f a="">
	<c path="haxe.test.ui.text.HtmlReport"/>
	<e path="Void"/>
</f></handler>
		<aggregator><c path="haxe.test.ui.common.ResultAggregator"/></aggregator>
		<oldTrace><d/></oldTrace>
		<_traces><c path="Array"><a>
	<time><c path="Float"/></time>
	<stack><c path="Array"><e path="haxe.StackItem"/></c></stack>
	<msg><c path="String"/></msg>
	<infos><t path="haxe.PosInfos"/></infos>
	<delta><c path="Float"/></delta>
</a></c></_traces>
		<setHandler public="1" set="method" line="73"><f a="handler">
	<f a="">
		<c path="haxe.test.ui.text.HtmlReport"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setHandler>
		<redirectTrace public="1" set="method" line="77"><f a=""><e path="Void"/></f></redirectTrace>
		<restoreTrace public="1" set="method" line="85"><f a=""><e path="Void"/></f></restoreTrace>
		<_traceTime><t path="Null"><c path="Float"/></t></_traceTime>
		<_trace set="method" line="92"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></_trace>
		<startTime><c path="Float"/></startTime>
		<start set="method" line="106"><f a="e">
	<c path="haxe.test.Runner"/>
	<e path="Void"/>
</f></start>
		<cls set="method" line="110"><f a="stats">
	<c path="haxe.test.ui.common.ResultStats"/>
	<c path="String"/>
</f></cls>
		<resultNumbers set="method" line="121"><f a="buf:stats">
	<c path="StringBuf"/>
	<c path="haxe.test.ui.common.ResultStats"/>
	<e path="Void"/>
</f></resultNumbers>
		<blockNumbers set="method" line="153"><f a="buf:stats">
	<c path="StringBuf"/>
	<c path="haxe.test.ui.common.ResultStats"/>
	<e path="Void"/>
</f></blockNumbers>
		<formatStack set="method" line="159"><f a="stack:?addNL">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<e path="Bool"/>
	<c path="String"/>
</f></formatStack>
		<addFixture set="method" line="180"><f a="buf:result:name:isOk">
	<c path="StringBuf"/>
	<c path="haxe.test.ui.common.FixtureResult"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addFixture>
		<addClass set="method" line="227"><f a="buf:result:name:isOk">
	<c path="StringBuf"/>
	<c path="haxe.test.ui.common.ClassResult"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addClass>
		<addPackages set="method" line="240"><f a="buf:result:isOk">
	<c path="StringBuf"/>
	<c path="haxe.test.ui.common.PackageResult"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addPackages>
		<addPackage set="method" line="249"><f a="buf:result:name:isOk">
	<c path="StringBuf"/>
	<c path="haxe.test.ui.common.PackageResult"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addPackage>
		<getHeader public="1" set="method" line="262"><f a=""><c path="String"/></f></getHeader>
		<getTrace public="1" set="method" line="285"><f a=""><c path="String"/></f></getTrace>
		<getResults public="1" set="method" line="312"><f a=""><c path="String"/></f></getResults>
		<getAll public="1" set="method" line="318"><f a=""><c path="String"/></f></getAll>
		<getHtml public="1" set="method" line="325"><f a="?title">
	<c path="String"/>
	<c path="String"/>
</f></getHtml>
		<result><c path="haxe.test.ui.common.PackageResult"/></result>
		<complete set="method" line="336"><f a="result">
	<c path="haxe.test.ui.common.PackageResult"/>
	<e path="Void"/>
</f></complete>
		<formatTime set="method" line="342"><f a="t">
	<c path="Float"/>
	<c path="String"/>
</f></formatTime>
		<cssStyle set="method" line="346"><f a=""><c path="String"/></f></cssStyle>
		<jsScript set="method" line="556"><f a=""><c path="String"/></f></jsScript>
		<wrapHtml set="method" line="590"><f a="title:s">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></wrapHtml>
		<_handler set="method" line="598"><f a="report">
	<c path="haxe.test.ui.text.HtmlReport"/>
	<e path="Void"/>
</f></_handler>
		<new public="1" set="method" line="59"><f a="runner:?outputHandler:?traceRedirected">
	<c path="haxe.test.Runner"/>
	<f a="">
		<c path="haxe.test.ui.text.HtmlReport"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
* @todo add documentation
</haxe_doc>
	</class>
	<class path="haxe.io.http.HttpTransformer" params="S:T" file="../src/main/haxe/haxe/io/http/HttpTransformer.hx">
		<implements path="haxe.io.http.Http"><c path="haxe.io.http.HttpTransformer.T"/></implements>
		<http><c path="haxe.io.http.Http"><c path="haxe.io.http.HttpTransformer.S"/></c></http>
		<encoder><f a="">
	<c path="haxe.io.http.HttpTransformer.T"/>
	<c path="haxe.io.http.HttpTransformer.S"/>
</f></encoder>
		<decoder><f a="">
	<c path="haxe.io.http.HttpTransformer.S"/>
	<c path="haxe.io.http.HttpTransformer.T"/>
</f></decoder>
		<mimeType><c path="String"/></mimeType>
		<get public="1" set="method" line="40"><f a="url:?params:?headers">
	<t path="haxe.net.Url"/>
	<t path="haxe.net.QueryParameters"/>
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="String"/>
	</c>
	<c path="Future"><t path="haxe.io.http.HttpResponse"><c path="haxe.io.http.HttpTransformer.T"/></t></c>
</f></get>
		<post public="1" set="method" line="44"><f a="url:data:?params:?headers">
	<t path="haxe.net.Url"/>
	<c path="haxe.io.http.HttpTransformer.T"/>
	<t path="haxe.net.QueryParameters"/>
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="String"/>
	</c>
	<c path="Future"><t path="haxe.io.http.HttpResponse"><c path="haxe.io.http.HttpTransformer.T"/></t></c>
</f></post>
		<put public="1" set="method" line="48"><f a="url:data:?params:?headers">
	<t path="haxe.net.Url"/>
	<c path="haxe.io.http.HttpTransformer.T"/>
	<t path="haxe.net.QueryParameters"/>
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="String"/>
	</c>
	<c path="Future"><t path="haxe.io.http.HttpResponse"><c path="haxe.io.http.HttpTransformer.T"/></t></c>
</f></put>
		<delete public="1" set="method" line="52"><f a="url:?params:?headers">
	<t path="haxe.net.Url"/>
	<t path="haxe.net.QueryParameters"/>
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="String"/>
	</c>
	<c path="Future"><t path="haxe.io.http.HttpResponse"><c path="haxe.io.http.HttpTransformer.T"/></t></c>
</f></delete>
		<custom public="1" set="method" line="56"><f a="method:url:data:?params:?headers">
	<c path="String"/>
	<t path="haxe.net.Url"/>
	<c path="haxe.io.http.HttpTransformer.T"/>
	<t path="haxe.net.QueryParameters"/>
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="String"/>
	</c>
	<c path="Future"><t path="haxe.io.http.HttpResponse"><c path="haxe.io.http.HttpTransformer.T"/></t></c>
</f></custom>
		<transformResponse public="1" set="method" line="60"><f a="r">
	<t path="haxe.io.http.HttpResponse"><c path="haxe.io.http.HttpTransformer.S"/></t>
	<t path="haxe.io.http.HttpResponse"><c path="haxe.io.http.HttpTransformer.T"/></t>
</f></transformResponse>
		<addMimeType set="method" line="68"><f a="map_">
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="String"/>
	</c>
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="String"/>
	</c>
</f></addMimeType>
		<new public="1" set="method" line="33"><f a="http:encoder:decoder:mimeType">
	<c path="haxe.io.http.Http"><c path="haxe.io.http.HttpTransformer.S"/></c>
	<f a="">
		<c path="haxe.io.http.HttpTransformer.T"/>
		<c path="haxe.io.http.HttpTransformer.S"/>
	</f>
	<f a="">
		<c path="haxe.io.http.HttpTransformer.S"/>
		<c path="haxe.io.http.HttpTransformer.T"/>
	</f>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="EReg" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/EReg.hx">
		<regexp_new_options line="157" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<unknown/>
</f></regexp_new_options>
		<regexp_match line="158" static="1"><f a=":::">
	<d/>
	<unknown/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></regexp_match>
		<regexp_matched line="159" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<c path="String"/>
</f></regexp_matched>
		<regexp_matched_pos line="160" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<a>
		<pos><c path="Int"/></pos>
		<len><c path="Int"/></len>
	</a>
</f></regexp_matched_pos>
		<r><d/></r>
		<last><c path="String"/></last>
		<global><e path="Bool"/></global>
		<match public="1" set="method" line="40">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the regular expression matches the String.
		Updates the internal state accordingly.
	</haxe_doc>
		</match>
		<matched public="1" set="method" line="49">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.
	</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="54">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was as the left of
		of the matched substring.
	</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="59">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was at the right of
		of the matched substring.
	</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="65">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>
		Returns the position of the matched substring within the
		original matched string.
	</haxe_doc>
		</matchedPos>
		<split public="1" set="method" line="69">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split a string by using the regular expression to match
		the separators.
	</haxe_doc>
		</split>
		<replace public="1" set="method" line="93">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.
	</haxe_doc>
		</replace>
		<customReplace public="1" set="method" line="144">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>
		For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.
	</haxe_doc>
		</customReplace>
		<new public="1" set="method" line="32"><f a="r:opt">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.
</haxe_doc>
	</class>
	<class path="haxe.net.UrlExtensions" params="" file="../src/main/haxe/haxe/net/UrlExtensions.hx">
		<UrlPattern line="30" static="1"><c path="EReg"/></UrlPattern>
		<Protocol line="32" static="1"><c path="Int"/></Protocol>
		<Hostname line="33" static="1"><c path="Int"/></Hostname>
		<Port line="34" static="1"><c path="Int"/></Port>
		<Pathname line="35" static="1"><c path="Int"/></Pathname>
		<Search line="36" static="1"><c path="Int"/></Search>
		<Hash line="37" static="1"><c path="Int"/></Hash>
		<toParsedUrl public="1" set="method" line="41" static="1">
			<f a="s">
				<c path="String"/>
				<e path="Option"><t path="haxe.net.ParsedUrl"/></e>
			</f>
			<haxe_doc> Tries to parse the url, returning None if unsuccessful.
   </haxe_doc>
		</toParsedUrl>
		<toUrl public="1" set="method" line="59" static="1">
			<f a="parsed">
				<t path="haxe.net.ParsedUrl"/>
				<t path="haxe.net.Url"/>
			</f>
			<haxe_doc> Converts a parsed url into a Url in standard string form.
   </haxe_doc>
		</toUrl>
		<withProtocol public="1" set="method" line="63" static="1"><f a="parsed:protocol">
	<t path="haxe.net.ParsedUrl"/>
	<c path="String"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withProtocol>
		<withHostname public="1" set="method" line="67" static="1"><f a="parsed:hostname">
	<t path="haxe.net.ParsedUrl"/>
	<c path="String"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withHostname>
		<withPort public="1" set="method" line="71" static="1"><f a="parsed:port">
	<t path="haxe.net.ParsedUrl"/>
	<c path="String"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withPort>
		<withPathname public="1" set="method" line="75" static="1"><f a="parsed:pathname">
	<t path="haxe.net.ParsedUrl"/>
	<c path="String"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withPathname>
		<withSearch public="1" set="method" line="79" static="1"><f a="parsed:search">
	<t path="haxe.net.ParsedUrl"/>
	<c path="String"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withSearch>
		<withSubdomains public="1" set="method" line="83" static="1"><f a="parsed:subdomains">
	<t path="haxe.net.ParsedUrl"/>
	<c path="String"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withSubdomains>
		<withHash public="1" set="method" line="98" static="1"><f a="parsed:hash">
	<t path="haxe.net.ParsedUrl"/>
	<c path="String"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withHash>
		<withFile public="1" set="method" line="102" static="1"><f a="parsed:file">
	<t path="haxe.net.ParsedUrl"/>
	<c path="String"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withFile>
		<withoutProtocol public="1" set="method" line="110" static="1"><f a="parsed">
	<t path="haxe.net.ParsedUrl"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withoutProtocol>
		<withoutHostname public="1" set="method" line="114" static="1"><f a="parsed">
	<t path="haxe.net.ParsedUrl"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withoutHostname>
		<withoutPort public="1" set="method" line="118" static="1"><f a="parsed">
	<t path="haxe.net.ParsedUrl"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withoutPort>
		<withoutPathname public="1" set="method" line="122" static="1"><f a="parsed">
	<t path="haxe.net.ParsedUrl"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withoutPathname>
		<withoutSearch public="1" set="method" line="126" static="1"><f a="parsed">
	<t path="haxe.net.ParsedUrl"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withoutSearch>
		<withoutSubdomains public="1" set="method" line="130" static="1"><f a="parsed">
	<t path="haxe.net.ParsedUrl"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withoutSubdomains>
		<withoutHash public="1" set="method" line="134" static="1"><f a="parsed">
	<t path="haxe.net.ParsedUrl"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withoutHash>
		<withoutFile public="1" set="method" line="138" static="1"><f a="parsed">
	<t path="haxe.net.ParsedUrl"/>
	<t path="haxe.net.ParsedUrl"/>
</f></withoutFile>
		<addQueryParameters public="1" set="method" line="144" static="1">
			<f a="url:params">
				<t path="haxe.net.Url"/>
				<t path="haxe.net.QueryParameters"/>
				<t path="haxe.net.Url"/>
			</f>
			<haxe_doc> Adds query parameters to an existing URL.
   </haxe_doc>
		</addQueryParameters>
		<extractQueryParameters public="1" set="method" line="157" static="1"><f a="url">
	<t path="haxe.net.Url"/>
	<t path="haxe.net.QueryParameters"/>
</f></extractQueryParameters>
		<extractSearch public="1" set="method" line="161" static="1"><f a="url">
	<t path="haxe.net.Url"/>
	<c path="String"/>
</f></extractSearch>
		<extractProtocol public="1" set="method" line="165" static="1"><f a="url">
	<t path="haxe.net.Url"/>
	<c path="String"/>
</f></extractProtocol>
		<extractHash public="1" set="method" line="169" static="1"><f a="url">
	<t path="haxe.net.Url"/>
	<c path="String"/>
</f></extractHash>
		<extractPathname public="1" set="method" line="173" static="1"><f a="url">
	<t path="haxe.net.Url"/>
	<c path="String"/>
</f></extractPathname>
		<extractHostname public="1" set="method" line="177" static="1"><f a="url">
	<t path="haxe.net.Url"/>
	<c path="String"/>
</f></extractHostname>
		<extractHost public="1" set="method" line="181" static="1"><f a="url">
	<t path="haxe.net.Url"/>
	<c path="String"/>
</f></extractHost>
		<extractPort public="1" set="method" line="185" static="1"><f a="url">
	<t path="haxe.net.Url"/>
	<c path="Int"/>
</f></extractPort>
		<toQueryParameters public="1" set="method" line="192" static="1">
			<f a="query">
				<c path="String"/>
				<t path="haxe.net.QueryParameters"/>
			</f>
			<haxe_doc> Converts a query string, which must begin with '?', into an anonymous 
   * object, whose fields all have string values.
   </haxe_doc>
		</toQueryParameters>
		<toQueryString public="1" set="method" line="208" static="1">
			<f a="query">
				<t path="haxe.net.QueryParameters"/>
				<c path="String"/>
			</f>
			<haxe_doc> Converts an anonymous object, whose fields all have string values, into a
   * query string, beginning with the character '?'.
   </haxe_doc>
		</toQueryString>
		<formUrl set="method" line="219" static="1"><f a="protocol:hostname:port:pathname:search:hash">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<t path="haxe.net.ParsedUrl"/>
</f></formUrl>
		<extractField set="method" line="235" static="1"><f a="url:field">
	<t path="haxe.net.Url"/>
	<c path="String"/>
	<c path="String"/>
</f></extractField>
	</class>
	<class path="haxe.test.ui.common.ResultAggregator" params="" file="../src/main/haxe/haxe/test/ui/common/ResultAggregator.hx">
		<runner><c path="haxe.test.Runner"/></runner>
		<flattenPackage><e path="Bool"/></flattenPackage>
		<root public="1" set="null"><c path="haxe.test.ui.common.PackageResult"/></root>
		<onStart public="1" set="null"><c path="haxe.test.Notifier"/></onStart>
		<onComplete public="1" set="null"><c path="haxe.test.Dispatcher"><c path="haxe.test.ui.common.PackageResult"/></c></onComplete>
		<onProgress public="1" set="null"><c path="haxe.test.Dispatcher"><a>
	<totals><c path="Int"/></totals>
	<done><c path="Int"/></done>
</a></c></onProgress>
		<start set="method" line="48"><f a="runner">
	<c path="haxe.test.Runner"/>
	<e path="Void"/>
</f></start>
		<getOrCreatePackage set="method" line="53"><f a="pack:flat:?ref">
	<c path="String"/>
	<e path="Bool"/>
	<c path="haxe.test.ui.common.PackageResult"/>
	<c path="haxe.test.ui.common.PackageResult"/>
</f></getOrCreatePackage>
		<getOrCreateClass set="method" line="71"><f a="pack:cls:setup:teardown">
	<c path="haxe.test.ui.common.PackageResult"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<t path="Null"><c path="haxe.test.ui.common.ClassResult"/></t>
</f></getOrCreateClass>
		<createFixture set="method" line="78"><f a="result">
	<c path="haxe.test.TestResult"/>
	<c path="haxe.test.ui.common.FixtureResult"/>
</f></createFixture>
		<progress set="method" line="85"><f a="e">
	<a>
		<totals><c path="Int"/></totals>
		<result set="null"><c path="haxe.test.TestResult"/></result>
		<done><c path="Int"/></done>
	</a>
	<e path="Void"/>
</f></progress>
		<complete set="method" line="90"><f a="runner">
	<c path="haxe.test.Runner"/>
	<e path="Void"/>
</f></complete>
		<new public="1" set="method" line="35"><f a="runner:?flattenPackage">
	<c path="haxe.test.Runner"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
* @todo add documentation
* @todo add tests for this class
</haxe_doc>
	</class>
	<typedef path="haxe.data.transcode.ExtractorFunction" params="I:O" file="../src/main/haxe/haxe/data/transcode/Transcode.hx" module="haxe.data.transcode.Transcode"><t path="Function">
	<c path="haxe.data.transcode.ExtractorFunction.I"/>
	<c path="haxe.data.transcode.ExtractorFunction.O"/>
</t></typedef>
	<typedef path="haxe.data.transcode.DecomposerFunction" params="I:O" file="../src/main/haxe/haxe/data/transcode/Transcode.hx" module="haxe.data.transcode.Transcode"><t path="Function">
	<c path="haxe.data.transcode.DecomposerFunction.I"/>
	<c path="haxe.data.transcode.DecomposerFunction.O"/>
</t></typedef>
	<class path="haxe.functional.PartialFunction1" params="A:Z" file="../src/main/haxe/haxe/functional/PartialFunction.hx" module="haxe.functional.PartialFunction" interface="1">
		<isDefinedAt public="1" set="method"><f a="a">
	<c path="haxe.functional.PartialFunction1.A"/>
	<e path="Bool"/>
</f></isDefinedAt>
		<orElse public="1" set="method"><f a="that">
	<c path="haxe.functional.PartialFunction1">
		<c path="haxe.functional.PartialFunction1.A"/>
		<c path="haxe.functional.PartialFunction1.Z"/>
	</c>
	<c path="haxe.functional.PartialFunction1">
		<c path="haxe.functional.PartialFunction1.A"/>
		<c path="haxe.functional.PartialFunction1.Z"/>
	</c>
</f></orElse>
		<orAlways public="1" set="method"><f a="f">
	<f a="">
		<c path="haxe.functional.PartialFunction1.A"/>
		<c path="haxe.functional.PartialFunction1.Z"/>
	</f>
	<c path="haxe.functional.PartialFunction1">
		<c path="haxe.functional.PartialFunction1.A"/>
		<c path="haxe.functional.PartialFunction1.Z"/>
	</c>
</f></orAlways>
		<orAlwaysC public="1" set="method"><f a="z">
	<t path="Thunk"><c path="haxe.functional.PartialFunction1.Z"/></t>
	<c path="haxe.functional.PartialFunction1">
		<c path="haxe.functional.PartialFunction1.A"/>
		<c path="haxe.functional.PartialFunction1.Z"/>
	</c>
</f></orAlwaysC>
		<call public="1" set="method"><f a="a">
	<c path="haxe.functional.PartialFunction1.A"/>
	<c path="haxe.functional.PartialFunction1.Z"/>
</f></call>
		<toFunction public="1" set="method"><f a=""><f a="">
	<c path="haxe.functional.PartialFunction1.A"/>
	<e path="Option"><c path="haxe.functional.PartialFunction1.Z"/></e>
</f></f></toFunction>
	</class>
	<class path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl" params="A:Z" file="../src/main/haxe/haxe/functional/PartialFunctionExtensions.hx" private="1" module="haxe.functional.PartialFunctionExtensions">
		<implements path="haxe.functional.PartialFunction1">
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.A"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.Z"/>
		</implements>
		<create public="1" params="A:Z" set="method" line="27" static="1"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a="">
		<c path="create.A"/>
		<e path="Bool"/>
	</f>
	<f a="">
		<c path="create.A"/>
		<c path="create.Z"/>
	</f>
</c></c>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl">
		<c path="create.A"/>
		<c path="create.Z"/>
	</c>
</f></create>
		<_def><c path="Array"><c path="Tuple2">
	<f a="">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.A"/>
		<e path="Bool"/>
	</f>
	<f a="">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.Z"/>
	</f>
</c></c></_def>
		<isDefinedAt public="1" set="method" line="35"><f a="a">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.A"/>
	<e path="Bool"/>
</f></isDefinedAt>
		<orElse public="1" set="method" line="43"><f a="that">
	<c path="haxe.functional.PartialFunction1">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.Z"/>
	</c>
	<c path="haxe.functional.PartialFunction1">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.Z"/>
	</c>
</f></orElse>
		<orAlways public="1" set="method" line="49"><f a="f">
	<f a="">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.Z"/>
	</f>
	<c path="haxe.functional.PartialFunction1">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.Z"/>
	</c>
</f></orAlways>
		<orAlwaysC public="1" set="method" line="55"><f a="z">
	<t path="Thunk"><c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.Z"/></t>
	<c path="haxe.functional.PartialFunction1">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.Z"/>
	</c>
</f></orAlwaysC>
		<call public="1" set="method" line="61"><f a="a">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.A"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.Z"/>
</f></call>
		<toFunction public="1" set="method" line="69"><f a=""><f a="">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.A"/>
	<e path="Option"><c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.Z"/></e>
</f></f></toFunction>
		<new set="method" line="31"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a="">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.A"/>
		<e path="Bool"/>
	</f>
	<f a="">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl.Z"/>
	</f>
</c></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.functional.PartialFunction1ImplExtensions" params="" file="../src/main/haxe/haxe/functional/PartialFunctionExtensions.hx" module="haxe.functional.PartialFunctionExtensions"><toPartialFunction public="1" params="A:Z" set="method" line="80" static="1"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a="">
		<c path="toPartialFunction.A"/>
		<e path="Bool"/>
	</f>
	<f a="">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.Z"/>
	</f>
</c></c>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction1Impl">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.Z"/>
	</c>
</f></toPartialFunction></class>
	<class path="haxe.functional.PartialFunction2" params="A:B:Z" file="../src/main/haxe/haxe/functional/PartialFunction.hx" module="haxe.functional.PartialFunction" interface="1">
		<isDefinedAt public="1" set="method"><f a="a:b">
	<c path="haxe.functional.PartialFunction2.A"/>
	<c path="haxe.functional.PartialFunction2.B"/>
	<e path="Bool"/>
</f></isDefinedAt>
		<orElse public="1" set="method"><f a="that">
	<c path="haxe.functional.PartialFunction2">
		<c path="haxe.functional.PartialFunction2.A"/>
		<c path="haxe.functional.PartialFunction2.B"/>
		<c path="haxe.functional.PartialFunction2.Z"/>
	</c>
	<c path="haxe.functional.PartialFunction2">
		<c path="haxe.functional.PartialFunction2.A"/>
		<c path="haxe.functional.PartialFunction2.B"/>
		<c path="haxe.functional.PartialFunction2.Z"/>
	</c>
</f></orElse>
		<orAlways public="1" set="method"><f a="f">
	<f a=":">
		<c path="haxe.functional.PartialFunction2.A"/>
		<c path="haxe.functional.PartialFunction2.B"/>
		<c path="haxe.functional.PartialFunction2.Z"/>
	</f>
	<c path="haxe.functional.PartialFunction2">
		<c path="haxe.functional.PartialFunction2.A"/>
		<c path="haxe.functional.PartialFunction2.B"/>
		<c path="haxe.functional.PartialFunction2.Z"/>
	</c>
</f></orAlways>
		<orAlwaysC public="1" set="method"><f a="z">
	<t path="Thunk"><c path="haxe.functional.PartialFunction2.Z"/></t>
	<c path="haxe.functional.PartialFunction2">
		<c path="haxe.functional.PartialFunction2.A"/>
		<c path="haxe.functional.PartialFunction2.B"/>
		<c path="haxe.functional.PartialFunction2.Z"/>
	</c>
</f></orAlwaysC>
		<call public="1" set="method"><f a="a:b">
	<c path="haxe.functional.PartialFunction2.A"/>
	<c path="haxe.functional.PartialFunction2.B"/>
	<c path="haxe.functional.PartialFunction2.Z"/>
</f></call>
		<toFunction public="1" set="method"><f a=""><f a=":">
	<c path="haxe.functional.PartialFunction2.A"/>
	<c path="haxe.functional.PartialFunction2.B"/>
	<e path="Option"><c path="haxe.functional.PartialFunction2.Z"/></e>
</f></f></toFunction>
	</class>
	<class path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl" params="A:B:Z" file="../src/main/haxe/haxe/functional/PartialFunctionExtensions.hx" private="1" module="haxe.functional.PartialFunctionExtensions">
		<implements path="haxe.functional.PartialFunction2">
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.A"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.B"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.Z"/>
		</implements>
		<create public="1" params="A:B:Z" set="method" line="88" static="1"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a=":">
		<c path="create.A"/>
		<c path="create.B"/>
		<e path="Bool"/>
	</f>
	<f a=":">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.Z"/>
	</f>
</c></c>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.Z"/>
	</c>
</f></create>
		<_def><c path="Array"><c path="Tuple2">
	<f a=":">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.B"/>
		<e path="Bool"/>
	</f>
	<f a=":">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.Z"/>
	</f>
</c></c></_def>
		<isDefinedAt public="1" set="method" line="96"><f a="a:b">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.A"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.B"/>
	<e path="Bool"/>
</f></isDefinedAt>
		<orElse public="1" set="method" line="104"><f a="that">
	<c path="haxe.functional.PartialFunction2">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.Z"/>
	</c>
	<c path="haxe.functional.PartialFunction2">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.Z"/>
	</c>
</f></orElse>
		<orAlways public="1" set="method" line="110"><f a="f">
	<f a=":">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.Z"/>
	</f>
	<c path="haxe.functional.PartialFunction2">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.Z"/>
	</c>
</f></orAlways>
		<orAlwaysC public="1" set="method" line="116"><f a="z">
	<t path="Thunk"><c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.Z"/></t>
	<c path="haxe.functional.PartialFunction2">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.Z"/>
	</c>
</f></orAlwaysC>
		<call public="1" set="method" line="122"><f a="a:b">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.A"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.B"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.Z"/>
</f></call>
		<toFunction public="1" set="method" line="130"><f a=""><f a=":">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.A"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.B"/>
	<e path="Option"><c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.Z"/></e>
</f></f></toFunction>
		<new set="method" line="92"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a=":">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.B"/>
		<e path="Bool"/>
	</f>
	<f a=":">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl.Z"/>
	</f>
</c></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.functional.PartialFunction2ImplExtensions" params="" file="../src/main/haxe/haxe/functional/PartialFunctionExtensions.hx" module="haxe.functional.PartialFunctionExtensions"><toPartialFunction public="1" params="A:B:Z" set="method" line="141" static="1"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a=":">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.B"/>
		<e path="Bool"/>
	</f>
	<f a=":">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.B"/>
		<c path="toPartialFunction.Z"/>
	</f>
</c></c>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction2Impl">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.B"/>
		<c path="toPartialFunction.Z"/>
	</c>
</f></toPartialFunction></class>
	<class path="haxe.functional.PartialFunction3" params="A:B:C:Z" file="../src/main/haxe/haxe/functional/PartialFunction.hx" module="haxe.functional.PartialFunction" interface="1">
		<isDefinedAt public="1" set="method"><f a="a:b:c">
	<c path="haxe.functional.PartialFunction3.A"/>
	<c path="haxe.functional.PartialFunction3.B"/>
	<c path="haxe.functional.PartialFunction3.C"/>
	<e path="Bool"/>
</f></isDefinedAt>
		<orElse public="1" set="method"><f a="that">
	<c path="haxe.functional.PartialFunction3">
		<c path="haxe.functional.PartialFunction3.A"/>
		<c path="haxe.functional.PartialFunction3.B"/>
		<c path="haxe.functional.PartialFunction3.C"/>
		<c path="haxe.functional.PartialFunction3.Z"/>
	</c>
	<c path="haxe.functional.PartialFunction3">
		<c path="haxe.functional.PartialFunction3.A"/>
		<c path="haxe.functional.PartialFunction3.B"/>
		<c path="haxe.functional.PartialFunction3.C"/>
		<c path="haxe.functional.PartialFunction3.Z"/>
	</c>
</f></orElse>
		<orAlways public="1" set="method"><f a="f">
	<f a="::">
		<c path="haxe.functional.PartialFunction3.A"/>
		<c path="haxe.functional.PartialFunction3.B"/>
		<c path="haxe.functional.PartialFunction3.C"/>
		<c path="haxe.functional.PartialFunction3.Z"/>
	</f>
	<c path="haxe.functional.PartialFunction3">
		<c path="haxe.functional.PartialFunction3.A"/>
		<c path="haxe.functional.PartialFunction3.B"/>
		<c path="haxe.functional.PartialFunction3.C"/>
		<c path="haxe.functional.PartialFunction3.Z"/>
	</c>
</f></orAlways>
		<orAlwaysC public="1" set="method"><f a="z">
	<t path="Thunk"><c path="haxe.functional.PartialFunction3.Z"/></t>
	<c path="haxe.functional.PartialFunction3">
		<c path="haxe.functional.PartialFunction3.A"/>
		<c path="haxe.functional.PartialFunction3.B"/>
		<c path="haxe.functional.PartialFunction3.C"/>
		<c path="haxe.functional.PartialFunction3.Z"/>
	</c>
</f></orAlwaysC>
		<call public="1" set="method"><f a="a:b:c">
	<c path="haxe.functional.PartialFunction3.A"/>
	<c path="haxe.functional.PartialFunction3.B"/>
	<c path="haxe.functional.PartialFunction3.C"/>
	<c path="haxe.functional.PartialFunction3.Z"/>
</f></call>
		<toFunction public="1" set="method"><f a=""><f a="::">
	<c path="haxe.functional.PartialFunction3.A"/>
	<c path="haxe.functional.PartialFunction3.B"/>
	<c path="haxe.functional.PartialFunction3.C"/>
	<e path="Option"><c path="haxe.functional.PartialFunction3.Z"/></e>
</f></f></toFunction>
	</class>
	<class path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl" params="A:B:C:Z" file="../src/main/haxe/haxe/functional/PartialFunctionExtensions.hx" private="1" module="haxe.functional.PartialFunctionExtensions">
		<implements path="haxe.functional.PartialFunction3">
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.A"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.B"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.C"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.Z"/>
		</implements>
		<create public="1" params="A:B:C:Z" set="method" line="149" static="1"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a="::">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.C"/>
		<e path="Bool"/>
	</f>
	<f a="::">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.C"/>
		<c path="create.Z"/>
	</f>
</c></c>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.C"/>
		<c path="create.Z"/>
	</c>
</f></create>
		<_def><c path="Array"><c path="Tuple2">
	<f a="::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.C"/>
		<e path="Bool"/>
	</f>
	<f a="::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.Z"/>
	</f>
</c></c></_def>
		<isDefinedAt public="1" set="method" line="157"><f a="a:b:c">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.A"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.B"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.C"/>
	<e path="Bool"/>
</f></isDefinedAt>
		<orElse public="1" set="method" line="165"><f a="that">
	<c path="haxe.functional.PartialFunction3">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.Z"/>
	</c>
	<c path="haxe.functional.PartialFunction3">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.Z"/>
	</c>
</f></orElse>
		<orAlways public="1" set="method" line="171"><f a="f">
	<f a="::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.Z"/>
	</f>
	<c path="haxe.functional.PartialFunction3">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.Z"/>
	</c>
</f></orAlways>
		<orAlwaysC public="1" set="method" line="177"><f a="z">
	<t path="Thunk"><c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.Z"/></t>
	<c path="haxe.functional.PartialFunction3">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.Z"/>
	</c>
</f></orAlwaysC>
		<call public="1" set="method" line="183"><f a="a:b:c">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.A"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.B"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.C"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.Z"/>
</f></call>
		<toFunction public="1" set="method" line="191"><f a=""><f a="::">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.A"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.B"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.C"/>
	<e path="Option"><c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.Z"/></e>
</f></f></toFunction>
		<new set="method" line="153"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a="::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.C"/>
		<e path="Bool"/>
	</f>
	<f a="::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl.Z"/>
	</f>
</c></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.functional.PartialFunction3ImplExtensions" params="" file="../src/main/haxe/haxe/functional/PartialFunctionExtensions.hx" module="haxe.functional.PartialFunctionExtensions"><toPartialFunction public="1" params="A:B:C:Z" set="method" line="202" static="1"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a="::">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.B"/>
		<c path="toPartialFunction.C"/>
		<e path="Bool"/>
	</f>
	<f a="::">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.B"/>
		<c path="toPartialFunction.C"/>
		<c path="toPartialFunction.Z"/>
	</f>
</c></c>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction3Impl">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.B"/>
		<c path="toPartialFunction.C"/>
		<c path="toPartialFunction.Z"/>
	</c>
</f></toPartialFunction></class>
	<class path="haxe.functional.PartialFunction4" params="A:B:C:D:Z" file="../src/main/haxe/haxe/functional/PartialFunction.hx" module="haxe.functional.PartialFunction" interface="1">
		<isDefinedAt public="1" set="method"><f a="a:b:c:d">
	<c path="haxe.functional.PartialFunction4.A"/>
	<c path="haxe.functional.PartialFunction4.B"/>
	<c path="haxe.functional.PartialFunction4.C"/>
	<c path="haxe.functional.PartialFunction4.D"/>
	<e path="Bool"/>
</f></isDefinedAt>
		<orElse public="1" set="method"><f a="that">
	<c path="haxe.functional.PartialFunction4">
		<c path="haxe.functional.PartialFunction4.A"/>
		<c path="haxe.functional.PartialFunction4.B"/>
		<c path="haxe.functional.PartialFunction4.C"/>
		<c path="haxe.functional.PartialFunction4.D"/>
		<c path="haxe.functional.PartialFunction4.Z"/>
	</c>
	<c path="haxe.functional.PartialFunction4">
		<c path="haxe.functional.PartialFunction4.A"/>
		<c path="haxe.functional.PartialFunction4.B"/>
		<c path="haxe.functional.PartialFunction4.C"/>
		<c path="haxe.functional.PartialFunction4.D"/>
		<c path="haxe.functional.PartialFunction4.Z"/>
	</c>
</f></orElse>
		<orAlways public="1" set="method"><f a="f">
	<f a=":::">
		<c path="haxe.functional.PartialFunction4.A"/>
		<c path="haxe.functional.PartialFunction4.B"/>
		<c path="haxe.functional.PartialFunction4.C"/>
		<c path="haxe.functional.PartialFunction4.D"/>
		<c path="haxe.functional.PartialFunction4.Z"/>
	</f>
	<c path="haxe.functional.PartialFunction4">
		<c path="haxe.functional.PartialFunction4.A"/>
		<c path="haxe.functional.PartialFunction4.B"/>
		<c path="haxe.functional.PartialFunction4.C"/>
		<c path="haxe.functional.PartialFunction4.D"/>
		<c path="haxe.functional.PartialFunction4.Z"/>
	</c>
</f></orAlways>
		<orAlwaysC public="1" set="method"><f a="z">
	<t path="Thunk"><c path="haxe.functional.PartialFunction4.Z"/></t>
	<c path="haxe.functional.PartialFunction4">
		<c path="haxe.functional.PartialFunction4.A"/>
		<c path="haxe.functional.PartialFunction4.B"/>
		<c path="haxe.functional.PartialFunction4.C"/>
		<c path="haxe.functional.PartialFunction4.D"/>
		<c path="haxe.functional.PartialFunction4.Z"/>
	</c>
</f></orAlwaysC>
		<call public="1" set="method"><f a="a:b:c:d">
	<c path="haxe.functional.PartialFunction4.A"/>
	<c path="haxe.functional.PartialFunction4.B"/>
	<c path="haxe.functional.PartialFunction4.C"/>
	<c path="haxe.functional.PartialFunction4.D"/>
	<c path="haxe.functional.PartialFunction4.Z"/>
</f></call>
		<toFunction public="1" set="method"><f a=""><f a=":::">
	<c path="haxe.functional.PartialFunction4.A"/>
	<c path="haxe.functional.PartialFunction4.B"/>
	<c path="haxe.functional.PartialFunction4.C"/>
	<c path="haxe.functional.PartialFunction4.D"/>
	<e path="Option"><c path="haxe.functional.PartialFunction4.Z"/></e>
</f></f></toFunction>
	</class>
	<class path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl" params="A:B:C:D:Z" file="../src/main/haxe/haxe/functional/PartialFunctionExtensions.hx" private="1" module="haxe.functional.PartialFunctionExtensions">
		<implements path="haxe.functional.PartialFunction4">
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.A"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.B"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.C"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.D"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.Z"/>
		</implements>
		<create public="1" params="A:B:C:D:Z" set="method" line="210" static="1"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a=":::">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.C"/>
		<c path="create.D"/>
		<e path="Bool"/>
	</f>
	<f a=":::">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.C"/>
		<c path="create.D"/>
		<c path="create.Z"/>
	</f>
</c></c>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.C"/>
		<c path="create.D"/>
		<c path="create.Z"/>
	</c>
</f></create>
		<_def><c path="Array"><c path="Tuple2">
	<f a=":::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.D"/>
		<e path="Bool"/>
	</f>
	<f a=":::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.Z"/>
	</f>
</c></c></_def>
		<isDefinedAt public="1" set="method" line="218"><f a="a:b:c:d">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.A"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.B"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.C"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.D"/>
	<e path="Bool"/>
</f></isDefinedAt>
		<orElse public="1" set="method" line="226"><f a="that">
	<c path="haxe.functional.PartialFunction4">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.Z"/>
	</c>
	<c path="haxe.functional.PartialFunction4">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.Z"/>
	</c>
</f></orElse>
		<orAlways public="1" set="method" line="232"><f a="f">
	<f a=":::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.Z"/>
	</f>
	<c path="haxe.functional.PartialFunction4">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.Z"/>
	</c>
</f></orAlways>
		<orAlwaysC public="1" set="method" line="238"><f a="z">
	<t path="Thunk"><c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.Z"/></t>
	<c path="haxe.functional.PartialFunction4">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.Z"/>
	</c>
</f></orAlwaysC>
		<call public="1" set="method" line="244"><f a="a:b:c:d">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.A"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.B"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.C"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.D"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.Z"/>
</f></call>
		<toFunction public="1" set="method" line="252"><f a=""><f a=":::">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.A"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.B"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.C"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.D"/>
	<e path="Option"><c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.Z"/></e>
</f></f></toFunction>
		<new set="method" line="214"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a=":::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.D"/>
		<e path="Bool"/>
	</f>
	<f a=":::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl.Z"/>
	</f>
</c></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.functional.PartialFunction4ImplExtensions" params="" file="../src/main/haxe/haxe/functional/PartialFunctionExtensions.hx" module="haxe.functional.PartialFunctionExtensions"><toPartialFunction public="1" params="A:B:C:D:Z" set="method" line="263" static="1"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a=":::">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.B"/>
		<c path="toPartialFunction.C"/>
		<c path="toPartialFunction.D"/>
		<e path="Bool"/>
	</f>
	<f a=":::">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.B"/>
		<c path="toPartialFunction.C"/>
		<c path="toPartialFunction.D"/>
		<c path="toPartialFunction.Z"/>
	</f>
</c></c>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction4Impl">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.B"/>
		<c path="toPartialFunction.C"/>
		<c path="toPartialFunction.D"/>
		<c path="toPartialFunction.Z"/>
	</c>
</f></toPartialFunction></class>
	<class path="haxe.functional.PartialFunction5" params="A:B:C:D:E:Z" file="../src/main/haxe/haxe/functional/PartialFunction.hx" module="haxe.functional.PartialFunction" interface="1">
		<isDefinedAt public="1" set="method"><f a="a:b:c:d:e">
	<c path="haxe.functional.PartialFunction5.A"/>
	<c path="haxe.functional.PartialFunction5.B"/>
	<c path="haxe.functional.PartialFunction5.C"/>
	<c path="haxe.functional.PartialFunction5.D"/>
	<c path="haxe.functional.PartialFunction5.E"/>
	<e path="Bool"/>
</f></isDefinedAt>
		<orElse public="1" set="method"><f a="that">
	<c path="haxe.functional.PartialFunction5">
		<c path="haxe.functional.PartialFunction5.A"/>
		<c path="haxe.functional.PartialFunction5.B"/>
		<c path="haxe.functional.PartialFunction5.C"/>
		<c path="haxe.functional.PartialFunction5.D"/>
		<c path="haxe.functional.PartialFunction5.E"/>
		<c path="haxe.functional.PartialFunction5.Z"/>
	</c>
	<c path="haxe.functional.PartialFunction5">
		<c path="haxe.functional.PartialFunction5.A"/>
		<c path="haxe.functional.PartialFunction5.B"/>
		<c path="haxe.functional.PartialFunction5.C"/>
		<c path="haxe.functional.PartialFunction5.D"/>
		<c path="haxe.functional.PartialFunction5.E"/>
		<c path="haxe.functional.PartialFunction5.Z"/>
	</c>
</f></orElse>
		<orAlways public="1" set="method"><f a="f">
	<f a="::::">
		<c path="haxe.functional.PartialFunction5.A"/>
		<c path="haxe.functional.PartialFunction5.B"/>
		<c path="haxe.functional.PartialFunction5.C"/>
		<c path="haxe.functional.PartialFunction5.D"/>
		<c path="haxe.functional.PartialFunction5.E"/>
		<c path="haxe.functional.PartialFunction5.Z"/>
	</f>
	<c path="haxe.functional.PartialFunction5">
		<c path="haxe.functional.PartialFunction5.A"/>
		<c path="haxe.functional.PartialFunction5.B"/>
		<c path="haxe.functional.PartialFunction5.C"/>
		<c path="haxe.functional.PartialFunction5.D"/>
		<c path="haxe.functional.PartialFunction5.E"/>
		<c path="haxe.functional.PartialFunction5.Z"/>
	</c>
</f></orAlways>
		<orAlwaysC public="1" set="method"><f a="z">
	<t path="Thunk"><c path="haxe.functional.PartialFunction5.Z"/></t>
	<c path="haxe.functional.PartialFunction5">
		<c path="haxe.functional.PartialFunction5.A"/>
		<c path="haxe.functional.PartialFunction5.B"/>
		<c path="haxe.functional.PartialFunction5.C"/>
		<c path="haxe.functional.PartialFunction5.D"/>
		<c path="haxe.functional.PartialFunction5.E"/>
		<c path="haxe.functional.PartialFunction5.Z"/>
	</c>
</f></orAlwaysC>
		<call public="1" set="method"><f a="a:b:c:d:e">
	<c path="haxe.functional.PartialFunction5.A"/>
	<c path="haxe.functional.PartialFunction5.B"/>
	<c path="haxe.functional.PartialFunction5.C"/>
	<c path="haxe.functional.PartialFunction5.D"/>
	<c path="haxe.functional.PartialFunction5.E"/>
	<c path="haxe.functional.PartialFunction5.Z"/>
</f></call>
		<toFunction public="1" set="method"><f a=""><f a="::::">
	<c path="haxe.functional.PartialFunction5.A"/>
	<c path="haxe.functional.PartialFunction5.B"/>
	<c path="haxe.functional.PartialFunction5.C"/>
	<c path="haxe.functional.PartialFunction5.D"/>
	<c path="haxe.functional.PartialFunction5.E"/>
	<e path="Option"><c path="haxe.functional.PartialFunction5.Z"/></e>
</f></f></toFunction>
	</class>
	<class path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl" params="A:B:C:D:E:Z" file="../src/main/haxe/haxe/functional/PartialFunctionExtensions.hx" private="1" module="haxe.functional.PartialFunctionExtensions">
		<implements path="haxe.functional.PartialFunction5">
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.A"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.B"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.C"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.D"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.E"/>
			<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.Z"/>
		</implements>
		<create public="1" params="A:B:C:D:E:Z" set="method" line="271" static="1"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a="::::">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.C"/>
		<c path="create.D"/>
		<c path="create.E"/>
		<e path="Bool"/>
	</f>
	<f a="::::">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.C"/>
		<c path="create.D"/>
		<c path="create.E"/>
		<c path="create.Z"/>
	</f>
</c></c>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.C"/>
		<c path="create.D"/>
		<c path="create.E"/>
		<c path="create.Z"/>
	</c>
</f></create>
		<_def><c path="Array"><c path="Tuple2">
	<f a="::::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.E"/>
		<e path="Bool"/>
	</f>
	<f a="::::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.E"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.Z"/>
	</f>
</c></c></_def>
		<isDefinedAt public="1" set="method" line="279"><f a="a:b:c:d:e">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.A"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.B"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.C"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.D"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.E"/>
	<e path="Bool"/>
</f></isDefinedAt>
		<orElse public="1" set="method" line="287"><f a="that">
	<c path="haxe.functional.PartialFunction5">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.E"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.Z"/>
	</c>
	<c path="haxe.functional.PartialFunction5">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.E"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.Z"/>
	</c>
</f></orElse>
		<orAlways public="1" set="method" line="293"><f a="f">
	<f a="::::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.E"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.Z"/>
	</f>
	<c path="haxe.functional.PartialFunction5">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.E"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.Z"/>
	</c>
</f></orAlways>
		<orAlwaysC public="1" set="method" line="299"><f a="z">
	<t path="Thunk"><c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.Z"/></t>
	<c path="haxe.functional.PartialFunction5">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.E"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.Z"/>
	</c>
</f></orAlwaysC>
		<call public="1" set="method" line="305"><f a="a:b:c:d:e">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.A"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.B"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.C"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.D"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.E"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.Z"/>
</f></call>
		<toFunction public="1" set="method" line="313"><f a=""><f a="::::">
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.A"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.B"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.C"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.D"/>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.E"/>
	<e path="Option"><c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.Z"/></e>
</f></f></toFunction>
		<new set="method" line="275"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a="::::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.E"/>
		<e path="Bool"/>
	</f>
	<f a="::::">
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.A"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.B"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.C"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.D"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.E"/>
		<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl.Z"/>
	</f>
</c></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.functional.PartialFunction5ImplExtensions" params="" file="../src/main/haxe/haxe/functional/PartialFunctionExtensions.hx" module="haxe.functional.PartialFunctionExtensions"><toPartialFunction public="1" params="A:B:C:D:E:Z" set="method" line="324" static="1"><f a="def">
	<c path="Array"><c path="Tuple2">
	<f a="::::">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.B"/>
		<c path="toPartialFunction.C"/>
		<c path="toPartialFunction.D"/>
		<c path="toPartialFunction.E"/>
		<e path="Bool"/>
	</f>
	<f a="::::">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.B"/>
		<c path="toPartialFunction.C"/>
		<c path="toPartialFunction.D"/>
		<c path="toPartialFunction.E"/>
		<c path="toPartialFunction.Z"/>
	</f>
</c></c>
	<c path="haxe.functional._PartialFunctionExtensions.PartialFunction5Impl">
		<c path="toPartialFunction.A"/>
		<c path="toPartialFunction.B"/>
		<c path="toPartialFunction.C"/>
		<c path="toPartialFunction.D"/>
		<c path="toPartialFunction.E"/>
		<c path="toPartialFunction.Z"/>
	</c>
</f></toPartialFunction></class>
	<class path="haxe.test.ui.common.FixtureResult" params="" file="../src/main/haxe/haxe/test/ui/common/FixtureResult.hx">
		<methodName public="1" set="null"><c path="String"/></methodName>
		<hasTestError public="1" set="null"><e path="Bool"/></hasTestError>
		<hasSetupError public="1" set="null"><e path="Bool"/></hasSetupError>
		<hasTeardownError public="1" set="null"><e path="Bool"/></hasTeardownError>
		<hasTimeoutError public="1" set="null"><e path="Bool"/></hasTimeoutError>
		<hasAsyncError public="1" set="null"><e path="Bool"/></hasAsyncError>
		<stats public="1" set="null"><c path="haxe.test.ui.common.ResultStats"/></stats>
		<list set="null"><c path="List"><e path="haxe.test.Assertation"/></c></list>
		<iterator public="1" set="method" line="46"><f a=""><t path="Iterator"><e path="haxe.test.Assertation"/></t></f></iterator>
		<add public="1" set="method" line="50"><f a="assertation">
	<e path="haxe.test.Assertation"/>
	<e path="Void"/>
</f></add>
		<new public="1" set="method" line="34"><f a="methodName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
* @todo add documentation
</haxe_doc>
	</class>
	<typedef path="haxe.math.tween.Easing" params="" file="../src/main/haxe/haxe/math/tween/Easing.hx"><f a="">
	<c path="Float"/>
	<c path="Float"/>
</f></typedef>
	<class path="haxe.math.tween.Easings" params="" file="../src/main/haxe/haxe/math/tween/Easing.hx" module="haxe.math.tween.Easing">
		<Linear public="1" line="21" static="1"><t path="haxe.math.tween.Easing"/></Linear>
		<Quadratic public="1" line="22" static="1"><t path="haxe.math.tween.Easing"/></Quadratic>
		<Cubic public="1" line="23" static="1"><t path="haxe.math.tween.Easing"/></Cubic>
		<Quartic public="1" line="24" static="1"><t path="haxe.math.tween.Easing"/></Quartic>
		<Quintic public="1" line="25" static="1"><t path="haxe.math.tween.Easing"/></Quintic>
	</class>
	<class path="haxe.reactive.SignalBool" params="" file="../src/main/haxe/haxe/reactive/SignalBool.hx">
		<not public="1" set="method" line="28" static="1">
			<f a="signal">
				<c path="haxe.reactive.Signal"><e path="Bool"/></c>
				<c path="haxe.reactive.Signal"><e path="Bool"/></c>
			</f>
			<haxe_doc>
     * Returns a Signal with the Bool of each value mapped to the
     * opposite of the original original Signal.
     </haxe_doc>
		</not>
		<ifTrue public="1" params="T" set="method" line="51" static="1">
			<f a="condition:thenS:elseS">
				<c path="haxe.reactive.Signal"><e path="Bool"/></c>
				<c path="haxe.reactive.Signal"><c path="ifTrue.T"/></c>
				<c path="haxe.reactive.Signal"><c path="ifTrue.T"/></c>
				<c path="haxe.reactive.Signal"><c path="ifTrue.T"/></c>
			</f>
			<haxe_doc><![CDATA[
     * Switches off of a Signal of Bools, returning
     * either a thenE Signal<T> when true or an elseE 
     * when falseSignal<T>.
     * 
     *
     * @param contition     A Signal of Bools that will 
     *                      be used to determine which 
     *                      Signal to return.
     *
     * @param thenE         The Signal that will be returned 
     *                      if stream == true;
     *
     * @param elseE         The Signal that will be returned 
      *                      if stream == false;
     *
     * @return              If a Signal from condition == true
     *                      Signal thenE, else Signal elseE
     ]]></haxe_doc>
		</ifTrue>
		<and public="1" set="method" line="71" static="1">
			<f a="signals">
				<t path="Iterable"><c path="haxe.reactive.Signal"><e path="Bool"/></c></t>
				<c path="haxe.reactive.Signal"><e path="Bool"/></c>
			</f>
			<haxe_doc>
     * Returns a Signal, true or false depending on whether 
     * or not all of the Signals supplied in the Iterable at a
     * given point of time are true.
     *
     * @param streams       An Iterable of the Signals to 
     *                      be evaluated.
     *
     * @return              If all the Signals in Iterable at
     *                      a given time are true, true, else
     *                      false.
     </haxe_doc>
		</and>
		<or public="1" set="method" line="87" static="1">
			<f a="signals">
				<t path="Iterable"><c path="haxe.reactive.Signal"><e path="Bool"/></c></t>
				<c path="haxe.reactive.Signal"><e path="Bool"/></c>
			</f>
			<haxe_doc>
     * Returns a Signal, true or false depending on whether 
     * or not any of the Signals supplied in the Iterable at a
     * given point of time are true.
     *
     * @param streams       An Iterable of the Signals to 
     *                      be evaluated.
     *
     * @return              If any the Signals in Iterable at
     *                      a given time are true, true, else
     *                      false.
     </haxe_doc>
		</or>
		<new set="method" line="22"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="haxe.text.json.JValue" params="" file="../src/main/haxe/haxe/text/json/JValue.hx">
		<JString a="v"><c path="String"/></JString>
		<JObject a="v"><c path="Array"><e path="haxe.text.json.JValue"/></c></JObject>
		<JNumber a="v"><c path="Float"/></JNumber>
		<JNull/>
		<JField a="k:v">
			<c path="String"/>
			<e path="haxe.text.json.JValue"/>
		</JField>
		<JBool a="v"><e path="Bool"/></JBool>
		<JArray a="v"><c path="Array"><e path="haxe.text.json.JValue"/></c></JArray>
	</enum>
	<class path="haxe.time.ScheduledExecutor" params="" file="../src/main/haxe/haxe/time/ScheduledExecutor.hx" interface="1">
		<__meta__ public="1" line="29" static="1"><d/></__meta__>
		<once public="1" params="T" set="method">
			<f a="f:ms">
				<f a=""><c path="once.T"/></f>
				<c path="Int"/>
				<c path="Future"><c path="once.T"/></c>
			</f>
			<haxe_doc> Executes the function a single time the specified number of milliseconds 
   * into the future, returning a future of the return value of the function.
   </haxe_doc>
		</once>
		<repeat public="1" params="T" set="method">
			<f a="seed:f:ms:times">
				<c path="repeat.T"/>
				<f a="">
					<c path="repeat.T"/>
					<c path="repeat.T"/>
				</f>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Future"><c path="repeat.T"/></c>
			</f>
			<haxe_doc> Executes the reducer a fixed number of times, each separated by the specified
   * number of milliseconds, returning a future of the completed reduction.
   </haxe_doc>
		</repeat>
		<repeatWhile public="1" params="T" set="method">
			<f a="seed:f:ms:pred">
				<c path="repeatWhile.T"/>
				<f a="">
					<c path="repeatWhile.T"/>
					<c path="repeatWhile.T"/>
				</f>
				<c path="Int"/>
				<f a="">
					<c path="repeatWhile.T"/>
					<e path="Bool"/>
				</f>
				<c path="Future"><c path="repeatWhile.T"/></c>
			</f>
			<haxe_doc><![CDATA[ Executes the reducer while a predicate holds true for the reduction, each 
   * invocation separated by the specified number of milliseconds, returning a
   * future of the completed reduction.
   * <p>
   * The result of the future is always the first reduction for which the 
   * predicate holds false.
   ]]></haxe_doc>
		</repeatWhile>
		<forever public="1" set="method">
			<f a="f:ms">
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<c path="Future"><e path="Void"/></c>
			</f>
			<haxe_doc> Executes the function an infinite number of times, each invocation 
   * separated by the specified number of milliseconds. The future will not 
   * return anything, but may be canceled in order to terminate the schedule.
   </haxe_doc>
		</forever>
		<haxe_doc> A scheduled executor service, which can be used to execute tasks at 
 * specified times in the future.
 </haxe_doc>
	</class>
	<class path="ImportAll" params="" file="./ImportAll.hx">
		<main public="1" set="method" line="85" static="1"><f a=""><e path="Void"/></f></main>
		<new public="1" set="method" line="84"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Class" params="T" file="C:\World\Stack\os\win\programs\lingos\haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="haxe.data.collections.IterableExtensions" params="" file="../src/main/haxe/haxe/data/collections/IterableExtensions.hx">
		<size public="1" params="T" set="method" line="27" static="1"><f a="iterable">
	<t path="Iterable"><c path="size.T"/></t>
	<c path="Int"/>
</f></size>
		<filter public="1" params="T" set="method" line="35" static="1"><f a="iter:f">
	<t path="Iterable"><c path="filter.T"/></t>
	<f a="">
		<c path="filter.T"/>
		<e path="Bool"/>
	</f>
	<t path="Iterable"><c path="filter.T"/></t>
</f></filter>
		<foldl public="1" params="T:Z" set="method" line="39" static="1"><f a="iter:seed:mapper">
	<t path="Iterable"><c path="foldl.T"/></t>
	<c path="foldl.Z"/>
	<f a=":">
		<c path="foldl.Z"/>
		<c path="foldl.T"/>
		<c path="foldl.Z"/>
	</f>
	<c path="foldl.Z"/>
</f></foldl>
		<concat public="1" params="T" set="method" line="47" static="1"><f a="iter1:iter2">
	<t path="Iterable"><c path="concat.T"/></t>
	<t path="Iterable"><c path="concat.T"/></t>
	<t path="Iterable"><c path="concat.T"/></t>
</f></concat>
		<foldr public="1" params="T:Z" set="method" line="51" static="1"><f a="iterable:z:f">
	<t path="Iterable"><c path="foldr.T"/></t>
	<c path="foldr.Z"/>
	<f a=":">
		<c path="foldr.T"/>
		<c path="foldr.Z"/>
		<c path="foldr.Z"/>
	</f>
	<c path="foldr.Z"/>
</f></foldr>
		<headOption public="1" params="T" set="method" line="55" static="1"><f a="iter">
	<t path="Iterable"><c path="headOption.T"/></t>
	<e path="Option"><c path="headOption.T"/></e>
</f></headOption>
		<head public="1" params="T" set="method" line="61" static="1"><f a="iter">
	<t path="Iterable"><c path="head.T"/></t>
	<c path="head.T"/>
</f></head>
		<tailOption public="1" params="T" set="method" line="68" static="1"><f a="iter">
	<t path="Iterable"><c path="tailOption.T"/></t>
	<e path="Option"><t path="Iterable"><c path="tailOption.T"/></t></e>
</f></tailOption>
		<drop public="1" params="T" set="method" line="75" static="1"><f a="iter:n">
	<t path="Iterable"><c path="drop.T"/></t>
	<c path="Int"/>
	<t path="Iterable"><c path="drop.T"/></t>
</f></drop>
		<take public="1" params="T" set="method" line="90" static="1"><f a="iter:n">
	<t path="Iterable"><c path="take.T"/></t>
	<c path="Int"/>
	<t path="Iterable"><c path="take.T"/></t>
</f></take>
		<tail public="1" params="T" set="method" line="102" static="1"><f a="iter">
	<t path="Iterable"><c path="tail.T"/></t>
	<t path="Iterable"><c path="tail.T"/></t>
</f></tail>
		<exists public="1" params="T" set="method" line="110" static="1"><f a="iter:eq:value">
	<t path="Iterable"><c path="exists.T"/></t>
	<f a=":">
		<c path="exists.T"/>
		<c path="exists.T"/>
		<e path="Bool"/>
	</f>
	<c path="exists.T"/>
	<e path="Bool"/>
</f></exists>
		<nub public="1" params="T" set="method" line="116" static="1"><f a="iter">
	<t path="Iterable"><c path="nub.T"/></t>
	<t path="Iterable"><c path="nub.T"/></t>
</f></nub>
		<at public="1" params="T" set="method" line="125" static="1"><f a="iter:index">
	<t path="Iterable"><c path="at.T"/></t>
	<c path="Int"/>
	<c path="at.T"/>
</f></at>
		<map public="1" params="T:Z" set="method" line="140" static="1"><f a="iter:f">
	<t path="Iterable"><c path="map.T"/></t>
	<f a="">
		<c path="map.T"/>
		<c path="map.Z"/>
	</f>
	<t path="Iterable"><c path="map.Z"/></t>
</f></map>
		<flatMap public="1" params="T:Z" set="method" line="147" static="1"><f a="iter:f">
	<t path="Iterable"><c path="flatMap.T"/></t>
	<f a="">
		<c path="flatMap.T"/>
		<t path="Iterable"><c path="flatMap.Z"/></t>
	</f>
	<t path="Iterable"><c path="flatMap.Z"/></t>
</f></flatMap>
		<zip public="1" params="T1:T2" set="method" line="154" static="1"><f a="iter1:iter2">
	<t path="Iterable"><c path="zip.T1"/></t>
	<t path="Iterable"><c path="zip.T2"/></t>
	<t path="Iterable"><c path="Tuple2">
	<c path="zip.T1"/>
	<c path="zip.T2"/>
</c></t>
</f></zip>
		<append public="1" params="T" set="method" line="170" static="1"><f a="iter:e">
	<t path="Iterable"><c path="append.T"/></t>
	<c path="append.T"/>
	<t path="Iterable"><c path="append.T"/></t>
</f></append>
		<cons public="1" params="T" set="method" line="178" static="1"><f a="iter:e">
	<t path="Iterable"><c path="cons.T"/></t>
	<c path="cons.T"/>
	<t path="Iterable"><c path="cons.T"/></t>
</f></cons>
		<toArray public="1" params="T" set="method" line="186" static="1"><f a="i">
	<t path="Iterable"><c path="toArray.T"/></t>
	<c path="Array"><c path="toArray.T"/></c>
</f></toArray>
		<reversed public="1" params="T" set="method" line="194" static="1"><f a="iter">
	<t path="Iterable"><c path="reversed.T"/></t>
	<t path="Iterable"><c path="reversed.T"/></t>
</f></reversed>
		<and public="1" params="T" set="method" line="202" static="1"><f a="iter">
	<t path="Iterable"><e path="Bool"/></t>
	<e path="Bool"/>
</f></and>
		<or public="1" params="T" set="method" line="212" static="1"><f a="iter">
	<t path="Iterable"><e path="Bool"/></t>
	<e path="Bool"/>
</f></or>
		<scanl public="1" params="T" set="method" line="221" static="1"><f a="iter:init:f">
	<t path="Iterable"><c path="scanl.T"/></t>
	<c path="scanl.T"/>
	<f a=":">
		<c path="scanl.T"/>
		<c path="scanl.T"/>
		<c path="scanl.T"/>
	</f>
	<t path="Iterable"><c path="scanl.T"/></t>
</f></scanl>
		<scanr public="1" params="T" set="method" line="231" static="1"><f a="iter:init:f">
	<t path="Iterable"><c path="scanr.T"/></t>
	<c path="scanr.T"/>
	<f a=":">
		<c path="scanr.T"/>
		<c path="scanr.T"/>
		<c path="scanr.T"/>
	</f>
	<t path="Iterable"><c path="scanr.T"/></t>
</f></scanr>
		<scanl1 public="1" params="T" set="method" line="235" static="1"><f a="iter:f">
	<t path="Iterable"><c path="scanl1.T"/></t>
	<f a=":">
		<c path="scanl1.T"/>
		<c path="scanl1.T"/>
		<c path="scanl1.T"/>
	</f>
	<t path="Iterable"><c path="scanl1.T"/></t>
</f></scanl1>
		<scanr1 public="1" params="T" set="method" line="248" static="1"><f a="iter:f">
	<t path="Iterable"><c path="scanr1.T"/></t>
	<f a=":">
		<c path="scanr1.T"/>
		<c path="scanr1.T"/>
		<c path="scanr1.T"/>
	</f>
	<t path="Iterable"><c path="scanr1.T"/></t>
</f></scanr1>
		<existsP public="1" params="T" set="method" line="252" static="1"><f a="iter:ref:f">
	<t path="Iterable"><c path="existsP.T"/></t>
	<c path="existsP.T"/>
	<f a=":">
		<c path="existsP.T"/>
		<c path="existsP.T"/>
		<e path="Bool"/>
	</f>
	<e path="Bool"/>
</f></existsP>
		<nubBy public="1" params="T" set="method" line="262" static="1"><f a="iter:f">
	<t path="Iterable"><c path="nubBy.T"/></t>
	<f a=":">
		<c path="nubBy.T"/>
		<c path="nubBy.T"/>
		<e path="Bool"/>
	</f>
	<t path="Iterable"><c path="nubBy.T"/></t>
</f></nubBy>
		<intersectBy public="1" params="T" set="method" line="274" static="1"><f a="iter1:iter2:f">
	<t path="Iterable"><c path="intersectBy.T"/></t>
	<t path="Iterable"><c path="intersectBy.T"/></t>
	<f a=":">
		<c path="intersectBy.T"/>
		<c path="intersectBy.T"/>
		<e path="Bool"/>
	</f>
	<t path="Iterable"><c path="intersectBy.T"/></t>
</f></intersectBy>
		<intersect public="1" params="T" set="method" line="280" static="1"><f a="iter1:iter2">
	<t path="Iterable"><c path="intersect.T"/></t>
	<t path="Iterable"><c path="intersect.T"/></t>
	<t path="Iterable"><c path="intersect.T"/></t>
</f></intersect>
		<unionBy public="1" params="T" set="method" line="286" static="1"><f a="iter1:iter2:f">
	<t path="Iterable"><c path="unionBy.T"/></t>
	<t path="Iterable"><c path="unionBy.T"/></t>
	<f a=":">
		<c path="unionBy.T"/>
		<c path="unionBy.T"/>
		<e path="Bool"/>
	</f>
	<t path="Iterable"><c path="unionBy.T"/></t>
</f></unionBy>
		<union public="1" params="T" set="method" line="305" static="1"><f a="iter1:iter2">
	<t path="Iterable"><c path="union.T"/></t>
	<t path="Iterable"><c path="union.T"/></t>
	<t path="Iterable"><c path="union.T"/></t>
</f></union>
		<partition public="1" params="T" set="method" line="309" static="1"><f a="iter:f">
	<t path="Iterable"><c path="partition.T"/></t>
	<f a="">
		<c path="partition.T"/>
		<e path="Bool"/>
	</f>
	<c path="Tuple2">
		<t path="Iterable"><c path="partition.T"/></t>
		<t path="Iterable"><c path="partition.T"/></t>
	</c>
</f></partition>
		<partitionWhile public="1" params="T" set="method" line="313" static="1"><f a="iter:f">
	<t path="Iterable"><c path="partitionWhile.T"/></t>
	<f a="">
		<c path="partitionWhile.T"/>
		<e path="Bool"/>
	</f>
	<c path="Tuple2">
		<t path="Iterable"><c path="partitionWhile.T"/></t>
		<t path="Iterable"><c path="partitionWhile.T"/></t>
	</c>
</f></partitionWhile>
		<count public="1" params="T" set="method" line="317" static="1"><f a="iter:f">
	<t path="Iterable"><c path="count.T"/></t>
	<f a="">
		<c path="count.T"/>
		<e path="Bool"/>
	</f>
	<c path="Int"/>
</f></count>
		<countWhile public="1" params="T" set="method" line="321" static="1"><f a="iter:f">
	<t path="Iterable"><c path="countWhile.T"/></t>
	<f a="">
		<c path="countWhile.T"/>
		<e path="Bool"/>
	</f>
	<c path="Int"/>
</f></countWhile>
		<elements public="1" params="T" set="method" line="325" static="1"><f a="iter">
	<t path="Iterable"><c path="elements.T"/></t>
	<t path="Iterable"><c path="elements.T"/></t>
</f></elements>
		<appendAll public="1" params="T" set="method" line="329" static="1"><f a="iter:i">
	<t path="Iterable"><c path="appendAll.T"/></t>
	<t path="Iterable"><c path="appendAll.T"/></t>
	<t path="Iterable"><c path="appendAll.T"/></t>
</f></appendAll>
		<isEmpty public="1" params="T" set="method" line="333" static="1"><f a="iter">
	<t path="Iterable"><c path="isEmpty.T"/></t>
	<e path="Bool"/>
</f></isEmpty>
		<find public="1" params="T" set="method" line="337" static="1"><f a="iter:f">
	<t path="Iterable"><c path="find.T"/></t>
	<f a="">
		<c path="find.T"/>
		<e path="Bool"/>
	</f>
	<e path="Option"><c path="find.T"/></e>
</f></find>
		<forEach public="1" params="T" set="method" line="340" static="1"><f a="iter:f">
	<t path="Iterable"><c path="forEach.T"/></t>
	<f a="">
		<c path="forEach.T"/>
		<e path="Void"/>
	</f>
	<t path="Iterable"><c path="forEach.T"/></t>
</f></forEach>
		<forAll public="1" params="T" set="method" line="347" static="1"><f a="iter:f">
	<t path="Iterable"><c path="forAll.T"/></t>
	<f a="">
		<c path="forAll.T"/>
		<e path="Bool"/>
	</f>
	<e path="Bool"/>
</f></forAll>
		<forAny public="1" params="T" set="method" line="351" static="1"><f a="iter:f">
	<t path="Iterable"><c path="forAny.T"/></t>
	<f a="">
		<c path="forAny.T"/>
		<e path="Bool"/>
	</f>
	<e path="Bool"/>
</f></forAny>
		<groupBy public="1" params="T:K" set="method" line="355" static="1"><f a="iter:grouper">
	<t path="Iterable"><c path="groupBy.T"/></t>
	<f a="">
		<c path="groupBy.T"/>
		<c path="groupBy.K"/>
	</f>
	<c path="haxe.data.collections.Map">
		<c path="groupBy.K"/>
		<t path="Iterable"><c path="groupBy.T"/></t>
	</c>
</f></groupBy>
		<unwind public="1" params="T" set="method" line="362" static="1"><f a="root:children:?breadth">
	<c path="unwind.T"/>
	<f a="">
		<c path="unwind.T"/>
		<c path="Array"><c path="unwind.T"/></c>
	</f>
	<e path="Bool"/>
	<t path="Iterable"><c path="unwind.T"/></t>
</f></unwind>
		<contains public="1" params="T" set="method" line="377" static="1"><f a="iter:v">
	<t path="Iterable"><c path="contains.T"/></t>
	<c path="contains.T"/>
	<e path="Bool"/>
</f></contains>
	</class>
	<class path="Reflect" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" get="inline" set="null" line="32" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="36" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" get="inline" set="null" line="41" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="45" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="60" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" get="inline" set="null" line="64" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" get="inline" set="null" line="68" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="72" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" get="inline" set="null" line="76" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" get="inline" set="null" line="80" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="84" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<same_closure line="89" static="1"><f a=":">
	<d/>
	<d/>
	<e path="Bool"/>
</f></same_closure>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="haxe.test.ui.common.ResultStats" params="" file="../src/main/haxe/haxe/test/ui/common/ResultStats.hx">
		<assertations public="1" set="null"><c path="Int"/></assertations>
		<successes public="1" set="null"><c path="Int"/></successes>
		<failures public="1" set="null"><c path="Int"/></failures>
		<errors public="1" set="null"><c path="Int"/></errors>
		<warnings public="1" set="null"><c path="Int"/></warnings>
		<onAddSuccesses public="1" set="null"><c path="haxe.test.Dispatcher"><c path="Int"/></c></onAddSuccesses>
		<onAddFailures public="1" set="null"><c path="haxe.test.Dispatcher"><c path="Int"/></c></onAddFailures>
		<onAddErrors public="1" set="null"><c path="haxe.test.Dispatcher"><c path="Int"/></c></onAddErrors>
		<onAddWarnings public="1" set="null"><c path="haxe.test.Dispatcher"><c path="Int"/></c></onAddWarnings>
		<isOk public="1" set="null"><e path="Bool"/></isOk>
		<hasFailures public="1" set="null"><e path="Bool"/></hasFailures>
		<hasErrors public="1" set="null"><e path="Bool"/></hasErrors>
		<hasWarnings public="1" set="null"><e path="Bool"/></hasWarnings>
		<addSuccesses public="1" set="method" line="57"><f a="v">
	<c path="Int"/>
	<e path="Void"/>
</f></addSuccesses>
		<addFailures public="1" set="method" line="64"><f a="v">
	<c path="Int"/>
	<e path="Void"/>
</f></addFailures>
		<addErrors public="1" set="method" line="73"><f a="v">
	<c path="Int"/>
	<e path="Void"/>
</f></addErrors>
		<addWarnings public="1" set="method" line="82"><f a="v">
	<c path="Int"/>
	<e path="Void"/>
</f></addWarnings>
		<sum public="1" set="method" line="91"><f a="other">
	<c path="haxe.test.ui.common.ResultStats"/>
	<e path="Void"/>
</f></sum>
		<subtract public="1" set="method" line="98"><f a="other">
	<c path="haxe.test.ui.common.ResultStats"/>
	<e path="Void"/>
</f></subtract>
		<wire public="1" set="method" line="105"><f a="dependant">
	<c path="haxe.test.ui.common.ResultStats"/>
	<e path="Void"/>
</f></wire>
		<unwire public="1" set="method" line="113"><f a="dependant">
	<c path="haxe.test.ui.common.ResultStats"/>
	<e path="Void"/>
</f></unwire>
		<new public="1" set="method" line="39"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
* @todo add documentation
</haxe_doc>
	</class>
	<enum path="haxe.StackItem" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/haxe/Stack.hx" module="haxe.Stack">
		<Module a="m"><c path="String"/></Module>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<Lambda a="v"><c path="Int"/></Lambda>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<c path="Int"/>
		</FilePos>
		<CFunction/>
		<haxe_doc>
	Elements return by [Stack] methods.
</haxe_doc>
	</enum>
	<class path="haxe.Stack" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/haxe/Stack.hx">
		<callStack public="1" set="method" line="46" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>
		Return the call stack elements.
	</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="69" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>
		Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		catched.
	</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="100" static="1">
			<f a="stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of the stack as a printable string.
	</haxe_doc>
		</toString>
		<itemToString set="method" line="109" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<e path="Void"/>
</f></itemToString>
		<makeStack set="method" line="135" static="1"><f a="s">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><e path="haxe.StackItem"/></c>
</f></makeStack>
		<haxe_doc>
	Get informations about the call stack.
</haxe_doc>
	</class>
	<class path="IntIter" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="haxe.util.StringExtensions" params="" file="../src/main/haxe/haxe/util/StringExtensions.hx">
		<SepAlphaPattern line="25" static="1"><c path="EReg"/></SepAlphaPattern>
		<AlphaUpperAlphaPattern line="26" static="1"><c path="EReg"/></AlphaUpperAlphaPattern>
		<chunk public="1" set="method" line="28" static="1"><f a="str:len">
	<c path="String"/>
	<c path="Int"/>
	<c path="haxe.data.collections.List"><c path="String"/></c>
</f></chunk>
		<chars public="1" set="method" line="41" static="1"><f a="str">
	<c path="String"/>
	<c path="haxe.data.collections.List"><c path="String"/></c>
</f></chars>
		<string public="1" set="method" line="51" static="1"><f a="l">
	<c path="haxe.data.collections.List"><c path="String"/></c>
	<c path="String"/>
</f></string>
		<toCamelCase public="1" set="method" line="55" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></toCamelCase>
		<fromCamelCase public="1" set="method" line="59" static="1"><f a="str:sep">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></fromCamelCase>
	</class>
	<class path="haxe.net.HttpHeaderExtensions" params="" file="../src/main/haxe/haxe/net/HttpHeaderExtensions.hx">
		<HeaderPattern line="26" static="1"><c path="EReg"/></HeaderPattern>
		<HeaderLinesPattern line="27" static="1"><c path="EReg"/></HeaderLinesPattern>
		<toHttpHeader public="1" set="method" line="29" static="1"><f a="str">
	<c path="String"/>
	<e path="Option"><t path="haxe.net.HttpHeader"/></e>
</f></toHttpHeader>
		<toHttpHeaders public="1" set="method" line="33" static="1"><f a="str">
	<c path="String"/>
	<t path="haxe.net.HttpHeaders"/>
</f></toHttpHeaders>
	</class>
	<class path="Math" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/Math.hx">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<min public="1" set="method" line="34" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" line="35" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<abs public="1" set="method" line="37" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<sin public="1" set="method" line="38" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" line="39" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" line="40" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" line="41" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" line="42" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" line="43" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" line="44" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" line="45" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" line="46" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" line="47" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" line="48" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" line="49" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" line="50" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" line="51" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<__rnd static="1"><unknown/></__rnd>
		<_rand_float line="54" static="1"><f a="">
	<unknown/>
	<c path="Float"/>
</f></_rand_float>
		<_rand_int line="55" static="1"><f a=":">
	<unknown/>
	<c path="Int"/>
	<unknown/>
</f></_rand_int>
		<random public="1" set="method" line="57" static="1"><f a=""><c path="Float"/></f></random>
		<isNaN public="1" set="method" line="59" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<isFinite public="1" set="method" line="60" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<class path="haxe.io.http.HttpXml" params="" file="../src/main/haxe/haxe/io/http/HttpXml.hx" interface="1"><implements path="haxe.io.http.Http"><c path="Xml"/></implements></class>
	<class path="haxe.reactive.SignalCollection" params="" file="../src/main/haxe/haxe/reactive/SignalCollection.hx">
		<concatS public="1" params="C:T" set="method" line="31" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="concatS.C"/>
	<c path="concatS.T"/>
</c></c>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="concatS.C"/>
	<c path="concatS.T"/>
</c></c>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="concatS.C"/>
	<c path="concatS.T"/>
</c></c>
</f></concatS>
		<join public="1" params="C:T" set="method" line="35" static="1"><f a="b:char">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="join.C"/>
	<c path="join.T"/>
</c></c>
	<c path="String"/>
	<c path="haxe.reactive.Signal"><c path="String"/></c>
</f></join>
		<size public="1" params="C:T" set="method" line="39" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="size.C"/>
	<c path="size.T"/>
</c></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></size>
		<zipS public="1" params="C:T:B" set="method" line="43" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.List"><c path="zipS.T"/></c></c>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.List"><c path="zipS.B"/></c></c>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.List"><c path="Tuple2">
	<c path="zipS.T"/>
	<c path="zipS.B"/>
</c></c></c>
</f></zipS>
		<append public="1" params="C:T" set="method" line="47" static="1"><f a="b:element">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="append.C"/>
	<c path="append.T"/>
</c></c>
	<c path="append.T"/>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="append.C"/>
	<c path="append.T"/>
</c></c>
</f></append>
		<count public="1" params="C:T" set="method" line="51" static="1"><f a="b:predicate">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="count.C"/>
	<c path="count.T"/>
</c></c>
	<f a="">
		<c path="count.T"/>
		<e path="Bool"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></count>
		<all public="1" params="C:T" set="method" line="55" static="1"><f a="b:tester">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="all.C"/>
	<c path="all.T"/>
</c></c>
	<f a="">
		<c path="all.T"/>
		<e path="Bool"/>
	</f>
	<c path="haxe.reactive.Signal"><e path="Bool"/></c>
</f></all>
		<any public="1" params="C:T" set="method" line="59" static="1"><f a="b:tester">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="any.C"/>
	<c path="any.T"/>
</c></c>
	<f a="">
		<c path="any.T"/>
		<e path="Bool"/>
	</f>
	<c path="haxe.reactive.Signal"><e path="Bool"/></c>
</f></any>
		<forEach public="1" params="C:T" set="method" line="63" static="1"><f a="b:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="forEach.C"/>
	<c path="forEach.T"/>
</c></c>
	<f a="">
		<c path="forEach.T"/>
		<e path="Void"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="forEach.C"/>
	<c path="forEach.T"/>
</c></c>
</f></forEach>
		<each public="1" params="C:T" set="method" line="67" static="1"><f a="b:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="each.C"/>
	<c path="each.T"/>
</c></c>
	<f a="">
		<c path="each.T"/>
		<e path="Void"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="each.C"/>
	<c path="each.T"/>
</c></c>
</f></each>
		<map public="1" params="C:T" set="method" line="71" static="1"><f a="b:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="map.C"/>
	<c path="map.T"/>
</c></c>
	<f a="">
		<c path="map.T"/>
		<c path="map.T"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="map.C"/>
	<c path="map.T"/>
</c></c>
</f></map>
		<mapTo public="1" params="C:T:Z" set="method" line="75" static="1"><f a="b:t:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="mapTo.C"/>
	<c path="mapTo.T"/>
</c></c>
	<c path="haxe.data.collections.Collection">
		<c path="mapTo.C"/>
		<c path="mapTo.Z"/>
	</c>
	<f a="">
		<c path="mapTo.T"/>
		<c path="mapTo.Z"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="mapTo.C"/>
	<c path="mapTo.Z"/>
</c></c>
</f></mapTo>
		<partition public="1" params="C:T" set="method" line="79" static="1"><f a="b:filter">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="partition.C"/>
	<c path="partition.T"/>
</c></c>
	<f a="">
		<c path="partition.T"/>
		<e path="Bool"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="Tuple2">
	<c path="haxe.data.collections.Collection">
		<c path="partition.C"/>
		<c path="partition.T"/>
	</c>
	<c path="haxe.data.collections.Collection">
		<c path="partition.C"/>
		<c path="partition.T"/>
	</c>
</c></c>
</f></partition>
		<filter public="1" params="C:T" set="method" line="83" static="1"><f a="b:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="filter.C"/>
	<c path="filter.T"/>
</c></c>
	<f a="">
		<c path="filter.T"/>
		<e path="Bool"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="filter.C"/>
	<c path="filter.T"/>
</c></c>
</f></filter>
		<flatMap public="1" params="C:T" set="method" line="87" static="1"><f a="b:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="flatMap.C"/>
	<c path="flatMap.T"/>
</c></c>
	<f a="">
		<c path="flatMap.T"/>
		<c path="haxe.data.collections.Collection">
			<c path="flatMap.C"/>
			<c path="flatMap.T"/>
		</c>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="flatMap.C"/>
	<c path="flatMap.T"/>
</c></c>
</f></flatMap>
		<toArray public="1" params="C:T" set="method" line="92" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="toArray.C"/>
	<c path="toArray.T"/>
</c></c>
	<c path="haxe.reactive.Signal"><c path="Array"><c path="toArray.T"/></c></c>
</f></toArray>
		<foldr public="1" params="C:T:Z" set="method" line="96" static="1"><f a="b:initial:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="foldr.C"/>
	<c path="foldr.T"/>
</c></c>
	<c path="foldr.Z"/>
	<f a=":">
		<c path="foldr.T"/>
		<c path="foldr.Z"/>
		<c path="foldr.Z"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="foldr.Z"/></c>
</f></foldr>
		<foldl public="1" params="C:T:Z" set="method" line="100" static="1"><f a="b:initial:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="foldl.C"/>
	<c path="foldl.T"/>
</c></c>
	<c path="foldl.Z"/>
	<f a=":">
		<c path="foldl.Z"/>
		<c path="foldl.T"/>
		<c path="foldl.Z"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="foldl.Z"/></c>
</f></foldl>
		<new set="method" line="27"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.util.OrderExtension" params="" file="../src/main/haxe/haxe/util/OrderExtension.hx">
		<greaterThan public="1" params="T" set="method" line="22" static="1"><f a="order">
	<t path="OrderFunction"><c path="greaterThan.T"/></t>
	<t path="EqualFunction"><c path="greaterThan.T"/></t>
</f></greaterThan>
		<greaterThanOrEqual public="1" params="T" set="method" line="26" static="1"><f a="order">
	<t path="OrderFunction"><c path="greaterThanOrEqual.T"/></t>
	<t path="EqualFunction"><c path="greaterThanOrEqual.T"/></t>
</f></greaterThanOrEqual>
		<lessThan public="1" params="T" set="method" line="30" static="1"><f a="order">
	<t path="OrderFunction"><c path="lessThan.T"/></t>
	<t path="EqualFunction"><c path="lessThan.T"/></t>
</f></lessThan>
		<lessThanOrEqual public="1" params="T" set="method" line="34" static="1"><f a="order">
	<t path="OrderFunction"><c path="lessThanOrEqual.T"/></t>
	<t path="EqualFunction"><c path="lessThanOrEqual.T"/></t>
</f></lessThanOrEqual>
		<equal public="1" params="T" set="method" line="38" static="1"><f a="order">
	<t path="OrderFunction"><c path="equal.T"/></t>
	<t path="EqualFunction"><c path="equal.T"/></t>
</f></equal>
		<notEqual public="1" params="T" set="method" line="42" static="1"><f a="order">
	<t path="OrderFunction"><c path="notEqual.T"/></t>
	<t path="EqualFunction"><c path="notEqual.T"/></t>
</f></notEqual>
	</class>
	<enum path="ValueType" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="49" static="1">
			<f a="o">
				<d/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="56" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="61" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="68" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="73" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="88" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="102" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="106" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="112" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="124" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor index and parameters.
	</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="130" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="146" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="158" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="163" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="185" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="200" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="204" static="1">
			<f a="e">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="208" static="1">
			<f a="e">
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="haxe.reactive.StreamStream" params="" file="../src/main/haxe/haxe/reactive/StreamStream.hx">
		<switchE public="1" params="T" set="method" line="32" static="1">
			<f a="streams">
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream"><c path="switchE.T"/></c></c>
				<c path="haxe.reactive.Stream"><c path="switchE.T"/></c>
			</f>
			<haxe_doc>
     * Converts an Stream of Streams into
     * a single Stream, whose events represent 
     * those of the last Stream to have an Event.
     *
     * @param   streams     The Stream of 
     *                      Streams to be
     *                      flattened.
     </haxe_doc>
		</switchE>
		<join public="1" params="T" set="method" line="45" static="1">
			<f a="stream">
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream"><c path="join.T"/></c></c>
				<c path="haxe.reactive.Stream"><c path="join.T"/></c>
			</f>
			<haxe_doc>
     * Converts an Stream of Streams into
     * a single Stream, whose events represent 
     * those of the last Stream to have an Event.
     *
     * @param   streams     The Stream of 
     *                      Streams to be
     *                      flattened.
     </haxe_doc>
		</join>
		<flatten public="1" params="T" set="method" line="58" static="1">
			<f a="stream">
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream"><c path="flatten.T"/></c></c>
				<c path="haxe.reactive.Stream"><c path="flatten.T"/></c>
			</f>
			<haxe_doc>
     * Converts an Stream of Streams into
     * a single Stream, whose events represent 
     * those of the last Stream to have an Event.
     *
     * @param   streams     The Stream of 
     *                      Streams to be
     *                      flattened.
     </haxe_doc>
		</flatten>
		<new set="method" line="21"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="XmlType" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/Xml.hx" module="Xml"/>
	<class path="Xml" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/Xml.hx">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Document>
		<_parse line="54" static="1"><f a=":">
	<unknown/>
	<a>
		<xml><f a="name:att">
	<c path="String"/>
	<unknown/>
	<e path="Void"/>
</f></xml>
		<pcdata><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></pcdata>
		<done><f a=""><e path="Void"/></f></done>
		<doctype><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></doctype>
		<cur><c path="Xml"/></cur>
		<comment><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></comment>
		<cdata><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></cdata>
	</a>
	<unknown/>
</f></_parse>
		<parse public="1" set="method" line="56" static="1">
			<f a="str">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Parse a String into an Xml object.
	</haxe_doc>
		</parse>
		<createElement public="1" set="method" line="125" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" line="134" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" line="141" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createCData>
		<createComment public="1" set="method" line="148" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" line="155" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocType>
		<createProlog public="1" set="method" line="162" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createProlog>
		<createDocument public="1" set="method" line="169" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocument>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>
		Returns the node name of an Element.
	</haxe_doc>
		</nodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>
		Returns the node value. Only works if the Xml node is not an Element or a Document.
	</haxe_doc>
		</nodeValue>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>
		Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.
	</haxe_doc>
		</parent>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>
		Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.
	</haxe_doc>
		</nodeType>
		<_nodeName><c path="String"/></_nodeName>
		<_nodeValue><c path="String"/></_nodeValue>
		<_attributes><d><c path="String"/></d></_attributes>
		<_children><c path="Array"><c path="Xml"/></c></_children>
		<_parent><c path="Xml"/></_parent>
		<getNodeName set="method" line="176"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName set="method" line="182"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeValue set="method" line="188"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue set="method" line="194"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<getParent set="method" line="200"><f a=""><c path="Xml"/></f></getParent>
		<get public="1" set="method" line="204">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.
	</haxe_doc>
		</get>
		<set public="1" set="method" line="210">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the given attribute value for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</set>
		<remove public="1" set="method" line="216">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Removes an attribute for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</remove>
		<exists public="1" set="method" line="222">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the Element node has a given attribute.
		Attributes are case-sensitive.
	</haxe_doc>
		</exists>
		<attributes public="1" set="method" line="228">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an [Iterator] on all the attributes values.
	</haxe_doc>
		</attributes>
		<iterator public="1" set="method" line="234">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</iterator>
		<elements public="1" set="method" line="250">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method" line="283">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elementsNamed>
		<firstChild public="1" set="method" line="317">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node.
	</haxe_doc>
		</firstChild>
		<firstElement public="1" set="method" line="323">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node which is an Element.
	</haxe_doc>
		</firstElement>
		<addChild public="1" set="method" line="334">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.
	</haxe_doc>
		</addChild>
		<removeChild public="1" set="method" line="342">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.
	</haxe_doc>
		</removeChild>
		<insertChild public="1" set="method" line="350">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts a child at the given position among the other childs.
	</haxe_doc>
		</insertChild>
		<toString public="1" set="method" line="358">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a String representation of the Xml node.
	</haxe_doc>
		</toString>
		<toStringRec set="method" line="364"><f a="s">
	<c path="StringBuf"/>
	<e path="Void"/>
</f></toStringRec>
		<new set="method" line="51"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.
</haxe_doc>
	</class>
	<class path="haxe.time.Clock" params="" file="../src/main/haxe/haxe/time/Clock.hx" interface="1">
		<__meta__ public="1" line="20" static="1"><d/></__meta__>
		<now public="1" set="method"><f a=""><c path="Date"/></f></now>
	</class>
	<class path="haxe.time.SystemClock" params="" file="../src/main/haxe/haxe/time/Clock.hx" module="haxe.time.Clock">
		<implements path="haxe.time.Clock"/>
		<now public="1" set="method" line="28"><f a=""><c path="Date"/></f></now>
		<new public="1" set="method" line="25"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.time.MockClock" params="" file="../src/main/haxe/haxe/time/Clock.hx" module="haxe.time.Clock">
		<implements path="haxe.time.Clock"/>
		<time public="1"><c path="Float"/></time>
		<now public="1" set="method" line="40"><f a=""><c path="Date"/></f></now>
		<new public="1" set="method" line="36"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.Timer" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/haxe/Timer.hx">
		<delay public="1" set="method" line="76" static="1"><f a="f:time_ms">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<c path="haxe.Timer"/>
</f></delay>
		<measure public="1" params="T" set="method" line="87" static="1"><f a="f:?pos">
	<f a=""><c path="measure.T"/></f>
	<t path="haxe.PosInfos"/>
	<c path="measure.T"/>
</f></measure>
		<stamp public="1" set="method" line="97" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns a timestamp, in seconds
	</haxe_doc>
		</stamp>
		<id><t path="Null"><c path="Int"/></t></id>
		<stop public="1" set="method" line="52"><f a=""><e path="Void"/></f></stop>
		<run public="1" set="dynamic" line="73"><f a=""><e path="Void"/></f></run>
		<new public="1" set="method" line="38"><f a="time_ms">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.http.HttpString" params="" file="../src/main/haxe/haxe/io/http/HttpString.hx" interface="1"><implements path="haxe.io.http.Http"><c path="String"/></implements></class>
	<class path="DynamicExtensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<withEffect public="1" params="T" set="method" line="27" static="1"><f a="t:f">
	<c path="withEffect.T"/>
	<t path="Function">
		<c path="withEffect.T"/>
		<e path="Void"/>
	</t>
	<c path="withEffect.T"/>
</f></withEffect>
		<withEffectP public="1" params="A:B" set="method" line="32" static="1"><f a="a:f">
	<c path="withEffectP.A"/>
	<t path="Function">
		<c path="withEffectP.A"/>
		<c path="withEffectP.B"/>
	</t>
	<c path="withEffectP.A"/>
</f></withEffectP>
		<into public="1" params="A:B" set="method" line="37" static="1"><f a="a:f">
	<c path="into.A"/>
	<f a="">
		<c path="into.A"/>
		<c path="into.B"/>
	</f>
	<c path="into.B"/>
</f></into>
		<isInstanceOf public="1" get="inline" set="null" line="40" static="1"><f a="o:c">
	<d/>
	<d/>
	<e path="Bool"/>
</f></isInstanceOf>
		<entuple public="1" params="A:B" set="method" line="43" static="1"><f a="a:b">
	<c path="entuple.A"/>
	<c path="entuple.B"/>
	<c path="Tuple2">
		<c path="entuple.A"/>
		<c path="entuple.B"/>
	</c>
</f></entuple>
		<memoize public="1" params="T" set="method" line="46" static="1"><f a="t">
	<t path="Thunk"><c path="memoize.T"/></t>
	<t path="Thunk"><c path="memoize.T"/></t>
</f></memoize>
		<toThunk public="1" params="T" set="method" line="56" static="1"><f a="t">
	<c path="toThunk.T"/>
	<t path="Thunk"><c path="toThunk.T"/></t>
</f></toThunk>
		<toConstantFunction public="1" params="S:T" set="method" line="61" static="1"><f a="t">
	<c path="toConstantFunction.T"/>
	<t path="Function">
		<c path="toConstantFunction.S"/>
		<c path="toConstantFunction.T"/>
	</t>
</f></toConstantFunction>
		<toMap public="1" params="T" set="method" line="66" static="1"><f a="d">
	<d><c path="toMap.T"/></d>
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="toMap.T"/>
	</c>
</f></toMap>
	</class>
	<class path="BoolExtensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<toInt public="1" set="method" line="80" static="1"><f a="v">
	<e path="Bool"/>
	<c path="Float"/>
</f></toInt>
		<ifTrue public="1" params="T" set="method" line="82" static="1"><f a="v:f">
	<e path="Bool"/>
	<t path="Thunk"><c path="ifTrue.T"/></t>
	<e path="Option"><c path="ifTrue.T"/></e>
</f></ifTrue>
		<ifFalse public="1" params="T" set="method" line="86" static="1"><f a="v:f">
	<e path="Bool"/>
	<t path="Thunk"><c path="ifFalse.T"/></t>
	<e path="Option"><c path="ifFalse.T"/></e>
</f></ifFalse>
		<ifElse public="1" params="T" set="method" line="90" static="1"><f a="v:f1:f2">
	<e path="Bool"/>
	<t path="Thunk"><c path="ifElse.T"/></t>
	<t path="Thunk"><c path="ifElse.T"/></t>
	<c path="ifElse.T"/>
</f></ifElse>
		<compare public="1" set="method" line="94" static="1"><f a="v1:v2">
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
</f></compare>
		<equals public="1" set="method" line="98" static="1"><f a="v1:v2">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></equals>
		<hashCode public="1" set="method" line="102" static="1"><f a="v">
	<e path="Bool"/>
	<c path="Int"/>
</f></hashCode>
		<toString public="1" set="method" line="106" static="1"><f a="v">
	<e path="Bool"/>
	<c path="String"/>
</f></toString>
		<decompose public="1" set="method" line="109" static="1"><f a="v">
	<e path="Bool"/>
	<e path="haxe.text.json.JValue"/>
</f></decompose>
		<extract public="1" set="method" line="112" static="1"><f a="c:v">
	<c path="Enum"><e path="Bool"/></c>
	<e path="haxe.text.json.JValue"/>
	<e path="Bool"/>
</f></extract>
		<not public="1" set="method" line="121" static="1"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></not>
	</class>
	<class path="IntExtensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<max public="1" set="method" line="126" static="1"><f a="v1:v2">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></max>
		<min public="1" set="method" line="127" static="1"><f a="v1:v2">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></min>
		<toBool public="1" set="method" line="128" static="1"><f a="v">
	<c path="Int"/>
	<e path="Bool"/>
</f></toBool>
		<toFloat public="1" set="method" line="129" static="1"><f a="v">
	<c path="Int"/>
	<c path="Float"/>
</f></toFloat>
		<to public="1" set="method" line="131" static="1"><f a="start:end">
	<c path="Int"/>
	<c path="Int"/>
	<t path="Iterable"><c path="Int"/></t>
</f></to>
		<until public="1" set="method" line="144" static="1"><f a="start:end">
	<c path="Int"/>
	<c path="Int"/>
	<t path="Iterable"><c path="Int"/></t>
</f></until>
		<compare public="1" set="method" line="147" static="1"><f a="v1:v2">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></compare>
		<equals public="1" set="method" line="150" static="1"><f a="v1:v2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></equals>
		<toString public="1" set="method" line="153" static="1"><f a="v">
	<c path="Int"/>
	<c path="String"/>
</f></toString>
		<hashCode public="1" set="method" line="156" static="1"><f a="v">
	<c path="Int"/>
	<c path="Int"/>
</f></hashCode>
		<decompose public="1" set="method" line="159" static="1"><f a="v">
	<c path="Int"/>
	<e path="haxe.text.json.JValue"/>
</f></decompose>
		<extract public="1" set="method" line="162" static="1"><f a="c:v">
	<c path="Class"><c path="Int"/></c>
	<e path="haxe.text.json.JValue"/>
	<c path="Int"/>
</f></extract>
	</class>
	<class path="FloatExtensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<round public="1" set="method" line="172" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<ceil public="1" set="method" line="173" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<floor public="1" set="method" line="174" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<max public="1" set="method" line="175" static="1"><f a="v1:v2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<min public="1" set="method" line="176" static="1"><f a="v1:v2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<toInt public="1" set="method" line="177" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></toInt>
		<compare public="1" set="method" line="178" static="1"><f a="v1:v2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></compare>
		<equals public="1" set="method" line="181" static="1"><f a="v1:v2">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></equals>
		<toString public="1" set="method" line="184" static="1"><f a="v">
	<c path="Float"/>
	<c path="String"/>
</f></toString>
		<hashCode public="1" set="method" line="187" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></hashCode>
		<decompose public="1" set="method" line="190" static="1"><f a="v">
	<c path="Float"/>
	<e path="haxe.text.json.JValue"/>
</f></decompose>
		<extract public="1" set="method" line="193" static="1"><f a="c:v">
	<c path="Class"><c path="Float"/></c>
	<e path="haxe.text.json.JValue"/>
	<c path="Float"/>
</f></extract>
	</class>
	<class path="StringExtensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<toBool public="1" set="method" line="203" static="1"><f a="v:?d">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></toBool>
		<toInt public="1" set="method" line="210" static="1"><f a="v:?d">
	<c path="String"/>
	<c path="Int"/>
	<c path="Int"/>
</f></toInt>
		<toFloat public="1" set="method" line="215" static="1"><f a="v:?d">
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
</f></toFloat>
		<startsWith public="1" set="method" line="220" static="1"><f a="v:frag">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
</f></startsWith>
		<endsWith public="1" set="method" line="223" static="1"><f a="v:frag">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
</f></endsWith>
		<urlEncode public="1" set="method" line="226" static="1"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></urlEncode>
		<urlDecode public="1" set="method" line="229" static="1"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></urlDecode>
		<htmlEscape public="1" set="method" line="232" static="1"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></htmlEscape>
		<htmlUnescape public="1" set="method" line="235" static="1"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></htmlUnescape>
		<trim public="1" set="method" line="238" static="1"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></trim>
		<contains public="1" set="method" line="241" static="1"><f a="v:s">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
</f></contains>
		<replace public="1" set="method" line="244" static="1"><f a="s:sub:by">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></replace>
		<compare public="1" set="method" line="247" static="1"><f a="v1:v2">
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
</f></compare>
		<equals public="1" set="method" line="250" static="1"><f a="v1:v2">
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
</f></equals>
		<toString public="1" set="method" line="253" static="1"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></toString>
		<hashCode public="1" set="method" line="256" static="1"><f a="v">
	<c path="String"/>
	<c path="Int"/>
</f></hashCode>
		<decompose public="1" set="method" line="269" static="1"><f a="v">
	<c path="String"/>
	<e path="haxe.text.json.JValue"/>
</f></decompose>
		<extract public="1" set="method" line="272" static="1"><f a="c:v">
	<c path="Class"><c path="String"/></c>
	<e path="haxe.text.json.JValue"/>
	<c path="String"/>
</f></extract>
	</class>
	<class path="DateExtensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<compare public="1" set="method" line="283" static="1"><f a="v1:v2">
	<c path="Date"/>
	<c path="Date"/>
	<c path="Int"/>
</f></compare>
		<equals public="1" set="method" line="288" static="1"><f a="v1:v2">
	<c path="Date"/>
	<c path="Date"/>
	<e path="Bool"/>
</f></equals>
		<toString public="1" set="method" line="291" static="1"><f a="v">
	<c path="Date"/>
	<c path="String"/>
</f></toString>
		<hashCode public="1" set="method" line="294" static="1"><f a="v">
	<c path="Date"/>
	<c path="Int"/>
</f></hashCode>
		<decompose public="1" set="method" line="297" static="1"><f a="v">
	<c path="Date"/>
	<e path="haxe.text.json.JValue"/>
</f></decompose>
		<extract public="1" set="method" line="300" static="1"><f a="c:v">
	<c path="Class"><c path="Date"/></c>
	<e path="haxe.text.json.JValue"/>
	<c path="Date"/>
</f></extract>
	</class>
	<class path="ArrayExtensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<sort public="1" params="T" set="method" line="310" static="1"><f a="v">
	<c path="Array"><c path="sort.T"/></c>
	<c path="Array"><c path="sort.T"/></c>
</f></sort>
		<sortWith public="1" params="T" set="method" line="314" static="1"><f a="v:order">
	<c path="Array"><c path="sortWith.T"/></c>
	<t path="OrderFunction"><c path="sortWith.T"/></t>
	<c path="Array"><c path="sortWith.T"/></c>
</f></sortWith>
		<compare public="1" params="T" set="method" line="320" static="1"><f a="v1:v2">
	<c path="Array"><c path="compare.T"/></c>
	<c path="Array"><c path="compare.T"/></c>
	<c path="Int"/>
</f></compare>
		<compareWith public="1" params="T" set="method" line="324" static="1"><f a="v1:v2:order">
	<c path="Array"><c path="compareWith.T"/></c>
	<c path="Array"><c path="compareWith.T"/></c>
	<t path="OrderFunction"><c path="compareWith.T"/></t>
	<c path="Int"/>
</f></compareWith>
		<equals public="1" params="T" set="method" line="337" static="1"><f a="v1:v2">
	<c path="Array"><c path="equals.T"/></c>
	<c path="Array"><c path="equals.T"/></c>
	<e path="Bool"/>
</f></equals>
		<equalsWith public="1" params="T" set="method" line="341" static="1"><f a="v1:v2:equal">
	<c path="Array"><c path="equalsWith.T"/></c>
	<c path="Array"><c path="equalsWith.T"/></c>
	<t path="EqualFunction"><c path="equalsWith.T"/></t>
	<e path="Bool"/>
</f></equalsWith>
		<toString public="1" params="T" set="method" line="351" static="1"><f a="v">
	<c path="Array"><c path="toString.T"/></c>
	<c path="String"/>
</f></toString>
		<toStringWith public="1" params="T" set="method" line="354" static="1"><f a="v:show">
	<c path="Array"><c path="toStringWith.T"/></c>
	<t path="ShowFunction"><c path="toStringWith.T"/></t>
	<c path="String"/>
</f></toStringWith>
		<hashCode public="1" params="T" set="method" line="357" static="1"><f a="v">
	<c path="Array"><c path="hashCode.T"/></c>
	<c path="Int"/>
</f></hashCode>
		<hashCodeWith public="1" params="T" set="method" line="360" static="1"><f a="v:hash">
	<c path="Array"><c path="hashCodeWith.T"/></c>
	<t path="HashFunction"><c path="hashCodeWith.T"/></t>
	<c path="Int"/>
</f></hashCodeWith>
		<filter public="1" params="T" set="method" line="370" static="1"><f a="a:f">
	<c path="Array"><c path="filter.T"/></c>
	<f a="">
		<c path="filter.T"/>
		<e path="Bool"/>
	</f>
	<c path="Array"><c path="filter.T"/></c>
</f></filter>
		<size public="1" params="T" set="method" line="379" static="1"><f a="a">
	<c path="Array"><c path="size.T"/></c>
	<c path="Int"/>
</f></size>
		<indexOf public="1" params="T" set="method" line="383" static="1"><f a="a:t">
	<c path="Array"><c path="indexOf.T"/></c>
	<c path="indexOf.T"/>
	<c path="Int"/>
</f></indexOf>
		<map public="1" params="T:S" set="method" line="395" static="1"><f a="a:f">
	<c path="Array"><c path="map.T"/></c>
	<f a="">
		<c path="map.T"/>
		<c path="map.S"/>
	</f>
	<c path="Array"><c path="map.S"/></c>
</f></map>
		<then public="1" params="T:S" set="method" line="402" static="1"><f a="a1:a2">
	<c path="Array"><c path="then.T"/></c>
	<c path="Array"><c path="then.S"/></c>
	<c path="Array"><c path="then.S"/></c>
</f></then>
		<flatMap public="1" params="T:S" set="method" line="406" static="1"><f a="a:f">
	<c path="Array"><c path="flatMap.T"/></c>
	<f a="">
		<c path="flatMap.T"/>
		<t path="Iterable"><c path="flatMap.S"/></t>
	</f>
	<c path="Array"><c path="flatMap.S"/></c>
</f></flatMap>
		<foldl public="1" params="T:Z" set="method" line="416" static="1"><f a="a:z:f">
	<c path="Array"><c path="foldl.T"/></c>
	<c path="foldl.Z"/>
	<f a=":">
		<c path="foldl.Z"/>
		<c path="foldl.T"/>
		<c path="foldl.Z"/>
	</f>
	<c path="foldl.Z"/>
</f></foldl>
		<foldr public="1" params="T:Z" set="method" line="424" static="1"><f a="a:z:f">
	<c path="Array"><c path="foldr.T"/></c>
	<c path="foldr.Z"/>
	<f a=":">
		<c path="foldr.T"/>
		<c path="foldr.Z"/>
		<c path="foldr.Z"/>
	</f>
	<c path="foldr.Z"/>
</f></foldr>
		<zip public="1" params="A:B" set="method" line="436" static="1"><f a="a:b">
	<c path="Array"><c path="zip.A"/></c>
	<c path="Array"><c path="zip.B"/></c>
	<c path="Array"><c path="Tuple2">
	<c path="zip.A"/>
	<c path="zip.B"/>
</c></c>
</f></zip>
		<append public="1" params="T" set="method" line="448" static="1"><f a="a:t">
	<c path="Array"><c path="append.T"/></c>
	<c path="append.T"/>
	<c path="Array"><c path="append.T"/></c>
</f></append>
		<snapshot public="1" params="T" set="method" line="456" static="1"><f a="a">
	<c path="Array"><c path="snapshot.T"/></c>
	<c path="Array"><c path="snapshot.T"/></c>
</f></snapshot>
		<first public="1" params="T" set="method" line="460" static="1"><f a="a">
	<c path="Array"><c path="first.T"/></c>
	<c path="first.T"/>
</f></first>
		<firstOption public="1" params="T" set="method" line="464" static="1"><f a="a">
	<c path="Array"><c path="firstOption.T"/></c>
	<e path="Option"><c path="firstOption.T"/></e>
</f></firstOption>
		<last public="1" params="T" set="method" line="468" static="1"><f a="a">
	<c path="Array"><c path="last.T"/></c>
	<c path="last.T"/>
</f></last>
		<lastOption public="1" params="T" set="method" line="472" static="1"><f a="a">
	<c path="Array"><c path="lastOption.T"/></c>
	<e path="Option"><c path="lastOption.T"/></e>
</f></lastOption>
		<contains public="1" params="T" set="method" line="476" static="1"><f a="a:t">
	<c path="Array"><c path="contains.T"/></c>
	<c path="contains.T"/>
	<e path="Bool"/>
</f></contains>
		<foreach public="1" params="T" set="method" line="482" static="1"><f a="a:f">
	<c path="Array"><c path="foreach.T"/></c>
	<f a="">
		<c path="foreach.T"/>
		<e path="Void"/>
	</f>
	<c path="Array"><c path="foreach.T"/></c>
</f></foreach>
		<take public="1" params="T" set="method" line="487" static="1"><f a="a:n">
	<c path="Array"><c path="take.T"/></c>
	<c path="Int"/>
	<c path="Array"><c path="take.T"/></c>
</f></take>
		<takeWhile public="1" params="T" set="method" line="490" static="1"><f a="a:p">
	<c path="Array"><c path="takeWhile.T"/></c>
	<f a="">
		<c path="takeWhile.T"/>
		<e path="Bool"/>
	</f>
	<c path="Array"><c path="takeWhile.T"/></c>
</f></takeWhile>
		<drop public="1" params="T" set="method" line="499" static="1"><f a="a:n">
	<c path="Array"><c path="drop.T"/></c>
	<c path="Int"/>
	<c path="Array"><c path="drop.T"/></c>
</f></drop>
		<dropWhile public="1" params="T" set="method" line="502" static="1"><f a="a:p">
	<c path="Array"><c path="dropWhile.T"/></c>
	<f a="">
		<c path="dropWhile.T"/>
		<e path="Bool"/>
	</f>
	<c path="Array"><c path="dropWhile.T"/></c>
</f></dropWhile>
		<decompose public="1" params="T" set="method" line="511" static="1"><f a="v">
	<c path="Array"><c path="decompose.T"/></c>
	<e path="haxe.text.json.JValue"/>
</f></decompose>
		<extract public="1" params="T" set="method" line="520" static="1"><f a="c:v:e">
	<c path="Class"><c path="Array"><d/></c></c>
	<e path="haxe.text.json.JValue"/>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.T"/></t>
	<c path="Array"><c path="extract.T"/></c>
</f></extract>
	</class>
	<class path="Function0Extensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<swallow public="1" set="method" line="529" static="1"><f a="f">
	<f a=""><e path="Void"/></f>
	<f a=""><e path="Void"/></f>
</f></swallow>
		<thenDo public="1" set="method" line="538" static="1"><f a="f1:f2">
	<f a=""><e path="Void"/></f>
	<f a=""><e path="Void"/></f>
	<f a=""><e path="Void"/></f>
</f></thenDo>
		<returning public="1" params="R1:R2" set="method" line="544" static="1"><f a="f:thunk">
	<f a=""><c path="returning.R1"/></f>
	<t path="Thunk"><c path="returning.R2"/></t>
	<f a=""><c path="returning.R2"/></f>
</f></returning>
		<returningC public="1" params="R1:R2" set="method" line="551" static="1"><f a="f:value">
	<f a=""><c path="returningC.R2"/></f>
	<c path="returningC.R2"/>
	<f a=""><c path="returningC.R2"/></f>
</f></returningC>
		<promote public="1" params="A:Z" set="method" line="554" static="1"><f a="f">
	<f a=""><c path="promote.Z"/></f>
	<f a="">
		<c path="promote.A"/>
		<c path="promote.Z"/>
	</f>
</f></promote>
		<promoteEffect public="1" params="A" set="method" line="560" static="1"><f a="f">
	<f a=""><e path="Void"/></f>
	<f a="">
		<c path="promoteEffect.A"/>
		<e path="Void"/>
	</f>
</f></promoteEffect>
		<stage public="1" params="Z:T" set="method" line="566" static="1"><f a="f:before:after">
	<t path="Function0"><c path="stage.Z"/></t>
	<f a=""><c path="stage.T"/></f>
	<f a="">
		<c path="stage.T"/>
		<e path="Void"/>
	</f>
	<c path="stage.Z"/>
</f></stage>
		<toEffect public="1" params="T" set="method" line="576" static="1"><f a="f">
	<t path="Function0"><c path="toEffect.T"/></t>
	<f a=""><e path="Void"/></f>
</f></toEffect>
	</class>
	<class path="Function1Extensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<swallow public="1" params="A" set="method" line="583" static="1"><f a="f">
	<t path="Function">
		<c path="swallow.A"/>
		<e path="Void"/>
	</t>
	<t path="Function">
		<c path="swallow.A"/>
		<e path="Void"/>
	</t>
</f></swallow>
		<swallowWith public="1" params="P1:R" set="method" line="586" static="1"><f a="f:d">
	<t path="Function">
		<c path="swallowWith.P1"/>
		<c path="swallowWith.R"/>
	</t>
	<c path="swallowWith.R"/>
	<t path="Function">
		<c path="swallowWith.P1"/>
		<c path="swallowWith.R"/>
	</t>
</f></swallowWith>
		<thenDo public="1" params="P1" set="method" line="595" static="1"><f a="f1:f2">
	<f a="">
		<c path="thenDo.P1"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="thenDo.P1"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="thenDo.P1"/>
		<e path="Void"/>
	</f>
</f></thenDo>
		<returning public="1" params="P1:R1:R2" set="method" line="601" static="1"><f a="f:thunk">
	<t path="Function">
		<c path="returning.P1"/>
		<c path="returning.R1"/>
	</t>
	<t path="Thunk"><c path="returning.R2"/></t>
	<t path="Function">
		<c path="returning.P1"/>
		<c path="returning.R2"/>
	</t>
</f></returning>
		<returningC public="1" params="P1:R1:R2" set="method" line="608" static="1"><f a="f:value">
	<t path="Function">
		<c path="returningC.P1"/>
		<c path="returningC.R2"/>
	</t>
	<c path="returningC.R2"/>
	<t path="Function">
		<c path="returningC.P1"/>
		<c path="returningC.R2"/>
	</t>
</f></returningC>
		<compose public="1" params="U:V:W" set="method" line="611" static="1"><f a="f1:f2">
	<t path="Function">
		<c path="compose.V"/>
		<c path="compose.W"/>
	</t>
	<t path="Function">
		<c path="compose.U"/>
		<c path="compose.V"/>
	</t>
	<t path="Function">
		<c path="compose.U"/>
		<c path="compose.W"/>
	</t>
</f></compose>
		<andThen public="1" params="U:V:W" set="method" line="616" static="1"><f a="f1:f2">
	<t path="Function">
		<c path="andThen.U"/>
		<c path="andThen.V"/>
	</t>
	<t path="Function">
		<c path="andThen.V"/>
		<c path="andThen.W"/>
	</t>
	<t path="Function">
		<c path="andThen.U"/>
		<c path="andThen.W"/>
	</t>
</f></andThen>
		<lazy public="1" params="P1:R" set="method" line="619" static="1"><f a="f:p1">
	<t path="Function">
		<c path="lazy.P1"/>
		<c path="lazy.R"/>
	</t>
	<c path="lazy.P1"/>
	<t path="Thunk"><c path="lazy.R"/></t>
</f></lazy>
		<toEffect public="1" params="P1:R" set="method" line="626" static="1"><f a="f">
	<t path="Function">
		<c path="toEffect.P1"/>
		<c path="toEffect.R"/>
	</t>
	<f a="">
		<c path="toEffect.P1"/>
		<e path="Void"/>
	</f>
</f></toEffect>
	</class>
	<class path="Function2Extensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<swallow public="1" params="P1:P2" set="method" line="633" static="1"><f a="f">
	<t path="Function2">
		<c path="swallow.P1"/>
		<c path="swallow.P2"/>
		<e path="Void"/>
	</t>
	<t path="Function2">
		<c path="swallow.P1"/>
		<c path="swallow.P2"/>
		<e path="Void"/>
	</t>
</f></swallow>
		<swallowWith public="1" params="P1:P2:R" set="method" line="636" static="1"><f a="f:d">
	<t path="Function2">
		<c path="swallowWith.P1"/>
		<c path="swallowWith.P2"/>
		<c path="swallowWith.R"/>
	</t>
	<c path="swallowWith.R"/>
	<t path="Function2">
		<c path="swallowWith.P1"/>
		<c path="swallowWith.P2"/>
		<c path="swallowWith.R"/>
	</t>
</f></swallowWith>
		<thenDo public="1" params="P1:P2" set="method" line="645" static="1"><f a="f1:f2">
	<f a=":">
		<c path="thenDo.P1"/>
		<c path="thenDo.P2"/>
		<e path="Void"/>
	</f>
	<f a=":">
		<c path="thenDo.P1"/>
		<c path="thenDo.P2"/>
		<e path="Void"/>
	</f>
	<f a=":">
		<c path="thenDo.P1"/>
		<c path="thenDo.P2"/>
		<e path="Void"/>
	</f>
</f></thenDo>
		<returning public="1" params="P1:P2:R1:R2" set="method" line="651" static="1"><f a="f:thunk">
	<t path="Function2">
		<c path="returning.P1"/>
		<c path="returning.P2"/>
		<c path="returning.R1"/>
	</t>
	<t path="Thunk"><c path="returning.R2"/></t>
	<t path="Function2">
		<c path="returning.P1"/>
		<c path="returning.P2"/>
		<c path="returning.R2"/>
	</t>
</f></returning>
		<returningC public="1" set="method" line="658" static="1"><f a="f:value">
	<t path="Function2">
		<unknown/>
		<unknown/>
		<unknown/>
	</t>
	<a><toThunk set="null"><f a=""><t path="Thunk"><unknown/></t></f></toThunk></a>
	<t path="Function2">
		<unknown/>
		<unknown/>
		<unknown/>
	</t>
</f></returningC>
		<flip public="1" params="P1:P2:R" set="method" line="661" static="1"><f a="f">
	<t path="Function2">
		<c path="flip.P1"/>
		<c path="flip.P2"/>
		<c path="flip.R"/>
	</t>
	<t path="Function2">
		<c path="flip.P2"/>
		<c path="flip.P1"/>
		<c path="flip.R"/>
	</t>
</f></flip>
		<curry public="1" params="P1:P2:R" set="method" line="666" static="1"><f a="f">
	<t path="Function2">
		<c path="curry.P1"/>
		<c path="curry.P2"/>
		<c path="curry.R"/>
	</t>
	<t path="Function">
		<c path="curry.P1"/>
		<t path="Function">
			<c path="curry.P2"/>
			<c path="curry.R"/>
		</t>
	</t>
</f></curry>
		<uncurry public="1" params="P1:P2:R" set="method" line="673" static="1"><f a="f">
	<t path="Function">
		<c path="uncurry.P1"/>
		<t path="Function">
			<c path="uncurry.P2"/>
			<c path="uncurry.R"/>
		</t>
	</t>
	<t path="Function2">
		<c path="uncurry.P1"/>
		<c path="uncurry.P2"/>
		<c path="uncurry.R"/>
	</t>
</f></uncurry>
		<lazy public="1" params="P1:P2:R" set="method" line="678" static="1"><f a="f:p1:p2">
	<t path="Function2">
		<c path="lazy.P1"/>
		<c path="lazy.P2"/>
		<c path="lazy.R"/>
	</t>
	<c path="lazy.P1"/>
	<c path="lazy.P2"/>
	<t path="Thunk"><c path="lazy.R"/></t>
</f></lazy>
		<toEffect public="1" params="P1:P2:R" set="method" line="685" static="1"><f a="f">
	<t path="Function2">
		<c path="toEffect.P1"/>
		<c path="toEffect.P2"/>
		<c path="toEffect.R"/>
	</t>
	<f a=":">
		<c path="toEffect.P1"/>
		<c path="toEffect.P2"/>
		<e path="Void"/>
	</f>
</f></toEffect>
	</class>
	<class path="Function3Extensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<swallow public="1" params="A:B:C" set="method" line="692" static="1"><f a="f">
	<t path="Function3">
		<c path="swallow.A"/>
		<c path="swallow.B"/>
		<c path="swallow.C"/>
		<e path="Void"/>
	</t>
	<t path="Function3">
		<c path="swallow.A"/>
		<c path="swallow.B"/>
		<c path="swallow.C"/>
		<e path="Void"/>
	</t>
</f></swallow>
		<swallowWith public="1" params="A:B:C:R" set="method" line="695" static="1"><f a="f:d">
	<t path="Function3">
		<c path="swallowWith.A"/>
		<c path="swallowWith.B"/>
		<c path="swallowWith.C"/>
		<c path="swallowWith.R"/>
	</t>
	<c path="swallowWith.R"/>
	<t path="Function3">
		<c path="swallowWith.A"/>
		<c path="swallowWith.B"/>
		<c path="swallowWith.C"/>
		<c path="swallowWith.R"/>
	</t>
</f></swallowWith>
		<thenDo public="1" params="P1:P2:P3" set="method" line="704" static="1"><f a="f1:f2">
	<f a="::">
		<c path="thenDo.P1"/>
		<c path="thenDo.P2"/>
		<c path="thenDo.P3"/>
		<e path="Void"/>
	</f>
	<f a="::">
		<c path="thenDo.P1"/>
		<c path="thenDo.P2"/>
		<c path="thenDo.P3"/>
		<e path="Void"/>
	</f>
	<f a="::">
		<c path="thenDo.P1"/>
		<c path="thenDo.P2"/>
		<c path="thenDo.P3"/>
		<e path="Void"/>
	</f>
</f></thenDo>
		<returning public="1" params="P1:P2:P3:R1:R2" set="method" line="710" static="1"><f a="f:thunk">
	<t path="Function3">
		<c path="returning.P1"/>
		<c path="returning.P2"/>
		<c path="returning.P3"/>
		<c path="returning.R1"/>
	</t>
	<t path="Thunk"><c path="returning.R2"/></t>
	<t path="Function3">
		<c path="returning.P1"/>
		<c path="returning.P2"/>
		<c path="returning.P3"/>
		<c path="returning.R2"/>
	</t>
</f></returning>
		<returningC public="1" set="method" line="717" static="1"><f a="f:value">
	<t path="Function3">
		<unknown/>
		<unknown/>
		<unknown/>
		<unknown/>
	</t>
	<a><toThunk set="null"><f a=""><t path="Thunk"><unknown/></t></f></toThunk></a>
	<t path="Function3">
		<unknown/>
		<unknown/>
		<unknown/>
		<unknown/>
	</t>
</f></returningC>
		<curry public="1" params="P1:P2:P3:R" set="method" line="720" static="1"><f a="f">
	<t path="Function3">
		<c path="curry.P1"/>
		<c path="curry.P2"/>
		<c path="curry.P3"/>
		<c path="curry.R"/>
	</t>
	<t path="Function">
		<c path="curry.P1"/>
		<t path="Function">
			<c path="curry.P2"/>
			<t path="Function">
				<c path="curry.P3"/>
				<c path="curry.R"/>
			</t>
		</t>
	</t>
</f></curry>
		<uncurry public="1" params="P1:P2:P3:R" set="method" line="729" static="1"><f a="f">
	<t path="Function">
		<c path="uncurry.P1"/>
		<t path="Function">
			<c path="uncurry.P2"/>
			<t path="Function">
				<c path="uncurry.P3"/>
				<c path="uncurry.R"/>
			</t>
		</t>
	</t>
	<t path="Function3">
		<c path="uncurry.P1"/>
		<c path="uncurry.P2"/>
		<c path="uncurry.P3"/>
		<c path="uncurry.R"/>
	</t>
</f></uncurry>
		<lazy public="1" params="P1:P2:P3:R" set="method" line="734" static="1"><f a="f:p1:p2:p3">
	<t path="Function3">
		<c path="lazy.P1"/>
		<c path="lazy.P2"/>
		<c path="lazy.P3"/>
		<c path="lazy.R"/>
	</t>
	<c path="lazy.P1"/>
	<c path="lazy.P2"/>
	<c path="lazy.P3"/>
	<t path="Thunk"><c path="lazy.R"/></t>
</f></lazy>
		<toEffect public="1" params="P1:P2:P3:R" set="method" line="741" static="1"><f a="f">
	<t path="Function3">
		<c path="toEffect.P1"/>
		<c path="toEffect.P2"/>
		<c path="toEffect.P3"/>
		<c path="toEffect.R"/>
	</t>
	<f a="::">
		<c path="toEffect.P1"/>
		<c path="toEffect.P2"/>
		<c path="toEffect.P3"/>
		<e path="Void"/>
	</f>
</f></toEffect>
	</class>
	<class path="Function4Extensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<swallow public="1" params="A:B:C:D" set="method" line="748" static="1"><f a="f">
	<t path="Function4">
		<c path="swallow.A"/>
		<c path="swallow.B"/>
		<c path="swallow.C"/>
		<c path="swallow.D"/>
		<e path="Void"/>
	</t>
	<t path="Function4">
		<c path="swallow.A"/>
		<c path="swallow.B"/>
		<c path="swallow.C"/>
		<c path="swallow.D"/>
		<e path="Void"/>
	</t>
</f></swallow>
		<swallowWith public="1" params="A:B:C:D:R" set="method" line="751" static="1"><f a="f:def">
	<t path="Function4">
		<c path="swallowWith.A"/>
		<c path="swallowWith.B"/>
		<c path="swallowWith.C"/>
		<c path="swallowWith.D"/>
		<c path="swallowWith.R"/>
	</t>
	<c path="swallowWith.R"/>
	<t path="Function4">
		<c path="swallowWith.A"/>
		<c path="swallowWith.B"/>
		<c path="swallowWith.C"/>
		<c path="swallowWith.D"/>
		<c path="swallowWith.R"/>
	</t>
</f></swallowWith>
		<thenDo public="1" params="P1:P2:P3:P4" set="method" line="760" static="1"><f a="f1:f2">
	<f a=":::">
		<c path="thenDo.P1"/>
		<c path="thenDo.P2"/>
		<c path="thenDo.P3"/>
		<c path="thenDo.P4"/>
		<e path="Void"/>
	</f>
	<f a=":::">
		<c path="thenDo.P1"/>
		<c path="thenDo.P2"/>
		<c path="thenDo.P3"/>
		<c path="thenDo.P4"/>
		<e path="Void"/>
	</f>
	<f a=":::">
		<c path="thenDo.P1"/>
		<c path="thenDo.P2"/>
		<c path="thenDo.P3"/>
		<c path="thenDo.P4"/>
		<e path="Void"/>
	</f>
</f></thenDo>
		<returning public="1" params="P1:P2:P3:P4:R1:R2" set="method" line="766" static="1"><f a="f:thunk">
	<t path="Function4">
		<c path="returning.P1"/>
		<c path="returning.P2"/>
		<c path="returning.P3"/>
		<c path="returning.P4"/>
		<c path="returning.R1"/>
	</t>
	<t path="Thunk"><c path="returning.R2"/></t>
	<t path="Function4">
		<c path="returning.P1"/>
		<c path="returning.P2"/>
		<c path="returning.P3"/>
		<c path="returning.P4"/>
		<c path="returning.R2"/>
	</t>
</f></returning>
		<returningC public="1" set="method" line="773" static="1"><f a="f:value">
	<t path="Function4">
		<unknown/>
		<unknown/>
		<unknown/>
		<unknown/>
		<unknown/>
	</t>
	<a><toThunk set="null"><f a=""><t path="Thunk"><unknown/></t></f></toThunk></a>
	<t path="Function4">
		<unknown/>
		<unknown/>
		<unknown/>
		<unknown/>
		<unknown/>
	</t>
</f></returningC>
		<curry public="1" params="P1:P2:P3:P4:R" set="method" line="776" static="1"><f a="f">
	<t path="Function4">
		<c path="curry.P1"/>
		<c path="curry.P2"/>
		<c path="curry.P3"/>
		<c path="curry.P4"/>
		<c path="curry.R"/>
	</t>
	<t path="Function">
		<c path="curry.P1"/>
		<t path="Function">
			<c path="curry.P2"/>
			<t path="Function">
				<c path="curry.P3"/>
				<t path="Function">
					<c path="curry.P4"/>
					<c path="curry.R"/>
				</t>
			</t>
		</t>
	</t>
</f></curry>
		<uncurry public="1" params="P1:P2:P3:P4:R" set="method" line="787" static="1"><f a="f">
	<t path="Function">
		<c path="uncurry.P1"/>
		<t path="Function">
			<c path="uncurry.P2"/>
			<t path="Function">
				<c path="uncurry.P3"/>
				<t path="Function">
					<c path="uncurry.P4"/>
					<c path="uncurry.R"/>
				</t>
			</t>
		</t>
	</t>
	<t path="Function4">
		<c path="uncurry.P1"/>
		<c path="uncurry.P2"/>
		<c path="uncurry.P3"/>
		<c path="uncurry.P4"/>
		<c path="uncurry.R"/>
	</t>
</f></uncurry>
		<lazy public="1" params="P1:P2:P3:P4:R" set="method" line="792" static="1"><f a="f:p1:p2:p3:p4">
	<t path="Function4">
		<c path="lazy.P1"/>
		<c path="lazy.P2"/>
		<c path="lazy.P3"/>
		<c path="lazy.P4"/>
		<c path="lazy.R"/>
	</t>
	<c path="lazy.P1"/>
	<c path="lazy.P2"/>
	<c path="lazy.P3"/>
	<c path="lazy.P4"/>
	<t path="Thunk"><c path="lazy.R"/></t>
</f></lazy>
		<toEffect public="1" params="P1:P2:P3:P4:R" set="method" line="799" static="1"><f a="f">
	<t path="Function4">
		<c path="toEffect.P1"/>
		<c path="toEffect.P2"/>
		<c path="toEffect.P3"/>
		<c path="toEffect.P4"/>
		<c path="toEffect.R"/>
	</t>
	<f a=":::">
		<c path="toEffect.P1"/>
		<c path="toEffect.P2"/>
		<c path="toEffect.P3"/>
		<c path="toEffect.P4"/>
		<e path="Void"/>
	</f>
</f></toEffect>
	</class>
	<class path="Function5Extensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<swallow public="1" params="A:B:C:D:E" set="method" line="806" static="1"><f a="f">
	<t path="Function5">
		<c path="swallow.A"/>
		<c path="swallow.B"/>
		<c path="swallow.C"/>
		<c path="swallow.D"/>
		<c path="swallow.E"/>
		<e path="Void"/>
	</t>
	<t path="Function5">
		<c path="swallow.A"/>
		<c path="swallow.B"/>
		<c path="swallow.C"/>
		<c path="swallow.D"/>
		<c path="swallow.E"/>
		<e path="Void"/>
	</t>
</f></swallow>
		<swallowWith public="1" params="A:B:C:D:E:R" set="method" line="809" static="1"><f a="f:def">
	<t path="Function5">
		<c path="swallowWith.A"/>
		<c path="swallowWith.B"/>
		<c path="swallowWith.C"/>
		<c path="swallowWith.D"/>
		<c path="swallowWith.E"/>
		<c path="swallowWith.R"/>
	</t>
	<c path="swallowWith.R"/>
	<t path="Function5">
		<c path="swallowWith.A"/>
		<c path="swallowWith.B"/>
		<c path="swallowWith.C"/>
		<c path="swallowWith.D"/>
		<c path="swallowWith.E"/>
		<c path="swallowWith.R"/>
	</t>
</f></swallowWith>
		<thenDo public="1" params="P1:P2:P3:P4:P5" set="method" line="818" static="1"><f a="f1:f2">
	<f a="::::">
		<c path="thenDo.P1"/>
		<c path="thenDo.P2"/>
		<c path="thenDo.P3"/>
		<c path="thenDo.P4"/>
		<c path="thenDo.P5"/>
		<e path="Void"/>
	</f>
	<f a="::::">
		<c path="thenDo.P1"/>
		<c path="thenDo.P2"/>
		<c path="thenDo.P3"/>
		<c path="thenDo.P4"/>
		<c path="thenDo.P5"/>
		<e path="Void"/>
	</f>
	<f a="::::">
		<c path="thenDo.P1"/>
		<c path="thenDo.P2"/>
		<c path="thenDo.P3"/>
		<c path="thenDo.P4"/>
		<c path="thenDo.P5"/>
		<e path="Void"/>
	</f>
</f></thenDo>
		<returning public="1" params="P1:P2:P3:P4:P5:R1:R2" set="method" line="824" static="1"><f a="f:thunk">
	<t path="Function5">
		<c path="returning.P1"/>
		<c path="returning.P2"/>
		<c path="returning.P3"/>
		<c path="returning.P4"/>
		<c path="returning.P5"/>
		<c path="returning.R1"/>
	</t>
	<t path="Thunk"><c path="returning.R2"/></t>
	<t path="Function5">
		<c path="returning.P1"/>
		<c path="returning.P2"/>
		<c path="returning.P3"/>
		<c path="returning.P4"/>
		<c path="returning.P5"/>
		<c path="returning.R2"/>
	</t>
</f></returning>
		<returningC public="1" set="method" line="831" static="1"><f a="f:value">
	<t path="Function5">
		<unknown/>
		<unknown/>
		<unknown/>
		<unknown/>
		<unknown/>
		<unknown/>
	</t>
	<a><toThunk set="null"><f a=""><t path="Thunk"><unknown/></t></f></toThunk></a>
	<t path="Function5">
		<unknown/>
		<unknown/>
		<unknown/>
		<unknown/>
		<unknown/>
		<unknown/>
	</t>
</f></returningC>
		<curry public="1" params="P1:P2:P3:P4:P5:R" set="method" line="834" static="1"><f a="f">
	<t path="Function5">
		<c path="curry.P1"/>
		<c path="curry.P2"/>
		<c path="curry.P3"/>
		<c path="curry.P4"/>
		<c path="curry.P5"/>
		<c path="curry.R"/>
	</t>
	<t path="Function">
		<c path="curry.P1"/>
		<t path="Function">
			<c path="curry.P2"/>
			<t path="Function">
				<c path="curry.P3"/>
				<t path="Function">
					<c path="curry.P4"/>
					<t path="Function">
						<c path="curry.P5"/>
						<c path="curry.R"/>
					</t>
				</t>
			</t>
		</t>
	</t>
</f></curry>
		<uncurry public="1" params="P1:P2:P3:P4:P5:R" set="method" line="847" static="1"><f a="f">
	<t path="Function">
		<c path="uncurry.P1"/>
		<t path="Function">
			<c path="uncurry.P2"/>
			<t path="Function">
				<c path="uncurry.P3"/>
				<t path="Function">
					<c path="uncurry.P4"/>
					<t path="Function">
						<c path="uncurry.P5"/>
						<c path="uncurry.R"/>
					</t>
				</t>
			</t>
		</t>
	</t>
	<t path="Function5">
		<c path="uncurry.P1"/>
		<c path="uncurry.P2"/>
		<c path="uncurry.P3"/>
		<c path="uncurry.P4"/>
		<c path="uncurry.P5"/>
		<c path="uncurry.R"/>
	</t>
</f></uncurry>
		<lazy public="1" params="P1:P2:P3:P4:P5:R" set="method" line="852" static="1"><f a="f:p1:p2:p3:p4:p5">
	<t path="Function5">
		<c path="lazy.P1"/>
		<c path="lazy.P2"/>
		<c path="lazy.P3"/>
		<c path="lazy.P4"/>
		<c path="lazy.P5"/>
		<c path="lazy.R"/>
	</t>
	<c path="lazy.P1"/>
	<c path="lazy.P2"/>
	<c path="lazy.P3"/>
	<c path="lazy.P4"/>
	<c path="lazy.P5"/>
	<t path="Thunk"><c path="lazy.R"/></t>
</f></lazy>
		<toEffect public="1" params="P1:P2:P3:P4:P5:R" set="method" line="859" static="1"><f a="f">
	<t path="Function5">
		<c path="toEffect.P1"/>
		<c path="toEffect.P2"/>
		<c path="toEffect.P3"/>
		<c path="toEffect.P4"/>
		<c path="toEffect.P5"/>
		<c path="toEffect.R"/>
	</t>
	<f a="::::">
		<c path="toEffect.P1"/>
		<c path="toEffect.P2"/>
		<c path="toEffect.P3"/>
		<c path="toEffect.P4"/>
		<c path="toEffect.P5"/>
		<e path="Void"/>
	</f>
</f></toEffect>
	</class>
	<class path="OptionExtensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<toOption public="1" params="T" set="method" line="867" static="1"><f a="t">
	<c path="toOption.T"/>
	<e path="Option"><c path="toOption.T"/></e>
</f></toOption>
		<toArray public="1" params="T" set="method" line="871" static="1"><f a="o">
	<e path="Option"><c path="toArray.T"/></e>
	<c path="Array"><c path="toArray.T"/></c>
</f></toArray>
		<map public="1" params="T:S" set="method" line="878" static="1"><f a="o:f">
	<e path="Option"><c path="map.T"/></e>
	<f a="">
		<c path="map.T"/>
		<c path="map.S"/>
	</f>
	<e path="Option"><c path="map.S"/></e>
</f></map>
		<then public="1" params="T:S" set="method" line="884" static="1"><f a="o1:o2">
	<e path="Option"><c path="then.T"/></e>
	<e path="Option"><c path="then.S"/></e>
	<e path="Option"><c path="then.S"/></e>
</f></then>
		<foreach public="1" params="T" set="method" line="887" static="1"><f a="o:f">
	<e path="Option"><c path="foreach.T"/></e>
	<f a="">
		<c path="foreach.T"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></foreach>
		<filter public="1" params="T" set="method" line="894" static="1"><f a="o:f">
	<e path="Option"><c path="filter.T"/></e>
	<f a="">
		<c path="filter.T"/>
		<e path="Bool"/>
	</f>
	<e path="Option"><c path="filter.T"/></e>
</f></filter>
		<flatMap public="1" params="T:S" set="method" line="901" static="1"><f a="o:f">
	<e path="Option"><c path="flatMap.T"/></e>
	<f a="">
		<c path="flatMap.T"/>
		<e path="Option"><c path="flatMap.S"/></e>
	</f>
	<e path="Option"><c path="flatMap.S"/></e>
</f></flatMap>
		<flatten public="1" params="T" set="method" line="905" static="1"><f a="o1">
	<e path="Option"><e path="Option"><c path="flatten.T"/></e></e>
	<e path="Option"><c path="flatten.T"/></e>
</f></flatten>
		<zip public="1" params="T:S" set="method" line="912" static="1"><f a="o1:o2">
	<e path="Option"><c path="zip.T"/></e>
	<e path="Option"><c path="zip.S"/></e>
	<e path="Option"><c path="Tuple2">
	<c path="zip.T"/>
	<c path="zip.S"/>
</c></e>
</f></zip>
		<get public="1" params="T" set="method" line="922" static="1"><f a="o">
	<e path="Option"><c path="get.T"/></e>
	<c path="get.T"/>
</f></get>
		<orElse public="1" params="T" set="method" line="929" static="1"><f a="o1:thunk">
	<e path="Option"><c path="orElse.T"/></e>
	<t path="Thunk"><e path="Option"><c path="orElse.T"/></e></t>
	<e path="Option"><c path="orElse.T"/></e>
</f></orElse>
		<orElseC public="1" params="T" set="method" line="937" static="1"><f a="o1:o2">
	<e path="Option"><c path="orElseC.T"/></e>
	<e path="Option"><c path="orElseC.T"/></e>
	<e path="Option"><c path="orElseC.T"/></e>
</f></orElseC>
		<orEither public="1" params="T:S" set="method" line="941" static="1"><f a="o1:thunk">
	<e path="Option"><c path="orEither.T"/></e>
	<t path="Thunk"><c path="orEither.S"/></t>
	<e path="Either">
		<c path="orEither.T"/>
		<c path="orEither.S"/>
	</e>
</f></orEither>
		<orEitherC public="1" params="T:S" set="method" line="949" static="1"><f a="o1:c">
	<e path="Option"><c path="orEitherC.T"/></e>
	<c path="orEitherC.S"/>
	<e path="Either">
		<c path="orEitherC.T"/>
		<c path="orEitherC.S"/>
	</e>
</f></orEitherC>
		<getOrElse public="1" params="T" set="method" line="953" static="1"><f a="o:thunk">
	<e path="Option"><c path="getOrElse.T"/></e>
	<t path="Thunk"><c path="getOrElse.T"/></t>
	<c path="getOrElse.T"/>
</f></getOrElse>
		<getOrElseC public="1" params="T" set="method" line="960" static="1"><f a="o:c">
	<e path="Option"><c path="getOrElseC.T"/></e>
	<c path="getOrElseC.T"/>
	<c path="getOrElseC.T"/>
</f></getOrElseC>
		<isEmpty public="1" params="T" set="method" line="964" static="1"><f a="o">
	<e path="Option"><c path="isEmpty.T"/></e>
	<e path="Bool"/>
</f></isEmpty>
		<decompose public="1" params="T" set="method" line="970" static="1"><f a="v">
	<e path="Option"><c path="decompose.T"/></e>
	<e path="haxe.text.json.JValue"/>
</f></decompose>
		<extract public="1" params="T" set="method" line="973" static="1"><f a="c:v:e">
	<c path="Enum"><e path="Option"><d/></e></c>
	<e path="haxe.text.json.JValue"/>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.T"/></t>
	<e path="Option"><c path="extract.T"/></e>
</f></extract>
	</class>
	<class path="EitherExtensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<toLeft public="1" params="A:B" set="method" line="983" static="1"><f a="v">
	<c path="toLeft.A"/>
	<e path="Either">
		<c path="toLeft.A"/>
		<c path="toLeft.B"/>
	</e>
</f></toLeft>
		<toRight public="1" params="A:B" set="method" line="987" static="1"><f a="v">
	<c path="toRight.B"/>
	<e path="Either">
		<c path="toRight.A"/>
		<c path="toRight.B"/>
	</e>
</f></toRight>
		<flip public="1" params="A:B" set="method" line="991" static="1"><f a="e">
	<e path="Either">
		<c path="flip.A"/>
		<c path="flip.B"/>
	</e>
	<e path="Either">
		<c path="flip.B"/>
		<c path="flip.A"/>
	</e>
</f></flip>
		<left public="1" params="A:B" set="method" line="998" static="1"><f a="e">
	<e path="Either">
		<c path="left.A"/>
		<c path="left.B"/>
	</e>
	<e path="Option"><c path="left.A"/></e>
</f></left>
		<isLeft public="1" params="A:B" set="method" line="1006" static="1"><f a="e">
	<e path="Either">
		<c path="isLeft.A"/>
		<c path="isLeft.B"/>
	</e>
	<e path="Bool"/>
</f></isLeft>
		<isRight public="1" params="A:B" set="method" line="1013" static="1"><f a="e">
	<e path="Either">
		<c path="isRight.A"/>
		<c path="isRight.B"/>
	</e>
	<e path="Bool"/>
</f></isRight>
		<right public="1" params="A:B" set="method" line="1020" static="1"><f a="e">
	<e path="Either">
		<c path="right.A"/>
		<c path="right.B"/>
	</e>
	<e path="Option"><c path="right.B"/></e>
</f></right>
		<get public="1" params="A" set="method" line="1028" static="1"><f a="e">
	<e path="Either">
		<c path="get.A"/>
		<c path="get.A"/>
	</e>
	<c path="get.A"/>
</f></get>
		<mapLeft public="1" params="A:B:C" set="method" line="1035" static="1"><f a="e:f">
	<e path="Either">
		<c path="mapLeft.A"/>
		<c path="mapLeft.B"/>
	</e>
	<f a="">
		<c path="mapLeft.A"/>
		<c path="mapLeft.C"/>
	</f>
	<e path="Either">
		<c path="mapLeft.C"/>
		<c path="mapLeft.B"/>
	</e>
</f></mapLeft>
		<map public="1" params="A:B:C:D" set="method" line="1042" static="1"><f a="e:f1:f2">
	<e path="Either">
		<c path="map.A"/>
		<c path="map.B"/>
	</e>
	<f a="">
		<c path="map.A"/>
		<c path="map.C"/>
	</f>
	<f a="">
		<c path="map.B"/>
		<c path="map.D"/>
	</f>
	<e path="Either">
		<c path="map.C"/>
		<c path="map.D"/>
	</e>
</f></map>
		<mapRight public="1" params="A:B:D" set="method" line="1049" static="1"><f a="e:f">
	<e path="Either">
		<c path="mapRight.A"/>
		<c path="mapRight.B"/>
	</e>
	<f a="">
		<c path="mapRight.B"/>
		<c path="mapRight.D"/>
	</f>
	<e path="Either">
		<c path="mapRight.A"/>
		<c path="mapRight.D"/>
	</e>
</f></mapRight>
		<flatMap public="1" params="A:B:C:D" set="method" line="1056" static="1"><f a="e:f1:f2">
	<e path="Either">
		<c path="flatMap.A"/>
		<c path="flatMap.B"/>
	</e>
	<f a="">
		<c path="flatMap.A"/>
		<e path="Either">
			<c path="flatMap.C"/>
			<c path="flatMap.D"/>
		</e>
	</f>
	<f a="">
		<c path="flatMap.B"/>
		<e path="Either">
			<c path="flatMap.C"/>
			<c path="flatMap.D"/>
		</e>
	</f>
	<e path="Either">
		<c path="flatMap.C"/>
		<c path="flatMap.D"/>
	</e>
</f></flatMap>
		<composeLeft public="1" params="A:B" set="method" line="1066" static="1">
			<f a="e1:e2:ac:bc">
				<e path="Either">
					<c path="composeLeft.A"/>
					<c path="composeLeft.B"/>
				</e>
				<e path="Either">
					<c path="composeLeft.A"/>
					<c path="composeLeft.B"/>
				</e>
				<f a=":">
					<c path="composeLeft.A"/>
					<c path="composeLeft.A"/>
					<c path="composeLeft.A"/>
				</f>
				<f a=":">
					<c path="composeLeft.B"/>
					<c path="composeLeft.B"/>
					<c path="composeLeft.B"/>
				</f>
				<e path="Either">
					<c path="composeLeft.A"/>
					<c path="composeLeft.B"/>
				</e>
			</f>
			<haxe_doc> Composes two Eithers together. In case of conflicts, "failure" (left) 
   * always wins.
   </haxe_doc>
		</composeLeft>
		<composeRight public="1" params="A:B" set="method" line="1082" static="1">
			<f a="e1:e2:ac:bc">
				<e path="Either">
					<c path="composeRight.A"/>
					<c path="composeRight.B"/>
				</e>
				<e path="Either">
					<c path="composeRight.A"/>
					<c path="composeRight.B"/>
				</e>
				<f a=":">
					<c path="composeRight.A"/>
					<c path="composeRight.A"/>
					<c path="composeRight.A"/>
				</f>
				<f a=":">
					<c path="composeRight.B"/>
					<c path="composeRight.B"/>
					<c path="composeRight.B"/>
				</f>
				<e path="Either">
					<c path="composeRight.A"/>
					<c path="composeRight.B"/>
				</e>
			</f>
			<haxe_doc> Composes two Eithers together. In case of conflicts, "success" (right) 
   * always wins.
   </haxe_doc>
		</composeRight>
	</class>
	<class path="FutureExtensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions"><toFuture public="1" params="T" set="method" line="1096" static="1"><f a="t">
	<c path="toFuture.T"/>
	<c path="Future"><c path="toFuture.T"/></c>
</f></toFuture></class>
	<class path="IterableExtensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<toString public="1" params="T" set="method" line="1102" static="1"><f a="i:?show:?prefix:?suffix:?sep">
	<t path="Iterable"><c path="toString.T"/></t>
	<f a="">
		<c path="toString.T"/>
		<c path="String"/>
	</f>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></toString>
		<mkString public="1" params="T" set="method" line="1106" static="1"><f a="i:?show:?prefix:?suffix:?sep">
	<t path="Iterable"><c path="mkString.T"/></t>
	<f a="">
		<c path="mkString.T"/>
		<c path="String"/>
	</f>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></mkString>
		<toList public="1" params="T" set="method" line="1122" static="1"><f a="i">
	<t path="Iterable"><c path="toList.T"/></t>
	<c path="haxe.data.collections.List"><c path="toList.T"/></c>
</f></toList>
		<toSet public="1" params="T" set="method" line="1126" static="1"><f a="i">
	<t path="Iterable"><c path="toSet.T"/></t>
	<c path="haxe.data.collections.Set"><c path="toSet.T"/></c>
</f></toSet>
		<toMap public="1" params="K:V" set="method" line="1130" static="1"><f a="i">
	<t path="Iterable"><c path="Tuple2">
	<c path="toMap.K"/>
	<c path="toMap.V"/>
</c></t>
	<c path="haxe.data.collections.Map">
		<c path="toMap.K"/>
		<c path="toMap.V"/>
	</c>
</f></toMap>
		<toArray public="1" params="T" set="method" line="1134" static="1"><f a="i">
	<t path="Iterable"><c path="toArray.T"/></t>
	<c path="Array"><c path="toArray.T"/></c>
</f></toArray>
	</class>
	<class path="JValueExtensions" params="" file="../src/main/haxe/PreludeExtensions.hx" module="PreludeExtensions">
		<decompose public="1" set="method" line="1142" static="1"><f a="v">
	<e path="haxe.text.json.JValue"/>
	<e path="haxe.text.json.JValue"/>
</f></decompose>
		<extract public="1" set="method" line="1145" static="1"><f a="c:v">
	<c path="Enum"><e path="haxe.text.json.JValue"/></c>
	<e path="haxe.text.json.JValue"/>
	<e path="haxe.text.json.JValue"/>
</f></extract>
	</class>
	<class path="IntHash" params="T" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/IntHash.hx">
		<h><d/></h>
		<set public="1" get="inline" set="null" line="34">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="42">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" get="inline" set="null" line="46">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="50">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="56">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="62">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.
</haxe_doc>
	</class>
	<typedef path="haxe.io.log.LogHandler" params="" file="../src/main/haxe/haxe/io/log/Logger.hx" module="haxe.io.log.Logger"><f a="::">
	<e path="haxe.io.log.LogLevel"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></typedef>
	<class path="haxe.io.log.LoggerFacade" params="" file="../src/main/haxe/haxe/io/log/Logger.hx" module="haxe.io.log.Logger" interface="1">
		<trace public="1" params="T" set="method"><f a="t:?p">
	<c path="trace.T"/>
	<t path="haxe.PosInfos"/>
	<c path="trace.T"/>
</f></trace>
		<debug public="1" set="method"><f a="s:?p">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></debug>
		<info public="1" set="method"><f a="s:?p">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></info>
		<warning public="1" set="method"><f a="s:?p">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></warning>
		<error public="1" set="method"><f a="s:?p">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></error>
		<fatal public="1" set="method"><f a="s:?p">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></fatal>
	</class>
	<enum path="haxe.io.log.LogLevel" params="" file="../src/main/haxe/haxe/io/log/Logger.hx" module="haxe.io.log.Logger">
		<Warning/>
		<None/>
		<Info/>
		<Fatal/>
		<Error/>
		<Debug/>
		<All/>
	</enum>
	<class path="haxe.io.log.Logger" params="" file="../src/main/haxe/haxe/io/log/Logger.hx">
		<defaultHandlers public="1" line="40" static="1">
			<c path="Array"><t path="haxe.io.log.LogHandler"/></c>
			<haxe_doc> The default handlers used for all loggers created using get() </haxe_doc>
		</defaultHandlers>
		<defaultLevel public="1" line="43" static="1">
			<e path="haxe.io.log.LogLevel"/>
			<haxe_doc> The default filtering level for all loggers created using get() </haxe_doc>
		</defaultLevel>
		<get public="1" set="method" line="50" static="1">
			<f a=""><c path="haxe.io.log.LoggerFacade"/></f>
			<haxe_doc> Convenience function that constructs a logger whose handlers are formed
   * from the 'defaultHandlers' field of this class, and whose messages are
   * filtered to include only those messages logged at the level of the
   * 'defaultLevel' field of this class, or higher.
   </haxe_doc>
		</get>
		<create public="1" set="method" line="60" static="1">
			<f a="config">
				<a>
					<level><t path="Thunk"><e path="haxe.io.log.LogLevel"/></t></level>
					<handlers><c path="Array"><t path="haxe.io.log.LogHandler"/></c></handlers>
				</a>
				<c path="haxe.io.log.LoggerFacade"/>
			</f>
			<haxe_doc> Convenience function that constructs a logger with the specified handlers
   * and log message cutoff level.
   </haxe_doc>
		</create>
		<none public="1" set="method" line="67" static="1">
			<f a=""><c path="haxe.io.log.LoggerFacade"/></f>
			<haxe_doc> Convenience function that constructs a logger that will not log anything
   * to anywhere (useful for production code).
   </haxe_doc>
		</none>
		<debug public="1" set="method" line="78" static="1">
			<f a=""><c path="haxe.io.log.LoggerFacade"/></f>
			<haxe_doc> Convenience function that creates a debug logger facade that sends information
   * to the browser console on JavaScript and Flash, and uses HaXe's trace method
   * otherwise.
   </haxe_doc>
		</debug>
	</class>
	<class path="haxe.io.log.LoggerBridge" params="" file="../src/main/haxe/haxe/io/log/Logger.hx" module="haxe.io.log.Logger">
		<implements path="haxe.io.log.LoggerFacade"/>
		<_handler><t path="haxe.io.log.LogHandler"/></_handler>
		<trace public="1" params="T" set="method" line="100"><f a="t:?p">
	<c path="trace.T"/>
	<t path="haxe.PosInfos"/>
	<c path="trace.T"/>
</f></trace>
		<debug public="1" set="method" line="102"><f a="s:?p">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></debug>
		<info public="1" set="method" line="104"><f a="s:?p">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></info>
		<warning public="1" set="method" line="106"><f a="s:?p">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></warning>
		<error public="1" set="method" line="108"><f a="s:?p">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></error>
		<fatal public="1" set="method" line="110"><f a="s:?p">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></fatal>
		<new public="1" set="method" line="96"><f a="h">
	<t path="haxe.io.log.LogHandler"/>
	<e path="Void"/>
</f></new>
		<haxe_doc> Converts all the facade methods to log handler invocations </haxe_doc>
	</class>
	<class path="haxe.io.log.LogHandlers" params="" file="../src/main/haxe/haxe/io/log/Logger.hx" module="haxe.io.log.Logger">
		<Trace public="1" line="115" static="1"><f a="level:text:p">
	<e path="haxe.io.log.LogLevel"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></Trace>
		<composite public="1" set="method" line="150" static="1"><f a="fns">
	<c path="Array"><t path="haxe.io.log.LogHandler"/></c>
	<t path="haxe.io.log.LogHandler"/>
</f></composite>
		<filter public="1" set="method" line="156" static="1"><f a="input:cutoff">
	<t path="haxe.io.log.LogHandler"/>
	<t path="Thunk"><e path="haxe.io.log.LogLevel"/></t>
	<t path="haxe.io.log.LogHandler"/>
</f></filter>
		<format set="method" line="164" static="1"><f a="text:p">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<c path="String"/>
</f></format>
		<textLevel set="method" line="168" static="1"><f a="level">
	<e path="haxe.io.log.LogLevel"/>
	<c path="String"/>
</f></textLevel>
		<intLevel set="method" line="180" static="1"><f a="level">
	<e path="haxe.io.log.LogLevel"/>
	<c path="Int"/>
</f></intLevel>
		<haxe_doc> Standard log handlers </haxe_doc>
	</class>
	<enum path="haxe.test.Assertation" params="" file="../src/main/haxe/haxe/test/Assertation.hx">
		<Warning a="msg">
			<c path="String"/>
			<haxe_doc>
  * A warning state. This can be declared explicitely by an Assert call
  * or can denote a test method that contains no assertions at all.
  * @param msg: The reason behind the warning
  </haxe_doc>
		</Warning>
		<TimeoutError a="missedAsyncs:stack">
			<c path="Int"/>
			<c path="Array"><e path="haxe.StackItem"/></c>
			<haxe_doc>
  * The asynchronous phase of a test has gone into timeout.
  * @param missedAsyncs: The number of asynchronous calls that was expected
  * to be performed before the timeout.
  </haxe_doc>
		</TimeoutError>
		<TeardownError a="e:stack">
			<d/>
			<c path="Array"><e path="haxe.StackItem"/></c>
			<haxe_doc>
  * An error has occurred during the Teardown phase of the test.
  * @param e: The captured error/exception
  </haxe_doc>
		</TeardownError>
		<Success a="pos">
			<t path="haxe.PosInfos"/>
			<haxe_doc>
  * Assertion is succesful
  * @param pos: Code position where the Assert call has been executed
  </haxe_doc>
		</Success>
		<SetupError a="e:stack">
			<d/>
			<c path="Array"><e path="haxe.StackItem"/></c>
			<haxe_doc>
  * An error has occurred during the Setup phase of the test. It prevents
  * the test to be run.
  * @param e: The captured error/exception
  </haxe_doc>
		</SetupError>
		<Failure a="msg:pos">
			<c path="String"/>
			<t path="haxe.PosInfos"/>
			<haxe_doc>
  * Assertion is a falure. This does not denote an error in the assertion
  * code but that the testing condition has failed for some reason.
  * Ei.: Assert.isTrue(1 == 0);
  * @param msg: An error message containing the reasons for the failure.
  * @param pos: Code position where the Assert call has been executed
  </haxe_doc>
		</Failure>
		<Error a="e:stack">
			<d/>
			<c path="Array"><e path="haxe.StackItem"/></c>
			<haxe_doc>
  * An error has occurred during the execution of the test that prevents
  * futher assertion to be tested.
  * @param e: The captured error/exception
  </haxe_doc>
		</Error>
		<AsyncError a="e:stack">
			<d/>
			<c path="Array"><e path="haxe.StackItem"/></c>
			<haxe_doc>
  * An error has occurred during an asynchronous test.
  * @param e: The captured error/exception
  </haxe_doc>
		</AsyncError>
		<haxe_doc>
* Enumerates the states available as a result of
* invoking one of the static methods of @see {@link utest.Assert}.
</haxe_doc>
	</enum>
	<enum path="Unit" params="" file="../src/main/haxe/Prelude.hx" module="Prelude"><Unit/></enum>
	<typedef path="AnyRef" params="" file="../src/main/haxe/Prelude.hx" module="Prelude"><a/></typedef>
	<typedef path="CodeBlock" params="" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a=""><e path="Void"/></f></typedef>
	<typedef path="Function" params="P1:R" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a="">
	<c path="Function.P1"/>
	<c path="Function.R"/>
</f></typedef>
	<typedef path="Function0" params="R" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a=""><c path="Function0.R"/></f></typedef>
	<typedef path="Function1" params="P1:R" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a="">
	<c path="Function1.P1"/>
	<c path="Function1.R"/>
</f></typedef>
	<typedef path="Function2" params="P1:P2:R" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a=":">
	<c path="Function2.P1"/>
	<c path="Function2.P2"/>
	<c path="Function2.R"/>
</f></typedef>
	<typedef path="Function3" params="P1:P2:P3:R" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a="::">
	<c path="Function3.P1"/>
	<c path="Function3.P2"/>
	<c path="Function3.P3"/>
	<c path="Function3.R"/>
</f></typedef>
	<typedef path="Function4" params="P1:P2:P3:P4:R" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a=":::">
	<c path="Function4.P1"/>
	<c path="Function4.P2"/>
	<c path="Function4.P3"/>
	<c path="Function4.P4"/>
	<c path="Function4.R"/>
</f></typedef>
	<typedef path="Function5" params="P1:P2:P3:P4:P5:R" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a="::::">
	<c path="Function5.P1"/>
	<c path="Function5.P2"/>
	<c path="Function5.P3"/>
	<c path="Function5.P4"/>
	<c path="Function5.P5"/>
	<c path="Function5.R"/>
</f></typedef>
	<typedef path="Function6" params="P1:P2:P3:P4:P5:P6:R" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a=":::::">
	<c path="Function6.P1"/>
	<c path="Function6.P2"/>
	<c path="Function6.P3"/>
	<c path="Function6.P4"/>
	<c path="Function6.P5"/>
	<c path="Function6.P6"/>
	<c path="Function6.R"/>
</f></typedef>
	<typedef path="Function7" params="P1:P2:P3:P4:P5:P6:P7:R" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a="::::::">
	<c path="Function7.P1"/>
	<c path="Function7.P2"/>
	<c path="Function7.P3"/>
	<c path="Function7.P4"/>
	<c path="Function7.P5"/>
	<c path="Function7.P6"/>
	<c path="Function7.P7"/>
	<c path="Function7.R"/>
</f></typedef>
	<typedef path="Function8" params="P1:P2:P3:P4:P5:P6:P7:P8:R" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a=":::::::">
	<c path="Function8.P1"/>
	<c path="Function8.P2"/>
	<c path="Function8.P3"/>
	<c path="Function8.P4"/>
	<c path="Function8.P5"/>
	<c path="Function8.P6"/>
	<c path="Function8.P7"/>
	<c path="Function8.P8"/>
	<c path="Function8.R"/>
</f></typedef>
	<typedef path="Function9" params="P1:P2:P3:P4:P5:P6:P7:P8:P9:R" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a="::::::::">
	<c path="Function9.P1"/>
	<c path="Function9.P2"/>
	<c path="Function9.P3"/>
	<c path="Function9.P4"/>
	<c path="Function9.P5"/>
	<c path="Function9.P6"/>
	<c path="Function9.P7"/>
	<c path="Function9.P8"/>
	<c path="Function9.P9"/>
	<c path="Function9.R"/>
</f></typedef>
	<typedef path="Function10" params="P1:P2:P3:P4:P5:P6:P7:P8:P9:P10:R" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a=":::::::::">
	<c path="Function10.P1"/>
	<c path="Function10.P2"/>
	<c path="Function10.P3"/>
	<c path="Function10.P4"/>
	<c path="Function10.P5"/>
	<c path="Function10.P6"/>
	<c path="Function10.P7"/>
	<c path="Function10.P8"/>
	<c path="Function10.P9"/>
	<c path="Function10.P10"/>
	<c path="Function10.R"/>
</f></typedef>
	<typedef path="Reducer" params="T" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a=":">
	<c path="Reducer.T"/>
	<c path="Reducer.T"/>
	<c path="Reducer.T"/>
</f></typedef>
	<typedef path="Factory" params="T" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a=""><c path="Factory.T"/></f></typedef>
	<typedef path="Thunk" params="T" file="../src/main/haxe/Prelude.hx" module="Prelude"><f a=""><c path="Thunk.T"/></f></typedef>
	<enum path="Option" params="T" file="../src/main/haxe/Prelude.hx" module="Prelude">
		<Some a="v"><c path="Option.T"/></Some>
		<None/>
		<haxe_doc> An option represents an optional value -- the value may or may not be
 * present. Option is a much safer alternative to null that often enables
 * reduction in code size and increase in code clarity.
 </haxe_doc>
	</enum>
	<enum path="Either" params="A:B" file="../src/main/haxe/Prelude.hx" module="Prelude">
		<Right a="v"><c path="Either.B"/></Right>
		<Left a="v"><c path="Either.A"/></Left>
		<haxe_doc> Either represents a type that is either a "left" value or a "right" value,
 * but not both. Either is often used to represent success/failure, where the
 * left side represents failure, and the right side represents success.
 </haxe_doc>
	</enum>
	<typedef path="FailureOrSuccess" params="A:B" file="../src/main/haxe/Prelude.hx" module="Prelude"><e path="Either">
	<c path="FailureOrSuccess.A"/>
	<c path="FailureOrSuccess.B"/>
</e></typedef>
	<class path="Future" params="T" file="../src/main/haxe/Prelude.hx" module="Prelude">
		<dead public="1" params="T" set="method" line="98" static="1">
			<f a=""><c path="Future"><c path="dead.T"/></c></f>
			<haxe_doc> Creates a "dead" future that is canceled and will never be delivered.
   </haxe_doc>
		</dead>
		<create public="1" params="T" set="method" line="319" static="1"><f a=""><c path="Future"><c path="create.T"/></c></f></create>
		<_listeners><c path="Array"><f a="">
	<c path="Future.T"/>
	<e path="Void"/>
</f></c></_listeners>
		<_result><c path="Future.T"/></_result>
		<_isSet><e path="Bool"/></_isSet>
		<_isCanceled><e path="Bool"/></_isCanceled>
		<_cancelers><c path="Array"><f a=""><e path="Bool"/></f></c></_cancelers>
		<_canceled><c path="Array"><f a=""><e path="Void"/></f></c></_canceled>
		<deliver public="1" set="method" line="107">
			<f a="t">
				<c path="Future.T"/>
				<c path="Future"><c path="Future.T"/></c>
			</f>
			<haxe_doc> Delivers the value of the future to anyone awaiting it. If the value has
   * already been delivered, this method will throw an exception.
   </haxe_doc>
		</deliver>
		<allowCancelOnlyIf public="1" set="method" line="129">
			<f a="f">
				<f a=""><e path="Bool"/></f>
				<c path="Future"><c path="Future.T"/></c>
			</f>
			<haxe_doc><![CDATA[ Installs the specified canceler on the future. Under ordinary
   * circumstances, the future will not be canceled unless all cancelers
   * return true. If the future is already done, this method has no effect.
   * <p>
   * This method does not normally need to be called. It's provided primarily
   * for the implementation of future primitives.
   ]]></haxe_doc>
		</allowCancelOnlyIf>
		<ifCanceled public="1" set="method" line="144">
			<f a="f">
				<f a=""><e path="Void"/></f>
				<c path="Future"><c path="Future.T"/></c>
			</f>
			<haxe_doc><![CDATA[ Installs a handler that will be called if and only if the future is
   * canceled.
   * <p>
   * This method does not normally need to be called, since there is no
   * difference between a future being canceled and a future taking an
   * arbitrarily long amount of time to evaluate. It's provided primarily
   * for implementation of future primitives to save resources when it's
   * explicitly known the result of a future will not be used.
   ]]></haxe_doc>
		</ifCanceled>
		<cancel public="1" set="method" line="158">
			<f a=""><e path="Bool"/></f>
			<haxe_doc><![CDATA[ Attempts to cancel the future. This may succeed only if the future is
   * not already delivered, and if all cancel conditions are satisfied.
   * <p>
   * If a future is canceled, the result will never be delivered.
   *
   * @return true if the future is canceled, false otherwise.
   ]]></haxe_doc>
		</cancel>
		<isDone public="1" set="method" line="177">
			<f a=""><e path="Bool"/></f>
			<haxe_doc> Determines if the future is "done" -- that is, delivered or canceled.
   </haxe_doc>
		</isDone>
		<isDelivered public="1" set="method" line="183">
			<f a=""><e path="Bool"/></f>
			<haxe_doc> Determines if the future is delivered.
   </haxe_doc>
		</isDelivered>
		<isCanceled public="1" set="method" line="189">
			<f a=""><e path="Bool"/></f>
			<haxe_doc> Determines if the future is canceled.
   </haxe_doc>
		</isCanceled>
		<deliverTo public="1" set="method" line="196">
			<f a="f">
				<f a="">
					<c path="Future.T"/>
					<e path="Void"/>
				</f>
				<c path="Future"><c path="Future.T"/></c>
			</f>
			<haxe_doc> Delivers the result of the future to the specified handler as soon as it
   * is delivered.
   </haxe_doc>
		</deliverTo>
		<map public="1" params="S" set="method" line="209">
			<f a="f">
				<f a="">
					<c path="Future.T"/>
					<c path="map.S"/>
				</f>
				<c path="Future"><c path="map.S"/></c>
			</f>
			<haxe_doc><![CDATA[ Uses the specified function to transform the result of this future into
   * a different value, returning a future of that value.
   * <p>
   * urlLoader.load("image.png").map(function(data) return new Image(data)).deliverTo(function(image) imageContainer.add(image));
   ]]></haxe_doc>
		</map>
		<then public="1" params="S" set="method" line="218"><f a="f">
	<c path="Future"><c path="then.S"/></c>
	<c path="Future"><c path="then.S"/></c>
</f></then>
		<flatMap public="1" params="S" set="method" line="236">
			<f a="f">
				<f a="">
					<c path="Future.T"/>
					<c path="Future"><c path="flatMap.S"/></c>
				</f>
				<c path="Future"><c path="flatMap.S"/></c>
			</f>
			<haxe_doc><![CDATA[ Maps the result of this future to another future, and returns a future
   * of the result of that future. Useful when chaining together multiple
   * asynchronous operations that must be completed sequentially.
   * <p>
   * <pre>
   * <code>
   * urlLoader.load("config.xml").flatMap(function(xml){
   *   return urlLoader.load(parse(xml).mediaUrl);
   * }).deliverTo(function(loadedMedia){
   *   container.add(loadedMedia);
   * });
   * </code>
   * </pre>
   ]]></haxe_doc>
		</flatMap>
		<filter public="1" set="method" line="256">
			<f a="f">
				<f a="">
					<c path="Future.T"/>
					<e path="Bool"/>
				</f>
				<c path="Future"><c path="Future.T"/></c>
			</f>
			<haxe_doc> Returns a new future that will be delivered only if the result of this
   * future is accepted by the specified filter (otherwise, the new future
   * will be canceled).
   </haxe_doc>
		</filter>
		<zip public="1" params="A" set="method" line="271">
			<f a="f2">
				<c path="Future"><c path="zip.A"/></c>
				<c path="Future"><c path="Tuple2">
	<c path="Future.T"/>
	<c path="zip.A"/>
</c></c>
			</f>
			<haxe_doc> Zips this future and the specified future into another future, whose
   * result is a tuple of the individual results of the futures. Useful when
   * an operation requires the result of two futures, but each future may
   * execute independently of the other.
   </haxe_doc>
		</zip>
		<value public="1" set="method" line="297">
			<f a=""><e path="Option"><c path="Future.T"/></e></f>
			<haxe_doc> Retrieves the value of the future, as an option.
   </haxe_doc>
		</value>
		<toOption public="1" set="method" line="301"><f a=""><e path="Option"><c path="Future.T"/></e></f></toOption>
		<toArray public="1" set="method" line="305"><f a=""><c path="Array"><c path="Future.T"/></c></f></toArray>
		<forceCancel set="method" line="309"><f a=""><c path="Future"><c path="Future.T"/></c></f></forceCancel>
		<new public="1" set="method" line="87"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[
 * An asynchronous operation that may complete in the future unless
 * successfully canceled.
 * <p>
 * Futures can be combined and chained together to form complicated
 * asynchronous control flows. Often used operations are map() and
 * flatMap().
 * <p>
 ]]></haxe_doc>
	</class>
	<class path="Product" params="" file="../src/main/haxe/Prelude.hx" module="Prelude" interface="1">
		<productPrefix public="1" get="getProductPrefix" set="null"><c path="String"/></productPrefix>
		<productArity public="1" get="getProductArity" set="null"><c path="Int"/></productArity>
		<productElement public="1" set="method"><f a="n">
	<c path="Int"/>
	<d/>
</f></productElement>
	</class>
	<class path="_Prelude.AbstractProduct" params="" file="../src/main/haxe/Prelude.hx" private="1" module="Prelude">
		<implements path="Product"/>
		<_baseHashes line="355" static="1"><c path="Array"><c path="Array"><c path="Int"/></c></c></_baseHashes>
		<productPrefix public="1" get="getProductPrefix" set="null"><c path="String"/></productPrefix>
		<productArity public="1" get="getProductArity" set="null"><c path="Int"/></productArity>
		<_productElements><c path="Array"><d/></c></_productElements>
		<productElement public="1" set="method" line="344"><f a="n">
	<c path="Int"/>
	<d/>
</f></productElement>
		<toString public="1" set="method" line="348"><f a=""><c path="String"/></f></toString>
		<hashCode public="1" set="method" line="361"><f a=""><c path="Int"/></f></hashCode>
		<productCompare set="method" line="368"><f a="other">
	<c path="_Prelude.AbstractProduct"/>
	<c path="Int"/>
</f></productCompare>
		<productDecompose set="method" line="377"><f a=""><e path="haxe.text.json.JValue"/></f></productDecompose>
		<productEquals set="method" line="381"><f a="other">
	<c path="_Prelude.AbstractProduct"/>
	<e path="Bool"/>
</f></productEquals>
		<getProductPrefix set="method" line="388"><f a=""><c path="String"/></f></getProductPrefix>
		<getProductArity set="method" line="392"><f a=""><c path="Int"/></f></getProductArity>
		<_orders><c path="Array"><t path="OrderFunction"><d/></t></c></_orders>
		<_equals><c path="Array"><t path="EqualFunction"><d/></t></c></_equals>
		<_hashes><c path="Array"><t path="HashFunction"><d/></t></c></_hashes>
		<_shows><c path="Array"><t path="ShowFunction"><d/></t></c></_shows>
		<getOrder set="method" line="400"><f a="i">
	<c path="Int"/>
	<t path="OrderFunction"><d/></t>
</f></getOrder>
		<getEqual set="method" line="407"><f a="i">
	<c path="Int"/>
	<t path="EqualFunction"><d/></t>
</f></getEqual>
		<getHash set="method" line="414"><f a="i">
	<c path="Int"/>
	<t path="HashFunction"><d/></t>
</f></getHash>
		<getShow set="method" line="421"><f a="i">
	<c path="Int"/>
	<t path="ShowFunction"><d/></t>
</f></getShow>
		<new public="1" set="method" line="339"><f a="elements">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Tuple2" params="A:B" file="../src/main/haxe/Prelude.hx" module="Prelude">
		<extends path="_Prelude.AbstractProduct"/>
		<create public="1" params="A:B" set="method" line="459" static="1"><f a="a:b">
	<c path="create.A"/>
	<c path="create.B"/>
	<c path="Tuple2">
		<c path="create.A"/>
		<c path="create.B"/>
	</c>
</f></create>
		<extract public="1" params="A:B" set="method" line="465" static="1"><f a="v:e1:e2">
	<e path="haxe.text.json.JValue"/>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.A"/></t>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.B"/></t>
	<c path="Tuple2">
		<c path="extract.A"/>
		<c path="extract.B"/>
	</c>
</f></extract>
		<_1 public="1" set="null"><c path="Tuple2.A"/></_1>
		<_2 public="1" set="null"><c path="Tuple2.B"/></_2>
		<getProductPrefix set="method" line="439" override="1"><f a=""><c path="String"/></f></getProductPrefix>
		<getProductArity set="method" line="443" override="1"><f a=""><c path="Int"/></f></getProductArity>
		<entuple public="1" params="C" set="method" line="447"><f a="c">
	<c path="entuple.C"/>
	<c path="Tuple3">
		<c path="Tuple2.A"/>
		<c path="Tuple2.B"/>
		<c path="entuple.C"/>
	</c>
</f></entuple>
		<compare public="1" set="method" line="451"><f a="other">
	<c path="Tuple2">
		<c path="Tuple2.A"/>
		<c path="Tuple2.B"/>
	</c>
	<c path="Int"/>
</f></compare>
		<equals public="1" set="method" line="455"><f a="other">
	<c path="Tuple2">
		<c path="Tuple2.A"/>
		<c path="Tuple2.B"/>
	</c>
	<e path="Bool"/>
</f></equals>
		<decompose public="1" set="method" line="462"><f a=""><e path="haxe.text.json.JValue"/></f></decompose>
		<new set="method" line="433"><f a="first:second">
	<c path="Tuple2.A"/>
	<c path="Tuple2.B"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Tuple3" params="A:B:C" file="../src/main/haxe/Prelude.hx" module="Prelude">
		<extends path="_Prelude.AbstractProduct"/>
		<create public="1" params="A:B:C" set="method" line="505" static="1"><f a="a:b:c">
	<c path="create.A"/>
	<c path="create.B"/>
	<c path="create.C"/>
	<c path="Tuple3">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.C"/>
	</c>
</f></create>
		<extract public="1" params="A:B:C" set="method" line="511" static="1"><f a="v:e1:e2:e3">
	<e path="haxe.text.json.JValue"/>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.A"/></t>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.B"/></t>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.C"/></t>
	<c path="Tuple3">
		<c path="extract.A"/>
		<c path="extract.B"/>
		<c path="extract.C"/>
	</c>
</f></extract>
		<_1 public="1" set="null"><c path="Tuple3.A"/></_1>
		<_2 public="1" set="null"><c path="Tuple3.B"/></_2>
		<_3 public="1" set="null"><c path="Tuple3.C"/></_3>
		<getProductPrefix set="method" line="485" override="1"><f a=""><c path="String"/></f></getProductPrefix>
		<getProductArity set="method" line="489" override="1"><f a=""><c path="Int"/></f></getProductArity>
		<entuple public="1" params="D" set="method" line="493"><f a="d">
	<c path="entuple.D"/>
	<c path="Tuple4">
		<c path="Tuple3.A"/>
		<c path="Tuple3.B"/>
		<c path="Tuple3.C"/>
		<c path="entuple.D"/>
	</c>
</f></entuple>
		<compare public="1" set="method" line="497"><f a="other">
	<c path="Tuple3">
		<c path="Tuple3.A"/>
		<c path="Tuple3.B"/>
		<c path="Tuple3.C"/>
	</c>
	<c path="Int"/>
</f></compare>
		<equals public="1" set="method" line="501"><f a="other">
	<c path="Tuple3">
		<c path="Tuple3.A"/>
		<c path="Tuple3.B"/>
		<c path="Tuple3.C"/>
	</c>
	<e path="Bool"/>
</f></equals>
		<decompose public="1" set="method" line="508"><f a=""><e path="haxe.text.json.JValue"/></f></decompose>
		<new set="method" line="479"><f a="first:second:third">
	<c path="Tuple3.A"/>
	<c path="Tuple3.B"/>
	<c path="Tuple3.C"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Tuple4" params="A:B:C:D" file="../src/main/haxe/Prelude.hx" module="Prelude">
		<extends path="_Prelude.AbstractProduct"/>
		<create public="1" params="A:B:C:D" set="method" line="552" static="1"><f a="a:b:c:d">
	<c path="create.A"/>
	<c path="create.B"/>
	<c path="create.C"/>
	<c path="create.D"/>
	<c path="Tuple4">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.C"/>
		<c path="create.D"/>
	</c>
</f></create>
		<extract public="1" params="A:B:C:D" set="method" line="558" static="1"><f a="v:e1:e2:e3:e4">
	<e path="haxe.text.json.JValue"/>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.A"/></t>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.B"/></t>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.C"/></t>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.D"/></t>
	<c path="Tuple4">
		<c path="extract.A"/>
		<c path="extract.B"/>
		<c path="extract.C"/>
		<c path="extract.D"/>
	</c>
</f></extract>
		<_1 public="1" set="null"><c path="Tuple4.A"/></_1>
		<_2 public="1" set="null"><c path="Tuple4.B"/></_2>
		<_3 public="1" set="null"><c path="Tuple4.C"/></_3>
		<_4 public="1" set="null"><c path="Tuple4.D"/></_4>
		<getProductPrefix set="method" line="532" override="1"><f a=""><c path="String"/></f></getProductPrefix>
		<getProductArity set="method" line="536" override="1"><f a=""><c path="Int"/></f></getProductArity>
		<entuple public="1" params="E" set="method" line="540"><f a="e">
	<c path="entuple.E"/>
	<c path="Tuple5">
		<c path="Tuple4.A"/>
		<c path="Tuple4.B"/>
		<c path="Tuple4.C"/>
		<c path="Tuple4.D"/>
		<c path="entuple.E"/>
	</c>
</f></entuple>
		<compare public="1" set="method" line="544"><f a="other">
	<c path="Tuple4">
		<c path="Tuple4.A"/>
		<c path="Tuple4.B"/>
		<c path="Tuple4.C"/>
		<c path="Tuple4.D"/>
	</c>
	<c path="Int"/>
</f></compare>
		<equals public="1" set="method" line="548"><f a="other">
	<c path="Tuple4">
		<c path="Tuple4.A"/>
		<c path="Tuple4.B"/>
		<c path="Tuple4.C"/>
		<c path="Tuple4.D"/>
	</c>
	<e path="Bool"/>
</f></equals>
		<decompose public="1" set="method" line="555"><f a=""><e path="haxe.text.json.JValue"/></f></decompose>
		<new set="method" line="526"><f a="first:second:third:fourth">
	<c path="Tuple4.A"/>
	<c path="Tuple4.B"/>
	<c path="Tuple4.C"/>
	<c path="Tuple4.D"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Tuple5" params="A:B:C:D:E" file="../src/main/haxe/Prelude.hx" module="Prelude">
		<extends path="_Prelude.AbstractProduct"/>
		<create public="1" params="A:B:C:D:E" set="method" line="596" static="1"><f a="a:b:c:d:e">
	<c path="create.A"/>
	<c path="create.B"/>
	<c path="create.C"/>
	<c path="create.D"/>
	<c path="create.E"/>
	<c path="Tuple5">
		<c path="create.A"/>
		<c path="create.B"/>
		<c path="create.C"/>
		<c path="create.D"/>
		<c path="create.E"/>
	</c>
</f></create>
		<extract public="1" params="A:B:C:D:E" set="method" line="602" static="1"><f a="v:e1:e2:e3:e4:e5">
	<e path="haxe.text.json.JValue"/>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.A"/></t>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.B"/></t>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.C"/></t>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.D"/></t>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.E"/></t>
	<c path="Tuple5">
		<c path="extract.A"/>
		<c path="extract.B"/>
		<c path="extract.C"/>
		<c path="extract.D"/>
		<c path="extract.E"/>
	</c>
</f></extract>
		<_1 public="1" set="null"><c path="Tuple5.A"/></_1>
		<_2 public="1" set="null"><c path="Tuple5.B"/></_2>
		<_3 public="1" set="null"><c path="Tuple5.C"/></_3>
		<_4 public="1" set="null"><c path="Tuple5.D"/></_4>
		<_5 public="1" set="null"><c path="Tuple5.E"/></_5>
		<getProductPrefix set="method" line="580" override="1"><f a=""><c path="String"/></f></getProductPrefix>
		<getProductArity set="method" line="584" override="1"><f a=""><c path="Int"/></f></getProductArity>
		<compare public="1" set="method" line="588"><f a="other">
	<c path="Tuple5">
		<c path="Tuple5.A"/>
		<c path="Tuple5.B"/>
		<c path="Tuple5.C"/>
		<c path="Tuple5.D"/>
		<c path="Tuple5.E"/>
	</c>
	<c path="Int"/>
</f></compare>
		<equals public="1" set="method" line="592"><f a="other">
	<c path="Tuple5">
		<c path="Tuple5.A"/>
		<c path="Tuple5.B"/>
		<c path="Tuple5.C"/>
		<c path="Tuple5.D"/>
		<c path="Tuple5.E"/>
	</c>
	<e path="Bool"/>
</f></equals>
		<decompose public="1" set="method" line="599"><f a=""><e path="haxe.text.json.JValue"/></f></decompose>
		<new set="method" line="574"><f a="first:second:third:fourth:fifth">
	<c path="Tuple5.A"/>
	<c path="Tuple5.B"/>
	<c path="Tuple5.C"/>
	<c path="Tuple5.D"/>
	<c path="Tuple5.E"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="OrderFunction" params="T" file="../src/main/haxe/Prelude.hx" module="Prelude"><t path="Function2">
	<c path="OrderFunction.T"/>
	<c path="OrderFunction.T"/>
	<c path="Int"/>
</t></typedef>
	<typedef path="EqualFunction" params="T" file="../src/main/haxe/Prelude.hx" module="Prelude"><t path="Function2">
	<c path="EqualFunction.T"/>
	<c path="EqualFunction.T"/>
	<e path="Bool"/>
</t></typedef>
	<typedef path="ShowFunction" params="T" file="../src/main/haxe/Prelude.hx" module="Prelude"><t path="Function">
	<c path="ShowFunction.T"/>
	<c path="String"/>
</t></typedef>
	<typedef path="HashFunction" params="T" file="../src/main/haxe/Prelude.hx" module="Prelude"><t path="Function">
	<c path="HashFunction.T"/>
	<c path="Int"/>
</t></typedef>
	<class path="FieldOrder" params="" file="../src/main/haxe/Prelude.hx" module="Prelude">
		<Ascending public="1" get="inline" set="null" line="617" static="1"><c path="Int"/></Ascending>
		<Descending public="1" get="inline" set="null" line="618" static="1"><c path="Int"/></Descending>
		<Ignore public="1" get="inline" set="null" line="619" static="1"><c path="Int"/></Ignore>
	</class>
	<class path="Stax" params="" file="../src/main/haxe/Prelude.hx" module="Prelude">
		<_createOrderImpl params="T" set="method" line="623" static="1"><f a="impl">
	<t path="OrderFunction"><d/></t>
	<t path="OrderFunction"><c path="_createOrderImpl.T"/></t>
</f></_createOrderImpl>
		<getOrderFor public="1" params="T" set="method" line="634" static="1">
			<f a="t">
				<c path="getOrderFor.T"/>
				<t path="OrderFunction"><c path="getOrderFor.T"/></t>
			</f>
			<haxe_doc><![CDATA[ Returns a OrderFunction (T -> T -> Int). It works for any type expect TFunction.
   *  Custom Classes must provide a compare(other : T) : Int method or an exception will be thrown.
   ]]></haxe_doc>
		</getOrderFor>
		<getOrderForType public="1" params="T" set="method" line="637" static="1"><f a="v">
	<e path="ValueType"/>
	<t path="OrderFunction"><c path="getOrderForType.T"/></t>
</f></getOrderForType>
		<_hasMetaDataClass set="method" line="716" static="1"><f a="c">
	<c path="Class"><d/></c>
	<e path="Bool"/>
</f></_hasMetaDataClass>
		<_getMetaDataField set="method" line="720" static="1"><f a="c:f">
	<c path="Class"><d/></c>
	<c path="String"/>
	<unknown/>
</f></_getMetaDataField>
		<_fieldsWithMeta set="method" line="729" static="1"><f a="c:name">
	<c path="Class"><d/></c>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></_fieldsWithMeta>
		<_createEqualImpl params="T" set="method" line="746" static="1"><f a="impl">
	<t path="EqualFunction"><d/></t>
	<f a="a:b">
		<c path="getEqualForType.T"/>
		<c path="getEqualForType.T"/>
		<e path="Bool"/>
	</f>
</f></_createEqualImpl>
		<getEqualFor public="1" params="T" set="method" line="756" static="1">
			<f a="t">
				<c path="getEqualFor.T"/>
				<t path="EqualFunction"><c path="getEqualFor.T"/></t>
			</f>
			<haxe_doc><![CDATA[ Returns an EqualFunction (T -> T -> Bool). It works for any type. Custom Classes must provide
   * an "equals(other : T) : Bool" method or a "compare(other : T) : Int" method otherwise an exception will be thrown.
   ]]></haxe_doc>
		</getEqualFor>
		<getEqualForType public="1" params="T" set="method" line="759" static="1"><f a="v">
	<e path="ValueType"/>
	<t path="EqualFunction"><c path="getEqualForType.T"/></t>
</f></getEqualForType>
		<_createShowImpl params="T" set="method" line="824" static="1"><f a="impl">
	<t path="ShowFunction"><d/></t>
	<t path="ShowFunction"><c path="_createShowImpl.T"/></t>
</f></_createShowImpl>
		<getShowFor public="1" params="T" set="method" line="831" static="1">
			<f a="t">
				<c path="getShowFor.T"/>
				<t path="ShowFunction"><c path="getShowFor.T"/></t>
			</f>
			<haxe_doc><![CDATA[ Returns a ShowFunction (T -> String). It works for any type. For Custom Classes you must provide a toString()
   * method, otherwise the full class name is returned.
   ]]></haxe_doc>
		</getShowFor>
		<getShowForType public="1" params="T" set="method" line="839" static="1">
			<f a="v">
				<e path="ValueType"/>
				<t path="ShowFunction"><c path="getShowForType.T"/></t>
			</f>
			<haxe_doc>
   *  @todo Reflect.fields doesn't work consistenly across platforms so we may probably pass to use Type.getInstanceFields. The problem here
   *  is that we must check if the fields are functions before grabbing the value.
   </haxe_doc>
		</getShowForType>
		<_createHashImpl params="T" set="method" line="897" static="1"><f a="impl">
	<t path="HashFunction"><d/></t>
	<f a="v">
		<c path="_createHashImpl.T"/>
		<c path="Int"/>
	</f>
</f></_createHashImpl>
		<getHashFor public="1" params="T" set="method" line="902" static="1"><f a="t">
	<c path="getHashFor.T"/>
	<t path="HashFunction"><c path="getHashFor.T"/></t>
</f></getHashFor>
		<getHashForType public="1" params="T" set="method" line="905" static="1"><f a="v">
	<e path="ValueType"/>
	<t path="HashFunction"><c path="getHashForType.T"/></t>
</f></getHashForType>
		<thunk public="1" set="method" line="959" static="1"><f a=""><e path="Void"/></f></thunk>
		<noop public="1" params="A" set="method" line="961" static="1"><f a=""><f a=""><e path="Void"/></f></f></noop>
		<noop1 public="1" params="A" set="method" line="964" static="1"><f a=""><f a="a">
	<c path="noop1.A"/>
	<e path="Void"/>
</f></f></noop1>
		<noop2 public="1" params="A:B" set="method" line="967" static="1"><f a=""><f a="a:b">
	<c path="noop2.A"/>
	<c path="noop2.B"/>
	<e path="Void"/>
</f></f></noop2>
		<noop3 public="1" params="A:B:C" set="method" line="970" static="1"><f a=""><f a="a:b:c">
	<c path="noop3.A"/>
	<c path="noop3.B"/>
	<c path="noop3.C"/>
	<e path="Void"/>
</f></f></noop3>
		<noop4 public="1" params="A:B:C:D" set="method" line="973" static="1"><f a=""><f a="a:b:c:d">
	<c path="noop4.A"/>
	<c path="noop4.B"/>
	<c path="noop4.C"/>
	<c path="noop4.D"/>
	<e path="Void"/>
</f></f></noop4>
		<noop5 public="1" params="A:B:C:D:E" set="method" line="976" static="1"><f a=""><f a="a:b:c:d:e">
	<c path="noop5.A"/>
	<c path="noop5.B"/>
	<c path="noop5.C"/>
	<c path="noop5.D"/>
	<c path="noop5.E"/>
	<e path="Void"/>
</f></f></noop5>
		<identity public="1" params="A" set="method" line="980" static="1"><f a=""><t path="Function">
	<c path="identity.A"/>
	<c path="identity.A"/>
</t></f></identity>
		<unfold public="1" params="T:R" set="method" line="984" static="1"><f a="initial:unfolder">
	<c path="unfold.T"/>
	<f a="">
		<c path="unfold.T"/>
		<e path="Option"><c path="Tuple2">
	<c path="unfold.T"/>
	<c path="unfold.R"/>
</c></e>
	</f>
	<t path="Iterable"><c path="unfold.R"/></t>
</f></unfold>
		<error public="1" params="T" set="method" line="1021" static="1"><f a="msg">
	<c path="String"/>
	<c path="error.T"/>
</f></error>
	</class>
	<class path="haxe.reactive.SignalFloat" params="" file="../src/main/haxe/haxe/reactive/SignalFloat.hx">
		<plus public="1" set="method" line="23" static="1"><f a="b:value">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="Float"/>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></plus>
		<plusS public="1" set="method" line="27" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></plusS>
		<minusS public="1" set="method" line="31" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></minusS>
		<minus public="1" set="method" line="35" static="1"><f a="b:value">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="Float"/>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></minus>
		<timesS public="1" set="method" line="39" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></timesS>
		<times public="1" set="method" line="43" static="1"><f a="b:value">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="Float"/>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></times>
		<dividedByS public="1" set="method" line="47" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></dividedByS>
		<dividedBy public="1" set="method" line="51" static="1"><f a="b:value">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="Float"/>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></dividedBy>
		<abs public="1" set="method" line="55" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></abs>
		<negate public="1" set="method" line="59" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></negate>
		<floor public="1" set="method" line="63" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></floor>
		<ceil public="1" set="method" line="67" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></ceil>
		<round public="1" set="method" line="71" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></round>
		<acos public="1" set="method" line="75" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></acos>
		<asin public="1" set="method" line="79" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></asin>
		<atan public="1" set="method" line="83" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></atan>
		<atan2B public="1" set="method" line="87" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></atan2B>
		<atan2 public="1" set="method" line="91" static="1"><f a="b:value">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="Float"/>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></atan2>
		<cos public="1" set="method" line="95" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></cos>
		<exp public="1" set="method" line="99" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></exp>
		<log public="1" set="method" line="103" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></log>
		<maxS public="1" set="method" line="107" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></maxS>
		<max public="1" set="method" line="111" static="1"><f a="b:value">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="Float"/>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></max>
		<minS public="1" set="method" line="115" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></minS>
		<min public="1" set="method" line="119" static="1"><f a="b:value">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="Float"/>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></min>
		<powS public="1" set="method" line="123" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></powS>
		<pow public="1" set="method" line="127" static="1"><f a="b:value">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="Float"/>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></pow>
		<sin public="1" set="method" line="131" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></sin>
		<sqrt public="1" set="method" line="135" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></sqrt>
		<tan public="1" set="method" line="139" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></tan>
		<new set="method" line="21"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.functional.Predicate1Extensions" params="" file="../src/main/haxe/haxe/functional/PredicateExtensions.hx" module="haxe.functional.PredicateExtensions">
		<and public="1" params="T" set="method" line="26" static="1"><f a="p1:p2">
	<t path="haxe.functional.Predicate"><c path="and.T"/></t>
	<t path="haxe.functional.Predicate"><c path="and.T"/></t>
	<t path="haxe.functional.Predicate"><c path="and.T"/></t>
</f></and>
		<andAll public="1" params="T" set="method" line="32" static="1"><f a="p1:ps">
	<t path="haxe.functional.Predicate"><c path="andAll.T"/></t>
	<t path="Iterable"><t path="haxe.functional.Predicate"><c path="andAll.T"/></t></t>
	<t path="haxe.functional.Predicate"><c path="andAll.T"/></t>
</f></andAll>
		<or public="1" params="T" set="method" line="46" static="1"><f a="p1:p2">
	<t path="haxe.functional.Predicate"><c path="or.T"/></t>
	<t path="haxe.functional.Predicate"><c path="or.T"/></t>
	<t path="haxe.functional.Predicate"><c path="or.T"/></t>
</f></or>
		<orAny public="1" params="T" set="method" line="52" static="1"><f a="p1:ps">
	<t path="haxe.functional.Predicate"><c path="orAny.T"/></t>
	<t path="Iterable"><t path="haxe.functional.Predicate"><c path="orAny.T"/></t></t>
	<t path="haxe.functional.Predicate"><c path="orAny.T"/></t>
</f></orAny>
		<negate public="1" params="T" set="method" line="66" static="1"><f a="p">
	<t path="haxe.functional.Predicate"><c path="negate.T"/></t>
	<t path="haxe.functional.Predicate"><c path="negate.T"/></t>
</f></negate>
	</class>
	<class path="haxe.test.MustMatcherExtensions" params="" file="../src/main/haxe/haxe/test/MustMatcherExtensions.hx">
		<negate public="1" params="T" set="method" line="25" static="1"><f a="c">
	<t path="haxe.test.MustMatcher"><c path="negate.T"/></t>
	<t path="haxe.test.MustMatcher"><c path="negate.T"/></t>
</f></negate>
		<or public="1" params="T" set="method" line="33" static="1"><f a="c1:c2">
	<t path="haxe.test.MustMatcher"><c path="or.T"/></t>
	<t path="haxe.test.MustMatcher"><c path="or.T"/></t>
	<t path="haxe.test.MustMatcher"><c path="or.T"/></t>
</f></or>
		<and public="1" params="T" set="method" line="46" static="1"><f a="c1:c2">
	<t path="haxe.test.MustMatcher"><c path="and.T"/></t>
	<t path="haxe.test.MustMatcher"><c path="and.T"/></t>
	<t path="haxe.test.MustMatcher"><c path="and.T"/></t>
</f></and>
	</class>
	<class path="haxe.io.http.HttpJValue" params="" file="../src/main/haxe/haxe/io/http/HttpJValue.hx" interface="1"><implements path="haxe.io.http.Http"><e path="haxe.text.json.JValue"/></implements></class>
	<typedef path="haxe.functional.Predicate" params="A" file="../src/main/haxe/haxe/functional/Predicate.hx"><t path="haxe.functional.Predicate1"><c path="haxe.functional.Predicate.A"/></t></typedef>
	<typedef path="haxe.functional.Predicate1" params="A" file="../src/main/haxe/haxe/functional/Predicate.hx" module="haxe.functional.Predicate"><t path="Function">
	<c path="haxe.functional.Predicate1.A"/>
	<e path="Bool"/>
</t></typedef>
	<typedef path="haxe.functional.Predicate2" params="A:B" file="../src/main/haxe/haxe/functional/Predicate.hx" module="haxe.functional.Predicate"><t path="Function2">
	<c path="haxe.functional.Predicate2.A"/>
	<c path="haxe.functional.Predicate2.B"/>
	<e path="Bool"/>
</t></typedef>
	<typedef path="haxe.functional.Predicate3" params="A:B:C" file="../src/main/haxe/haxe/functional/Predicate.hx" module="haxe.functional.Predicate"><t path="Function3">
	<c path="haxe.functional.Predicate3.A"/>
	<c path="haxe.functional.Predicate3.B"/>
	<c path="haxe.functional.Predicate3.C"/>
	<e path="Bool"/>
</t></typedef>
	<typedef path="haxe.functional.Predicate4" params="A:B:C:D" file="../src/main/haxe/haxe/functional/Predicate.hx" module="haxe.functional.Predicate"><t path="Function4">
	<c path="haxe.functional.Predicate4.A"/>
	<c path="haxe.functional.Predicate4.B"/>
	<c path="haxe.functional.Predicate4.C"/>
	<c path="haxe.functional.Predicate4.D"/>
	<e path="Bool"/>
</t></typedef>
	<typedef path="haxe.functional.Predicate5" params="A:B:C:D:E" file="../src/main/haxe/haxe/functional/Predicate.hx" module="haxe.functional.Predicate"><t path="Function5">
	<c path="haxe.functional.Predicate5.A"/>
	<c path="haxe.functional.Predicate5.B"/>
	<c path="haxe.functional.Predicate5.C"/>
	<c path="haxe.functional.Predicate5.D"/>
	<c path="haxe.functional.Predicate5.E"/>
	<e path="Bool"/>
</t></typedef>
	<class path="haxe.functional.P" params="" file="../src/main/haxe/haxe/functional/Predicate.hx" module="haxe.functional.Predicate">
		<isNull public="1" params="T" set="method" line="33" static="1"><f a=""><t path="haxe.functional.Predicate"><c path="isNull.T"/></t></f></isNull>
		<isNotNull public="1" params="T" set="method" line="39" static="1"><f a=""><t path="haxe.functional.Predicate"><c path="isNotNull.T"/></t></f></isNotNull>
		<isGreaterThan public="1" set="method" line="45" static="1"><f a="ref">
	<c path="Float"/>
	<t path="haxe.functional.Predicate"><c path="Float"/></t>
</f></isGreaterThan>
		<isLessThan public="1" set="method" line="51" static="1"><f a="ref">
	<c path="Float"/>
	<t path="haxe.functional.Predicate"><c path="Float"/></t>
</f></isLessThan>
		<isGreaterThanInt public="1" set="method" line="57" static="1"><f a="ref">
	<c path="Int"/>
	<t path="haxe.functional.Predicate"><c path="Int"/></t>
</f></isGreaterThanInt>
		<isLessThanInt public="1" set="method" line="63" static="1"><f a="ref">
	<c path="Int"/>
	<t path="haxe.functional.Predicate"><c path="Int"/></t>
</f></isLessThanInt>
		<isEqualTo public="1" params="T" set="method" line="69" static="1"><f a="ref:?equal">
	<c path="isEqualTo.T"/>
	<t path="EqualFunction"><c path="isEqualTo.T"/></t>
	<t path="haxe.functional.Predicate"><c path="isEqualTo.T"/></t>
</f></isEqualTo>
		<startsWith public="1" set="method" line="77" static="1"><f a="s">
	<c path="String"/>
	<t path="haxe.functional.Predicate"><c path="String"/></t>
</f></startsWith>
		<endsWith public="1" set="method" line="83" static="1"><f a="s">
	<c path="String"/>
	<t path="haxe.functional.Predicate"><c path="String"/></t>
</f></endsWith>
		<contains public="1" set="method" line="89" static="1"><f a="s">
	<c path="String"/>
	<t path="haxe.functional.Predicate"><c path="String"/></t>
</f></contains>
	</class>
	<class path="StringBuf" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/StringBuf.hx">
		<__make line="50" static="1"><d/></__make>
		<__add line="51" static="1"><d/></__add>
		<__add_char line="52" static="1"><d/></__add_char>
		<__add_sub line="53" static="1"><d/></__add_sub>
		<__string line="54" static="1"><d/></__string>
		<b><d/></b>
		<add public="1" get="inline" set="null" line="34">
			<f a="?x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="38">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="42">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="46">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<typedef path="haxe.test.MatchResult" params="" file="../src/main/haxe/haxe/test/MustMatchers.hx" module="haxe.test.MustMatchers"><a>
	<negation><c path="String"/></negation>
	<assertion><c path="String"/></assertion>
</a></typedef>
	<typedef path="haxe.test.MustMatcher" params="T" file="../src/main/haxe/haxe/test/MustMatchers.hx" module="haxe.test.MustMatchers"><f a="">
	<c path="haxe.test.MustMatcher.T"/>
	<e path="Either">
		<t path="haxe.test.MatchResult"/>
		<t path="haxe.test.MatchResult"/>
	</e>
</f></typedef>
	<class path="haxe.test.Must" params="" file="../src/main/haxe/haxe/test/MustMatchers.hx" module="haxe.test.MustMatchers">
		<equal public="1" params="T" set="method" line="32" static="1"><f a="expected:?equal">
	<c path="equal.T"/>
	<t path="EqualFunction"><c path="equal.T"/></t>
	<t path="haxe.test.MustMatcher"><c path="equal.T"/></t>
</f></equal>
		<beTrue public="1" set="method" line="50" static="1"><f a=""><t path="haxe.test.MustMatcher"><e path="Bool"/></t></f></beTrue>
		<beFalse public="1" set="method" line="66" static="1"><f a=""><t path="haxe.test.MustMatcher"><e path="Bool"/></t></f></beFalse>
		<beGreaterThan public="1" set="method" line="82" static="1"><f a="ref">
	<c path="Float"/>
	<t path="haxe.test.MustMatcher"><c path="Float"/></t>
</f></beGreaterThan>
		<beLessThan public="1" set="method" line="98" static="1"><f a="ref">
	<c path="Float"/>
	<t path="haxe.test.MustMatcher"><c path="Float"/></t>
</f></beLessThan>
		<beGreaterThanInt public="1" set="method" line="114" static="1"><f a="ref">
	<c path="Int"/>
	<t path="haxe.test.MustMatcher"><c path="Int"/></t>
</f></beGreaterThanInt>
		<beLessThanInt public="1" set="method" line="130" static="1"><f a="ref">
	<c path="Int"/>
	<t path="haxe.test.MustMatcher"><c path="Int"/></t>
</f></beLessThanInt>
		<haveLength public="1" params="T" set="method" line="146" static="1"><f a="length">
	<c path="Int"/>
	<t path="haxe.test.MustMatcher"><t path="Iterable"><c path="haveLength.T"/></t></t>
</f></haveLength>
		<haveClass public="1" params="T" set="method" line="161" static="1"><f a="c">
	<c path="Class"><c path="haveClass.T"/></c>
	<t path="haxe.test.MustMatcher"><d/></t>
</f></haveClass>
		<containElement public="1" params="C:T" set="method" line="172" static="1"><f a="element">
	<c path="containElement.T"/>
	<t path="haxe.test.MustMatcher"><c path="haxe.data.collections.Collection">
	<c path="containElement.C"/>
	<c path="containElement.T"/>
</c></t>
</f></containElement>
		<containString public="1" set="method" line="183" static="1"><f a="sub">
	<c path="String"/>
	<t path="haxe.test.MustMatcher"><c path="String"/></t>
</f></containString>
		<startWithString public="1" set="method" line="194" static="1"><f a="s">
	<c path="String"/>
	<t path="haxe.test.MustMatcher"><c path="String"/></t>
</f></startWithString>
		<endWithString public="1" set="method" line="205" static="1"><f a="s">
	<c path="String"/>
	<t path="haxe.test.MustMatcher"><c path="String"/></t>
</f></endWithString>
		<beNull public="1" params="T" set="method" line="216" static="1"><f a=""><t path="haxe.test.MustMatcher"><c path="beNull.T"/></t></f></beNull>
		<beNonNull public="1" params="T" set="method" line="227" static="1"><f a=""><t path="haxe.test.MustMatcher"><c path="beNonNull.T"/></t></f></beNonNull>
	</class>
	<class path="Lambda" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>
		Creates an [Array] from an [Iterable]
	</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>
		Creates a [List] from an [Iterable]
	</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>
		Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.
	</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>
		Similar to [map], but also pass an index for each item iterated.
	</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="81" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.
	</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="97" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if at least one element of the iterable is found by using the specific function.
	</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="107" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if all elements of the iterable have the specified property defined by [f].
	</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="117" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Call the function 'f' on all elements of the [Iterable] 'it'.
	</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>
		Return the list of elements matching the function 'f'
	</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="136" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>
		Functional 'fold' using an [Iterable]
	</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="145" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<e path="Bool"/>
				</f>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Count the number of elements in an [Iterable] having [pred] returning true.
	</haxe_doc>
		</count>
		<empty public="1" set="method" line="160" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an iterable does not contain any element.
	</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="168" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the item in the given Iterable, depending on the order of the Iterator.
		Returns -1 if the item was not found.
	</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="181" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>
		Returns a list containing all items of 'a' followed by all items of 'b'
	</haxe_doc>
		</concat>
		<haxe_doc>
	The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.
</haxe_doc>
	</class>
	<class path="haxe.test.TestFixture" params="T" file="../src/main/haxe/haxe/test/TestFixture.hx">
		<target public="1" set="null"><c path="haxe.test.TestFixture.T"/></target>
		<methodName public="1" set="null"><c path="String"/></methodName>
		<method public="1" set="null"><f a=""><e path="Void"/></f></method>
		<setup public="1" set="null"><c path="String"/></setup>
		<teardown public="1" set="null"><c path="String"/></teardown>
		<onTested public="1" set="null"><c path="haxe.test.Dispatcher"><c path="haxe.test.TestHandler"><c path="haxe.test.TestFixture.T"/></c></c></onTested>
		<onTimeout public="1" set="null"><c path="haxe.test.Dispatcher"><c path="haxe.test.TestHandler"><c path="haxe.test.TestFixture.T"/></c></c></onTimeout>
		<onComplete public="1" set="null"><c path="haxe.test.Dispatcher"><c path="haxe.test.TestHandler"><c path="haxe.test.TestFixture.T"/></c></c></onComplete>
		<checkMethod set="method" line="44"><f a="name:arg">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></checkMethod>
		<new public="1" set="method" line="32"><f a="target:methodName:method:?setup:?teardown">
	<c path="haxe.test.TestFixture.T"/>
	<c path="String"/>
	<f a=""><e path="Void"/></f>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
* @todo add documentation
</haxe_doc>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="haxe.rtti.Meta" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/haxe/rtti/Meta.hx">
		<getType public="1" set="method" line="35" static="1">
			<f a="t">
				<d/>
				<d><c path="Array"><d/></c></d>
			</f>
			<haxe_doc>
		Returns the metadata that were declared for the given type (class or enum)
	</haxe_doc>
		</getType>
		<getStatics public="1" set="method" line="43" static="1">
			<f a="t">
				<d/>
				<d><d><c path="Array"><d/></c></d></d>
			</f>
			<haxe_doc>
		Returns the metadata that were declared for the given class fields or enum constructors
	</haxe_doc>
		</getStatics>
		<getFields public="1" set="method" line="51" static="1">
			<f a="t">
				<d/>
				<d><d><c path="Array"><d/></c></d></d>
			</f>
			<haxe_doc>
		Returns the metadata that were declared for the given class static fields
	</haxe_doc>
		</getFields>
		<haxe_doc>
	An api to access classes and enums metadata at runtime.
</haxe_doc>
	</class>
	<typedef path="haxe.util.Object" params="" file="../src/main/haxe/haxe/util/ObjectExtensions.hx" module="haxe.util.ObjectExtensions"><a/></typedef>
	<class path="haxe.util.ObjectExtensions" params="" file="../src/main/haxe/haxe/util/ObjectExtensions.hx">
		<copy public="1" set="method" line="26" static="1"><f a="d:?shallow">
	<t path="haxe.util.Object"/>
	<e path="Bool"/>
	<t path="haxe.util.Object"/>
</f></copy>
		<copyTo public="1" set="method" line="30" static="1"><f a="src:dest:?shallow">
	<t path="haxe.util.Object"/>
	<t path="haxe.util.Object"/>
	<e path="Bool"/>
	<t path="haxe.util.Object"/>
</f></copyTo>
		<extendWith public="1" set="method" line="48" static="1"><f a="dest:src:?shallow">
	<t path="haxe.util.Object"/>
	<t path="haxe.util.Object"/>
	<e path="Bool"/>
	<t path="haxe.util.Object"/>
</f></extendWith>
		<fields public="1" set="method" line="54" static="1"><f a="d">
	<t path="haxe.util.Object"/>
	<c path="Array"><c path="String"/></c>
</f></fields>
		<mapValues public="1" params="T:S" set="method" line="58" static="1"><f a="d:f">
	<d><c path="mapValues.T"/></d>
	<f a="">
		<c path="mapValues.T"/>
		<c path="mapValues.S"/>
	</f>
	<d><c path="mapValues.S"/></d>
</f></mapValues>
		<set public="1" params="T" set="method" line="64" static="1"><f a="d:k:v">
	<d><c path="set.T"/></d>
	<c path="String"/>
	<c path="set.T"/>
	<d><c path="set.T"/></d>
</f></set>
		<setAny public="1" set="method" line="70" static="1"><f a="d:k:v">
	<t path="haxe.util.Object"/>
	<c path="String"/>
	<d/>
	<t path="haxe.util.Object"/>
</f></setAny>
		<setAll public="1" params="T" set="method" line="76" static="1"><f a="d:fields">
	<d><c path="setAll.T"/></d>
	<t path="Iterable"><c path="Tuple2">
	<c path="String"/>
	<c path="setAll.T"/>
</c></t>
	<d><c path="setAll.T"/></d>
</f></setAll>
		<replaceAll public="1" params="T" set="method" line="84" static="1"><f a="d1:d2:def">
	<d><c path="replaceAll.T"/></d>
	<d><c path="replaceAll.T"/></d>
	<c path="replaceAll.T"/>
	<t path="haxe.util.Object"/>
</f></replaceAll>
		<setAllAny public="1" set="method" line="98" static="1"><f a="d:fields">
	<t path="haxe.util.Object"/>
	<t path="Iterable"><c path="Tuple2">
	<c path="String"/>
	<d/>
</c></t>
	<t path="haxe.util.Object"/>
</f></setAllAny>
		<replaceAllAny public="1" set="method" line="106" static="1"><f a="d1:d2:def">
	<t path="haxe.util.Object"/>
	<t path="haxe.util.Object"/>
	<d/>
	<t path="haxe.util.Object"/>
</f></replaceAllAny>
		<get public="1" params="T" set="method" line="120" static="1"><f a="d:k">
	<d><c path="get.T"/></d>
	<c path="String"/>
	<e path="Option"><c path="get.T"/></e>
</f></get>
		<getAny public="1" set="method" line="124" static="1"><f a="d:k">
	<t path="haxe.util.Object"/>
	<c path="String"/>
	<e path="Option"><d/></e>
</f></getAny>
		<extractFieldValues public="1" set="method" line="128" static="1"><f a="obj:field">
	<d/>
	<c path="String"/>
	<c path="Array"><d/></c>
</f></extractFieldValues>
		<extractAll public="1" params="T" set="method" line="139" static="1"><f a="d">
	<d><c path="extractAll.T"/></d>
	<c path="Array"><c path="Tuple2">
	<c path="String"/>
	<c path="extractAll.T"/>
</c></c>
</f></extractAll>
		<extractAllAny public="1" set="method" line="143" static="1"><f a="d">
	<t path="haxe.util.Object"/>
	<c path="Array"><c path="Tuple2">
	<c path="String"/>
	<d/>
</c></c>
</f></extractAllAny>
		<extractValuesAny public="1" set="method" line="147" static="1"><f a="d:names:def">
	<t path="haxe.util.Object"/>
	<t path="Iterable"><c path="String"/></t>
	<d/>
	<c path="Array"><d/></c>
</f></extractValuesAny>
		<extractValues public="1" params="T" set="method" line="151" static="1"><f a="d:names:def">
	<d><c path="extractValues.T"/></d>
	<t path="Iterable"><c path="String"/></t>
	<c path="extractValues.T"/>
	<c path="Array"><c path="extractValues.T"/></c>
</f></extractValues>
		<iterator public="1" set="method" line="163" static="1"><f a="d">
	<t path="haxe.util.Object"/>
	<t path="Iterator"><c path="String"/></t>
</f></iterator>
	</class>
	<typedef path="haxe.reactive.Timeout" params="" file="../src/main/haxe/haxe/reactive/Reactive.hx" module="haxe.reactive.Reactive"><a/></typedef>
	<class path="haxe.reactive.External" params="" file="../src/main/haxe/haxe/reactive/Reactive.hx" module="haxe.reactive.Reactive">
		<setTimeout public="1" line="28" static="1"><f a=":">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<t path="haxe.reactive.Timeout"/>
</f></setTimeout>
		<cancelTimeout public="1" line="30" static="1"><f a="">
	<t path="haxe.reactive.Timeout"/>
	<e path="Void"/>
</f></cancelTimeout>
		<now public="1" line="32" static="1"><f a=""><c path="Float"/></f></now>
	</class>
	<enum path="haxe.reactive.Propagation" params="T" file="../src/main/haxe/haxe/reactive/Reactive.hx" module="haxe.reactive.Reactive">
		<propagate a="value"><c path="haxe.reactive.Pulse"><c path="haxe.reactive.Propagation.T"/></c></propagate>
		<doNotPropagate/>
	</enum>
	<class path="haxe.reactive.Pulse" params="T" file="../src/main/haxe/haxe/reactive/Reactive.hx" module="haxe.reactive.Reactive">
		<stamp public="1" set="null"><c path="Int"/></stamp>
		<value public="1" set="null"><c path="haxe.reactive.Pulse.T"/></value>
		<map public="1" params="S" set="method" line="53"><f a="f">
	<f a="">
		<c path="haxe.reactive.Pulse.T"/>
		<c path="map.S"/>
	</f>
	<c path="haxe.reactive.Pulse"><c path="map.S"/></c>
</f></map>
		<withValue public="1" params="S" set="method" line="57"><f a="newValue">
	<c path="withValue.S"/>
	<c path="haxe.reactive.Pulse"><c path="withValue.S"/></c>
</f></withValue>
		<new public="1" set="method" line="44"><f a="stamp:value">
	<c path="Int"/>
	<c path="haxe.reactive.Pulse.T"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.reactive.Stamp" params="" file="../src/main/haxe/haxe/reactive/Reactive.hx" module="haxe.reactive.Reactive">
		<_stamp line="63" static="1"><c path="Int"/></_stamp>
		<lastStamp public="1" set="method" line="65" static="1"><f a=""><c path="Int"/></f></lastStamp>
		<nextStamp public="1" set="method" line="69" static="1"><f a=""><c path="Int"/></f></nextStamp>
	</class>
	<class path="haxe.reactive.Rank" params="" file="../src/main/haxe/haxe/reactive/Reactive.hx" module="haxe.reactive.Reactive">
		<_rank line="75" static="1"><c path="Int"/></_rank>
		<lastRank public="1" set="method" line="77" static="1"><f a=""><c path="Int"/></f></lastRank>
		<nextRank public="1" set="method" line="81" static="1"><f a=""><c path="Int"/></f></nextRank>
	</class>
	<typedef path="haxe.reactive.KeyValue" params="T" file="../src/main/haxe/haxe/reactive/Reactive.hx" module="haxe.reactive.Reactive"><a>
	<v><c path="haxe.reactive.KeyValue.T"/></v>
	<k><c path="Int"/></k>
</a></typedef>
	<class path="haxe.reactive._Reactive.PriorityQueue" params="T" file="../src/main/haxe/haxe/reactive/Reactive.hx" private="1" module="haxe.reactive.Reactive">
		<val><c path="Array"><t path="haxe.reactive.KeyValue"><c path="haxe.reactive._Reactive.PriorityQueue.T"/></t></c></val>
		<length public="1" set="method" line="95"><f a=""><c path="Int"/></f></length>
		<insert public="1" set="method" line="99"><f a="kv">
	<t path="haxe.reactive.KeyValue"><c path="haxe.reactive._Reactive.PriorityQueue.T"/></t>
	<e path="Void"/>
</f></insert>
		<isEmpty public="1" set="method" line="113"><f a=""><e path="Bool"/></f></isEmpty>
		<pop public="1" set="method" line="117"><f a=""><t path="haxe.reactive.KeyValue"><c path="haxe.reactive._Reactive.PriorityQueue.T"/></t></f></pop>
		<new public="1" set="method" line="91"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.reactive.Stream" params="T" file="../src/main/haxe/haxe/reactive/Reactive.hx" module="haxe.reactive.Reactive">
		<_rank><c path="Int"/></_rank>
		<_sendsTo><c path="Array"><c path="haxe.reactive.Stream"><d/></c></c></_sendsTo>
		<_updater><f a="">
	<c path="haxe.reactive.Pulse"><d/></c>
	<e path="haxe.reactive.Propagation"><c path="haxe.reactive.Stream.T"/></e>
</f></_updater>
		<_weak><e path="Bool"/></_weak>
		<weaklyHeld public="1" get="getWeaklyHeld" set="setWeaklyHeld"><e path="Bool"/></weaklyHeld>
		<_cleanups><c path="Array"><f a=""><e path="Void"/></f></c></_cleanups>
		<attachListener public="1" set="method" line="178"><f a="dependent">
	<c path="haxe.reactive.Stream"><d/></c>
	<e path="Void"/>
</f></attachListener>
		<removeListener public="1" set="method" line="196"><f a="dependent:?isWeakReference">
	<c path="haxe.reactive.Stream"><d/></c>
	<e path="Bool"/>
	<e path="Bool"/>
</f></removeListener>
		<whenFinishedDo public="1" set="method" line="220">
			<f a="f">
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Invokes the specified function when this stream is "finished", defined 
     * as being unable to produce any more events.
     </haxe_doc>
		</whenFinishedDo>
		<forEach public="1" set="method" line="232">
			<f a="f">
				<f a="">
					<c path="haxe.reactive.Stream.T"/>
					<e path="Void"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Calls the specified function for each event.
     </haxe_doc>
		</forEach>
		<each public="1" set="method" line="248">
			<f a="f">
				<f a="">
					<c path="haxe.reactive.Stream.T"/>
					<e path="Void"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Calls the specified function for each event.
     </haxe_doc>
		</each>
		<toArray public="1" set="method" line="256">
			<f a=""><c path="Array"><c path="haxe.reactive.Stream.T"/></c></f>
			<haxe_doc>
     * Converts the stream to an array. Note: This array will grow 
     * continuously without bound unless clients remove elements from it.
     </haxe_doc>
		</toArray>
		<constant public="1" params="Z" set="method" line="270">
			<f a="value">
				<c path="constant.Z"/>
				<c path="haxe.reactive.Stream"><c path="constant.Z"/></c>
			</f>
			<haxe_doc>
     * Maps this stream to a stream of constant values.
     *
     * @param value The constant that every value will be mapped to.
     *
     </haxe_doc>
		</constant>
		<bind public="1" params="Z" set="method" line="280">
			<f a="k">
				<f a="">
					<c path="haxe.reactive.Stream.T"/>
					<c path="haxe.reactive.Stream"><c path="bind.Z"/></c>
				</f>
				<c path="haxe.reactive.Stream"><c path="bind.Z"/></c>
			</f>
			<haxe_doc>
     * AKA flatMap. Binds each value to another stream, and returns a 
     * flattened stream.
     *
     * @param k The bind function.
     </haxe_doc>
		</bind>
		<sendEvent public="1" set="method" line="310">
			<f a="value">
				<d/>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Sends an event now. This function should not be used except to create
     * "pure" streams.
     *
     * @param value The value to send.
     </haxe_doc>
		</sendEvent>
		<sendEventTyped public="1" set="method" line="322">
			<f a="value">
				<c path="haxe.reactive.Stream.T"/>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * A typed version of sendEvent.
	 * Sends an event now. This function should not be used except to create
     * "pure" streams.
     *
     * @param value The value to send.
     </haxe_doc>
		</sendEventTyped>
		<sendLaterIn public="1" set="method" line="337">
			<f a="value:millis">
				<d/>
				<c path="Int"/>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Sends an event later. This function should not be used except to create
     * "pure" streams.
     *
     * @param value     The value to send.
     *
     * @param millis    The number of milliseconds to send it in. If this is 0, 
     *                  the event will be scheduled for "as soon as possible".
     *
     </haxe_doc>
		</sendLaterIn>
		<sendLater public="1" set="method" line="355">
			<f a="value">
				<d/>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Sends an event later, "as soon as possible".
     *
     * @param value The value to send.
     </haxe_doc>
		</sendLater>
		<startsWith public="1" set="method" line="365">
			<f a="init">
				<c path="haxe.reactive.Stream.T"/>
				<c path="haxe.reactive.Signal"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Creates a signal backed by this event stream, which starts with the 
     * specified value.
     *
     * @param init  The initial value.
     </haxe_doc>
		</startsWith>
		<delay public="1" set="method" line="380">
			<f a="time">
				<c path="Int"/>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Delays this stream by the specified number of milliseconds.
     *
     * @param   time    Time in milliseconds as an Int
     </haxe_doc>
		</delay>
		<delayS public="1" set="method" line="400">
			<f a="time">
				<c path="haxe.reactive.Signal"><c path="Int"/></c>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Delays this stream by the specified number of milliseconds.
     * 
     * @param   time    Time in milliseconds as a Signal
     </haxe_doc>
		</delayS>
		<calm public="1" set="method" line="440">
			<f a="time">
				<c path="Int"/>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Calms the stream. No event will be fired unless it occurs T milliseconds
     * after the prior event.
     *
     * @param time  The number of milliseconds.
     </haxe_doc>
		</calm>
		<calmS public="1" set="method" line="450">
			<f a="time">
				<c path="haxe.reactive.Signal"><c path="Int"/></c>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Calms the stream. No event will be get through unless it occurs T 
     * milliseconds or more before the following event.
     *
     * @param time  The number of milliseconds.
     </haxe_doc>
		</calmS>
		<blind public="1" set="method" line="484">
			<f a="time">
				<c path="Int"/>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Blinds the event stream to events occurring less than the specified 
     * milliseconds together.
     *
     * @param time The time to blind the stream to.
     </haxe_doc>
		</blind>
		<blindS public="1" set="method" line="494">
			<f a="time">
				<c path="haxe.reactive.Signal"><c path="Int"/></c>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Blinds the event stream to events occurring the specified 
     * number of milliseconds together or less.
     *
     * @param time The time to blind the stream to.
     </haxe_doc>
		</blindS>
		<snapshot public="1" params="Z" set="method" line="520">
			<f a="value">
				<c path="haxe.reactive.Signal"><c path="snapshot.Z"/></c>
				<c path="haxe.reactive.Stream"><c path="snapshot.Z"/></c>
			</f>
			<haxe_doc>
     * Maps this stream into a stream of values determined by "snapshotting" 
     * the value of the signal.
     *
     * @param value The value.
     </haxe_doc>
		</snapshot>
		<filterRepeats public="1" set="method" line="529">
			<f a="?optStart">
				<c path="haxe.reactive.Stream.T"/>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Filters adjacent repeats.
     *
     * @param optStart  An optional start value.
     </haxe_doc>
		</filterRepeats>
		<filterRepeatsBy public="1" set="method" line="539">
			<f a="?optStart:eq">
				<c path="haxe.reactive.Stream.T"/>
				<f a=":">
					<c path="haxe.reactive.Stream.T"/>
					<c path="haxe.reactive.Stream.T"/>
					<e path="Bool"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Filters adjacent repeats.
     *
     * @param optStart  An optional start value.
     * @param eq        An equality function.
     </haxe_doc>
		</filterRepeatsBy>
		<map public="1" params="Z" set="method" line="561">
			<f a="mapper">
				<f a="">
					<c path="haxe.reactive.Stream.T"/>
					<c path="map.Z"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="map.Z"/></c>
			</f>
			<haxe_doc>
     * Maps this stream to another stream by using the specified function.
     *
     * @param mapper    The mapping function.
     </haxe_doc>
		</map>
		<flatMap public="1" params="Z" set="method" line="575">
			<f a="mapper">
				<f a="">
					<c path="haxe.reactive.Stream.T"/>
					<c path="haxe.reactive.Stream"><c path="flatMap.Z"/></c>
				</f>
				<c path="haxe.reactive.Stream"><c path="flatMap.Z"/></c>
			</f>
			<haxe_doc>
     * Flattens the result of mapping each value to another stream.
     *
     * @param mapper The mapper.
     </haxe_doc>
		</flatMap>
		<scanl public="1" params="Z" set="method" line="585">
			<f a="initial:folder">
				<c path="scanl.Z"/>
				<f a=":">
					<c path="scanl.Z"/>
					<c path="haxe.reactive.Stream.T"/>
					<c path="scanl.Z"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="scanl.Z"/></c>
			</f>
			<haxe_doc>
     * A stream of values resulting from left folding.
     *
     * @param initial   The initial value.
     * @param folder    The folding function.
     </haxe_doc>
		</scanl>
		<scanlP public="1" set="method" line="602">
			<f a="folder">
				<f a=":">
					<c path="haxe.reactive.Stream.T"/>
					<c path="haxe.reactive.Stream.T"/>
					<c path="haxe.reactive.Stream.T"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Same as scanl, but without an initial value.
     </haxe_doc>
		</scanlP>
		<take public="1" set="method" line="629">
			<f a="n">
				<c path="Int"/>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Returns a finite stream consisting of the first n elements of this 
     * stream.
     *
     * @param n The number of values.
     </haxe_doc>
		</take>
		<takeWhile public="1" set="method" line="655">
			<f a="filter">
				<f a="">
					<c path="haxe.reactive.Stream.T"/>
					<e path="Bool"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Returns a finite stream consisting of the first subset of this stream
     * for which the filter returns true.
     *
     * @param n The number of values.
     </haxe_doc>
		</takeWhile>
		<shift public="1" set="method" line="685">
			<f a="n">
				<c path="Int"/>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Shifts events forward in time by the specified number of events.
     * 
     * @param n The number of events to shift by.
     </haxe_doc>
		</shift>
		<shiftWhile public="1" set="method" line="705">
			<f a="pred">
				<f a="">
					<c path="haxe.reactive.Stream.T"/>
					<e path="Bool"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Shifts events forward in time until the specified predicate returns 
     * false for an event.
     *
     * @param pred  The predicate.
     </haxe_doc>
		</shiftWhile>
		<shiftWith public="1" set="method" line="734">
			<f a="elements">
				<t path="Iterable"><c path="haxe.reactive.Stream.T"/></t>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Shifts events forward in time by pulling from the specified iterable
     * until it's exhausted, then streaming the delayed events.
     *
     * @param elements  The elements to use in time shifting.
     </haxe_doc>
		</shiftWith>
		<drop public="1" set="method" line="756">
			<f a="n">
				<c path="Int"/>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Drops the specified number of events from this stream. This method does
     * not change the timestamps of events.
     *
     * @param n The number to drop.
     </haxe_doc>
		</drop>
		<dropWhile public="1" set="method" line="773">
			<f a="pred">
				<f a="">
					<c path="haxe.reactive.Stream.T"/>
					<e path="Bool"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Drops events for as long as the predicate returns true.
     *
     * @param pred  The predicate.
     </haxe_doc>
		</dropWhile>
		<partition public="1" set="method" line="798">
			<f a="pred">
				<f a="">
					<c path="haxe.reactive.Stream.T"/>
					<e path="Bool"/>
				</f>
				<c path="Tuple2">
					<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
					<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
				</c>
			</f>
			<haxe_doc>
     * Partitions the stream into two event streams, one for which the 
     * predicate is true, one for which the predicate is false.
     *
     * @param pred  The predicate.
     </haxe_doc>
		</partition>
		<partitionWhile public="1" set="method" line="821">
			<f a="pred">
				<f a="">
					<c path="haxe.reactive.Stream.T"/>
					<e path="Bool"/>
				</f>
				<c path="Tuple2">
					<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
					<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
				</c>
			</f>
			<haxe_doc>
     * Returns a tuple of takeWhile/dropWhile for the specified predicate.
     *
     * @param pred  The predicate.
     </haxe_doc>
		</partitionWhile>
		<filter public="1" set="method" line="833">
			<f a="pred">
				<f a="">
					<c path="haxe.reactive.Stream.T"/>
					<e path="Bool"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Filters this stream by the specified predicate.
     *
      * @param pred The predicate.
      </haxe_doc>
		</filter>
		<filterWhile public="1" set="method" line="847">
			<f a="pred">
				<f a="">
					<c path="haxe.reactive.Stream.T"/>
					<e path="Bool"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Accepts all elements until the predicate first returns false.
     *
     * @param pred  The predicate.
     </haxe_doc>
		</filterWhile>
		<zipWith public="1" params="A:R" set="method" line="884">
			<f a="as:f">
				<c path="haxe.reactive.Stream"><c path="zipWith.A"/></c>
				<f a=":">
					<c path="haxe.reactive.Stream.T"/>
					<c path="zipWith.A"/>
					<c path="zipWith.R"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="zipWith.R"/></c>
			</f>
			<haxe_doc>
     * Zips elements of supplied streams together using a function and returns a
     * Stream of the resulting elements.
     *
     * [1, 2, 3].zipWith([1, 2, 3], Tuple2.create) == [Tuple2[1, 1], Tuple2[2, 2], Tuple2[3, 3]]
     *
     * @param as  The stream with which to zipWith 'this'.
     * @param f  The function that will be used to get the result from the inputs streams ('this' and as).
     *
     * @return     The Stream of the result of the application of the function on using both stream elements as input.
	 * 
     </haxe_doc>
		</zipWith>
		<zip public="1" params="A" set="method" line="919">
			<f a="as">
				<c path="haxe.reactive.Stream"><c path="zip.A"/></c>
				<c path="haxe.reactive.Stream"><c path="Tuple2">
	<c path="haxe.reactive.Stream.T"/>
	<c path="zip.A"/>
</c></c>
			</f>
			<haxe_doc>
     * Zips elements of supplied streams together and returns an
     * Stream of Tuple2 containing the zipped elements.
     *
     * [1, 2, 3].zip[1, 2, 3] == [Tuple2[1, 1], Tuple2[2, 2], Tuple2[3, 3]]
     *
     * @param as  The stream with which to zip 'this'.
     *
     * @return     A Tuple slice containing an element from each 
     *             stream
     </haxe_doc>
		</zip>
		<zip3 public="1" params="A:B" set="method" line="935">
			<f a="as:bs">
				<c path="haxe.reactive.Stream"><c path="zip3.A"/></c>
				<c path="haxe.reactive.Stream"><c path="zip3.B"/></c>
				<c path="haxe.reactive.Stream"><c path="Tuple3">
	<c path="haxe.reactive.Stream.T"/>
	<c path="zip3.A"/>
	<c path="zip3.B"/>
</c></c>
			</f>
			<haxe_doc>
     * Zips elements of supplied streams together and returns an
     * Stream of Tuple3 containing the zipped elements.
     *
     * [1, 2, 3].zip([1, 2, 3], [1, 2, 3]) == [Tuple3[1, 1, 1], Tuple3[2, 2, 2], Tuple3[3, 3, 3]]
     *
     * @param as  The a stream with which to zip 'this'.
     * @param bs  The b stream with which to zip 'this' and as.
     *
     * @return     A Tuple slice containing an element from each 
     *             stream
     </haxe_doc>
		</zip3>
		<zip4 public="1" params="A:B:C" set="method" line="958">
			<f a="as:bs:cs">
				<c path="haxe.reactive.Stream"><c path="zip4.A"/></c>
				<c path="haxe.reactive.Stream"><c path="zip4.B"/></c>
				<c path="haxe.reactive.Stream"><c path="zip4.C"/></c>
				<c path="haxe.reactive.Stream"><c path="Tuple4">
	<c path="haxe.reactive.Stream.T"/>
	<c path="zip4.A"/>
	<c path="zip4.B"/>
	<c path="zip4.C"/>
</c></c>
			</f>
			<haxe_doc>
     * Zips elements of supplied streams together and returns an
     * Stream of Tuple4 containing the zipped elements.
     *
     * For example see above
     *
     * @param as  The a stream with which to zip 'this'.
     * @param bs  The b stream with which to zip 'this' and as.
     * @param cs  The c stream with which to zip 'this,' as, and bs.
     *
     * @return     A Tuple slice containing one element from each 
     *             stream
     </haxe_doc>
		</zip4>
		<zip5 public="1" params="A:B:C:D" set="method" line="983">
			<f a="as:bs:cs:ds">
				<c path="haxe.reactive.Stream"><c path="zip5.A"/></c>
				<c path="haxe.reactive.Stream"><c path="zip5.B"/></c>
				<c path="haxe.reactive.Stream"><c path="zip5.C"/></c>
				<c path="haxe.reactive.Stream"><c path="zip5.D"/></c>
				<c path="haxe.reactive.Stream"><c path="Tuple5">
	<c path="haxe.reactive.Stream.T"/>
	<c path="zip5.A"/>
	<c path="zip5.B"/>
	<c path="zip5.C"/>
	<c path="zip5.D"/>
</c></c>
			</f>
			<haxe_doc>
     * Zips elements of supplied streams together and returns an
     * Stream of Tuple5 containing the zipped elements.
     *
     * For example see above
     *
     * @param as  The a stream with which to zip 'this'.
     * @param bs  The b stream with which to zip 'this' and as.
     * @param cs  The c stream with which to zip 'this,' as, and bs.
     * @param ds  The d stream with which to zip 'this,' as, bs, and cs.
     *
     * @return     A Tuple slice containing one element from each 
     *             stream
     </haxe_doc>
		</zip5>
		<group public="1" set="method" line="1002">
			<f a=""><c path="haxe.reactive.Stream"><t path="Iterable"><c path="haxe.reactive.Stream.T"/></t></c></f>
			<haxe_doc>
     * Groups Stream elements which are sent
     * sequentially and are == to each other into
     * iterables and returns these in a new stream
     *
     * @return     An Stream of grouped elements
     </haxe_doc>
		</group>
		<groupBy public="1" set="method" line="1019">
			<f a="eq">
				<f a=":">
					<c path="haxe.reactive.Stream.T"/>
					<c path="haxe.reactive.Stream.T"/>
					<e path="Bool"/>
				</f>
				<c path="haxe.reactive.Stream"><t path="Iterable"><c path="haxe.reactive.Stream.T"/></t></c>
			</f>
			<haxe_doc>
     * Groups Stream elements which are sent
     * sequentially and which return true from the
     * supplied comparison function into iterables
     * and returns these in a new stream
     *
     * @param   eq      The comparison function that
     *                  will be used fo evaluate the 
     *                  equality of the stream
     *                  elements.
     *
     * @return     An Stream of grouped elements
     </haxe_doc>
		</groupBy>
		<merge public="1" set="method" line="1062">
			<f a="that">
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Merges this stream and the specified stream.
     *
     * @param that  The Stream with which to 
     *              merge 'this' stream
     </haxe_doc>
		</merge>
		<uniqueSteps public="1" set="method" line="1070">
			<f a=""><c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c></f>
			<haxe_doc>
     * Creates a new Stream in which only events on 
     * different time steps will appear
     *
     </haxe_doc>
		</uniqueSteps>
		<uniqueEvents public="1" set="method" line="1092">
			<f a="?eq">
				<f a=":">
					<c path="haxe.reactive.Stream.T"/>
					<c path="haxe.reactive.Stream.T"/>
					<e path="Bool"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Creates a new Stream in which only new events
     * will appear (including those on the same time step)
     *
     * @param eq  The Function used to check event equality
     </haxe_doc>
		</uniqueEvents>
		<unique public="1" set="method" line="1115">
			<f a="?eq">
				<f a=":">
					<c path="haxe.reactive.Stream.T"/>
					<c path="haxe.reactive.Stream.T"/>
					<e path="Bool"/>
				</f>
				<c path="haxe.reactive.Stream"><c path="haxe.reactive.Stream.T"/></c>
			</f>
			<haxe_doc>
     * Creates a new Stream in which only unique events
     * taking place at unique timesteps will appear
     *
     * @param eq  The Function used to check event equality
     </haxe_doc>
		</unique>
		<propagatePulse set="method" line="1119"><f a="pulse">
	<c path="haxe.reactive.Pulse"><d/></c>
	<e path="Void"/>
</f></propagatePulse>
		<setWeaklyHeld set="method" line="1163"><f a="held">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setWeaklyHeld>
		<getWeaklyHeld set="method" line="1177"><f a=""><e path="Bool"/></f></getWeaklyHeld>
		<new public="1" set="method" line="163"><f a="updater:?sources">
	<f a="">
		<c path="haxe.reactive.Pulse"><d/></c>
		<e path="haxe.reactive.Propagation"><c path="haxe.reactive.Stream.T"/></e>
	</f>
	<c path="Array"><c path="haxe.reactive.Stream"><d/></c></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.reactive.Signal" params="T" file="../src/main/haxe/haxe/reactive/Reactive.hx" module="haxe.reactive.Reactive">
		<_underlyingRaw><c path="haxe.reactive.Stream"><d/></c></_underlyingRaw>
		<_underlying><c path="haxe.reactive.Stream"><c path="haxe.reactive.Signal.T"/></c></_underlying>
		<_updater><f a="">
	<c path="haxe.reactive.Pulse"><d/></c>
	<e path="haxe.reactive.Propagation"><c path="haxe.reactive.Signal.T"/></e>
</f></_updater>
		<_last><c path="haxe.reactive.Signal.T"/></_last>
		<map public="1" params="Z" set="method" line="1221">
			<f a="f">
				<f a="">
					<c path="haxe.reactive.Signal.T"/>
					<c path="map.Z"/>
				</f>
				<c path="haxe.reactive.Signal"><c path="map.Z"/></c>
			</f>
			<haxe_doc>
     * Applies a function to a value and returns the 
     * result as a Signal.
     *
     * @param   f   The function to apply.
     *
     * @result      A Signal that is the result
     *              of the supplied function. 
     </haxe_doc>
		</map>
		<mapS public="1" params="Z" set="method" line="1235">
			<f a="f">
				<c path="haxe.reactive.Signal"><f a="">
	<c path="haxe.reactive.Signal.T"/>
	<c path="mapS.Z"/>
</f></c>
				<c path="haxe.reactive.Signal"><c path="mapS.Z"/></c>
			</f>
			<haxe_doc>
     * Applies a function to a value and returns the 
     * result as a Signal.
     *
     * @param   f   A Signal that accepts a T and 
     *              returns a Z.
     *
     * @result      A Signal that is the result
     *              of the supplied function. 
     </haxe_doc>
		</mapS>
		<lift public="1" params="Z" set="method" line="1248">
			<f a="f">
				<f a="">
					<c path="haxe.reactive.Signal.T"/>
					<c path="lift.Z"/>
				</f>
				<c path="haxe.reactive.Signal"><c path="lift.Z"/></c>
			</f>
			<haxe_doc>
     * Applies a function to a value and returns the 
     * result as a Signal.
     *
     * @param   f   The function to apply.
     *
     * @result      A Signal that is the result
     *              of the supplied function. 
     </haxe_doc>
		</lift>
		<liftS public="1" params="Z" set="method" line="1266">
			<f a="f">
				<c path="haxe.reactive.Signal"><f a="">
	<c path="haxe.reactive.Signal.T"/>
	<c path="liftS.Z"/>
</f></c>
				<c path="haxe.reactive.Signal"><c path="liftS.Z"/></c>
			</f>
			<haxe_doc>
     * Applies a function to a value and returns the 
     * result as a Signal.
     *
     * @param   f   A Signal that accepts a T and 
     *              returns a Z.
     *
     * @result      A Signal that is the result
     *              of the supplied function. 
     </haxe_doc>
		</liftS>
		<zipWith public="1" params="A:R" set="method" line="1287">
			<f a="b2:f">
				<c path="haxe.reactive.Signal"><c path="zipWith.A"/></c>
				<f a=":">
					<c path="haxe.reactive.Signal.T"/>
					<c path="zipWith.A"/>
					<c path="zipWith.R"/>
				</f>
				<c path="haxe.reactive.Signal"><c path="zipWith.R"/></c>
			</f>
			<haxe_doc>
     * Zips elements of supplied streams together using a function and returns a
     * Signal of the resulting elements.
     *
     * [1, 2, 3].zipWith([1, 2, 3], Tuple2.create) == [Tuple2[1, 1], Tuple2[2, 2], Tuple2[3, 3]]
     *
     * @param as  The signal with which to zipWith 'this'.
     * @param f  The function that will be used to get the result from the inputs signals ('this' and as).
     *
     * @return     The Signal of the result of the application of the function on using both stream elements as input.
	 * 
     </haxe_doc>
		</zipWith>
		<zip public="1" params="B" set="method" line="1313">
			<f a="b2">
				<c path="haxe.reactive.Signal"><c path="zip.B"/></c>
				<c path="haxe.reactive.Signal"><c path="Tuple2">
	<c path="haxe.reactive.Signal.T"/>
	<c path="zip.B"/>
</c></c>
			</f>
			<haxe_doc>
     * Zips elements of supplied Signals together and returns a
     * Signal of Tuple2 containing the zipped elements.
     *
     * [1, 2, 3].zip[1, 2, 3] == [Tuple2[1, 1], Tuple2[2, 2], Tuple2[3, 3]]
     *
     * @param b2  The Signal with which to zip 'this' Signal.
     *
     * @return     A Signal Tuple slice containing an element from each 
     *             supplied Signal
     </haxe_doc>
		</zip>
		<zip3 public="1" params="B:C" set="method" line="1327">
			<f a="b2:b3">
				<c path="haxe.reactive.Signal"><c path="zip3.B"/></c>
				<c path="haxe.reactive.Signal"><c path="zip3.C"/></c>
				<c path="haxe.reactive.Signal"><c path="Tuple3">
	<c path="haxe.reactive.Signal.T"/>
	<c path="zip3.B"/>
	<c path="zip3.C"/>
</c></c>
			</f>
			<haxe_doc>
     * Zips elements of supplied Signals together and returns a
     * Signal of Tuple3 containing the zipped elements.
     *
     * @param b2  A Signal to be zipped.
     * @param b3  A Signal to be zipped.
     *
     * @return     A Signal Tuple slice containing an element from each 
     *             Signal
     </haxe_doc>
		</zip3>
		<zip4 public="1" params="B:C:D" set="method" line="1353">
			<f a="b2:b3:b4">
				<c path="haxe.reactive.Signal"><c path="zip4.B"/></c>
				<c path="haxe.reactive.Signal"><c path="zip4.C"/></c>
				<c path="haxe.reactive.Signal"><c path="zip4.D"/></c>
				<c path="haxe.reactive.Signal"><c path="Tuple4">
	<c path="haxe.reactive.Signal.T"/>
	<c path="zip4.B"/>
	<c path="zip4.C"/>
	<c path="zip4.D"/>
</c></c>
			</f>
			<haxe_doc>
     * Zips elements of supplied Signals together and returns a
     * Signal of Tuple4 containing the zipped elements.
     *
     * @param b2  A Signal to be zipped.
      * @param b3  A Signal to be zipped.
      * @param b4  A Signal to be zipped.
      *
      * @return     A Signal Tuple slice containing an element from each 
      *             Signal
       </haxe_doc>
		</zip4>
		<zip5 public="1" params="B:C:D:E" set="method" line="1380">
			<f a="b2:b3:b4:b5">
				<c path="haxe.reactive.Signal"><c path="zip5.B"/></c>
				<c path="haxe.reactive.Signal"><c path="zip5.C"/></c>
				<c path="haxe.reactive.Signal"><c path="zip5.D"/></c>
				<c path="haxe.reactive.Signal"><c path="zip5.E"/></c>
				<c path="haxe.reactive.Signal"><c path="Tuple5">
	<c path="haxe.reactive.Signal.T"/>
	<c path="zip5.B"/>
	<c path="zip5.C"/>
	<c path="zip5.D"/>
	<c path="zip5.E"/>
</c></c>
			</f>
			<haxe_doc>
      * Zips elements of supplied Signals together and returns a
      * Signal of Tuple5 containing the zipped elements.
      *
      * @param b2  A Signal to be zipped.
      * @param b3  A Signal to be zipped.
      * @param b4  A Signal to be zipped.
      * @param b5  A Signal to be zipped.
      *
      * @return     A Signal Tuple slice containing an element from each 
      *             Signal
      </haxe_doc>
		</zip5>
		<zipN public="1" set="method" line="1401">
			<f a="signals">
				<t path="Iterable"><c path="haxe.reactive.Signal"><c path="haxe.reactive.Signal.T"/></c></t>
				<c path="haxe.reactive.Signal"><t path="Iterable"><c path="haxe.reactive.Signal.T"/></t></c>
			</f>
			<haxe_doc>
     * Zips together the specified Signals.
     *
     *@param    signals   An Iterable of the 
     *                      Signals to be zipped.
     </haxe_doc>
		</zipN>
		<calm public="1" set="method" line="1413">
			<f a="time">
				<c path="Int"/>
				<c path="haxe.reactive.Signal"><c path="haxe.reactive.Signal.T"/></c>
			</f>
			<haxe_doc>
     * Calms the stream. No event will be get through unless it occurs T 
     * milliseconds or more before the following event.
     *
     * @param time  The number of milliseconds.
     </haxe_doc>
		</calm>
		<calmS public="1" set="method" line="1423">
			<f a="time">
				<c path="haxe.reactive.Signal"><c path="Int"/></c>
				<c path="haxe.reactive.Signal"><c path="haxe.reactive.Signal.T"/></c>
			</f>
			<haxe_doc>
     * Calms the stream. No event will be get through unless it occurs T 
     * milliseconds or more before the following event.
     *
     * @param time  The number of milliseconds as a Signal.
     </haxe_doc>
		</calmS>
		<blind public="1" set="method" line="1433">
			<f a="time">
				<c path="Int"/>
				<c path="haxe.reactive.Signal"><c path="haxe.reactive.Signal.T"/></c>
			</f>
			<haxe_doc>
     * Blinds the event stream to events occurring the specified 
     * number of milliseconds together or less.
     *
     * @param time The time to blind the stream to.
     </haxe_doc>
		</blind>
		<blindS public="1" set="method" line="1443">
			<f a="time">
				<c path="haxe.reactive.Signal"><c path="Int"/></c>
				<c path="haxe.reactive.Signal"><c path="haxe.reactive.Signal.T"/></c>
			</f>
			<haxe_doc>
     * Blinds the event stream to events occurring the specified 
     * number of milliseconds together or less.
     *
     * @param time The time to blind the stream to.
     </haxe_doc>
		</blindS>
		<delay public="1" set="method" line="1452">
			<f a="time">
				<c path="Int"/>
				<c path="haxe.reactive.Signal"><c path="haxe.reactive.Signal.T"/></c>
			</f>
			<haxe_doc>
     * Delays this stream by the specified number of milliseconds.
     * 
     * @param   time    Time in milliseconds as an Int
     </haxe_doc>
		</delay>
		<delayS public="1" set="method" line="1461">
			<f a="time">
				<c path="haxe.reactive.Signal"><c path="Int"/></c>
				<c path="haxe.reactive.Signal"><c path="haxe.reactive.Signal.T"/></c>
			</f>
			<haxe_doc>
     * Delays this stream by the specified number of milliseconds.
     * 
     * @param   time    Time in milliseconds as a Signal
     </haxe_doc>
		</delayS>
		<valueNow public="1" set="method" line="1469">
			<f a=""><c path="haxe.reactive.Signal.T"/></f>
			<haxe_doc>
     * Returns the present value of 'this' Signal. 
     *
     </haxe_doc>
		</valueNow>
		<mapC public="1" set="method" line="1483">
			<f a="f">
				<f a="">
					<c path="haxe.reactive.Stream"><c path="haxe.reactive.Signal.T"/></c>
					<c path="haxe.reactive.Stream"><c path="haxe.reactive.Signal.T"/></c>
				</f>
				<c path="haxe.reactive.Signal"><c path="haxe.reactive.Signal.T"/></c>
			</f>
			<haxe_doc>
     * Applies a function to a signal's value that 
     * accepts an Stream value and returns the 
     * result as an Stream value.
     *
     * @param   f   The function to apply.
     *
     * @result      A Signal that is the result
     *              of the supplied function. 
     </haxe_doc>
		</mapC>
		<changes public="1" set="method" line="1492">
			<f a=""><c path="haxe.reactive.Stream"><c path="haxe.reactive.Signal.T"/></c></f>
			<haxe_doc>
     * Returns the Stream underlying the Signal.
     *
     * @result      The underlying Stream.
     </haxe_doc>
		</changes>
		<sendSignal public="1" set="method" line="1502">
			<f a="value">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Sends an event to the underlying Stream that will be immediately 
     * propagated with a new timestamp.
     *
     * @param   value   the value to send Into the Stream.
     </haxe_doc>
		</sendSignal>
		<new public="1" set="method" line="1189"><f a="stream:init:updater">
	<c path="haxe.reactive.Stream"><d/></c>
	<c path="haxe.reactive.Signal.T"/>
	<f a="">
		<c path="haxe.reactive.Pulse"><d/></c>
		<e path="haxe.reactive.Propagation"><c path="haxe.reactive.Signal.T"/></e>
	</f>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.test.resources.CollectionTester" params="" file="../src/main/haxe/haxe/test/resources/BCollectionTester.hx" module="haxe.test.resources.BCollectionTester">
		<extends path="haxe.test.TestCase"/>
		<testThatTraceWorks public="1" set="method" line="15"><f a=""><e path="Void"/></f></testThatTraceWorks>
		<testThatItXFoldlWorks public="1" set="method" line="20"><f a=""><e path="Void"/></f></testThatItXFoldlWorks>
		<testThatItXFoldrWorks public="1" set="method" line="28"><f a=""><e path="Void"/></f></testThatItXFoldrWorks>
		<testThatItXReversedWorks public="1" set="method" line="36"><f a=""><e path="Void"/></f></testThatItXReversedWorks>
		<testThatItXHeadWorks public="1" set="method" line="42"><f a=""><e path="Void"/></f></testThatItXHeadWorks>
		<testThatItXAppendWorks public="1" set="method" line="48"><f a=""><e path="Void"/></f></testThatItXAppendWorks>
		<testThatItXTailWorks public="1" set="method" line="54"><f a=""><e path="Void"/></f></testThatItXTailWorks>
		<testThatItXTakeWorks public="1" set="method" line="60"><f a=""><e path="Void"/></f></testThatItXTakeWorks>
		<testThatItXDropWorks public="1" set="method" line="74"><f a=""><e path="Void"/></f></testThatItXDropWorks>
		<testThatItXExistsWorks public="1" set="method" line="84"><f a=""><e path="Void"/></f></testThatItXExistsWorks>
		<testThatItXNubWorks public="1" set="method" line="92"><f a=""><e path="Void"/></f></testThatItXNubWorks>
		<testThatItXAtWorks public="1" set="method" line="98"><f a=""><e path="Void"/></f></testThatItXAtWorks>
		<testThatItXMapWorks public="1" set="method" line="106"><f a=""><e path="Void"/></f></testThatItXMapWorks>
		<testThatItXScanlWorks public="1" set="method" line="112"><f a=""><e path="Void"/></f></testThatItXScanlWorks>
		<testThatItXScanl1Works public="1" set="method" line="118"><f a=""><e path="Void"/></f></testThatItXScanl1Works>
		<testThatItXScanrWorks public="1" set="method" line="124"><f a=""><e path="Void"/></f></testThatItXScanrWorks>
		<testThatItXScanr1Works public="1" set="method" line="130"><f a=""><e path="Void"/></f></testThatItXScanr1Works>
		<new public="1" set="method" line="11"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.test.resources.BCollectionTester" params="" file="../src/main/haxe/haxe/test/resources/BCollectionTester.hx"><main public="1" set="method" line="139" static="1"><f a=""><e path="Void"/></f></main></class>
	<class path="haxe.reactive.Signals" params="" file="../src/main/haxe/haxe/reactive/Signals.hx">
		<constant public="1" params="T" set="method" line="27" static="1"><f a="value">
	<c path="constant.T"/>
	<c path="haxe.reactive.Signal"><c path="constant.T"/></c>
</f></constant>
		<cond public="1" params="T" set="method" line="48" static="1">
			<f a="conditions:elseS">
				<t path="Iterable"><c path="Tuple2">
	<c path="haxe.reactive.Signal"><e path="Bool"/></c>
	<c path="haxe.reactive.Signal"><c path="cond.T"/></c>
</c></t>
				<c path="haxe.reactive.Signal"><c path="cond.T"/></c>
				<c path="haxe.reactive.Signal"><c path="cond.T"/></c>
			</f>
			<haxe_doc>
     * Switches off a supplied Bool Signal, returning
     * an 'ifTrue' Signal if true or a 'ifFalse' 
     * Signal if false.
     * 
     *
     * @param conditions    An Iterable of Tuple2s, composed of a
     *                      true/false Signals and an 'if true' 
     *                      Signal that will be returned if 
     *                      Tuple._1 == 'true.'
     *
     * @param elseS         The Signal to return if Tuple._1
     *                      == false.
     *
     * @return              An 'ifTrue' Signal if Tuple._1
     *                      == true, else an 'ifFalse' Signal.
     </haxe_doc>
		</cond>
		<zipN public="1" params="T" set="method" line="61" static="1">
			<f a="signals">
				<t path="Iterable"><c path="haxe.reactive.Signal"><c path="zipN.T"/></c></t>
				<c path="haxe.reactive.Signal"><t path="Iterable"><c path="zipN.T"/></t></c>
			</f>
			<haxe_doc>
     * Zips together the specified Signals.
     *
     *@param    signals   An Iterable of the 
     *                      Signals to be zipped.
     </haxe_doc>
		</zipN>
		<sample public="1" set="method" line="79" static="1">
			<f a="time">
				<c path="Int"/>
				<c path="haxe.reactive.Signal"><c path="Int"/></c>
			</f>
			<haxe_doc>
     * Returns the time at a specified time step interval.
     *
     * @param time      The interval at which to sample time.
     </haxe_doc>
		</sample>
		<sampleS public="1" set="method" line="88" static="1">
			<f a="time">
				<c path="haxe.reactive.Signal"><c path="Int"/></c>
				<c path="haxe.reactive.Signal"><c path="Int"/></c>
			</f>
			<haxe_doc>
     * Returns the time step at a specified intverval.
     *
     * @param time      The interval at which to sample time.
     </haxe_doc>
		</sampleS>
		<new set="method" line="25"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Enum" params="T" file="C:\World\Stack\os\win\programs\lingos\haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="haxe.test.ui.common.PackageResult" params="" file="../src/main/haxe/haxe/test/ui/common/PackageResult.hx">
		<packageName public="1" set="null"><c path="String"/></packageName>
		<classes><c path="Hash"><c path="haxe.test.ui.common.ClassResult"/></c></classes>
		<packages><c path="Hash"><c path="haxe.test.ui.common.PackageResult"/></c></packages>
		<stats public="1" set="null"><c path="haxe.test.ui.common.ResultStats"/></stats>
		<addResult public="1" set="method" line="39"><f a="result:flattenPackage">
	<c path="haxe.test.TestResult"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addResult>
		<addClass public="1" set="method" line="46"><f a="result">
	<c path="haxe.test.ui.common.ClassResult"/>
	<e path="Void"/>
</f></addClass>
		<addPackage public="1" set="method" line="51"><f a="result">
	<c path="haxe.test.ui.common.PackageResult"/>
	<e path="Void"/>
</f></addPackage>
		<existsPackage public="1" set="method" line="56"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></existsPackage>
		<existsClass public="1" set="method" line="60"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></existsClass>
		<getPackage public="1" set="method" line="64"><f a="name">
	<c path="String"/>
	<c path="haxe.test.ui.common.PackageResult"/>
</f></getPackage>
		<getClass public="1" set="method" line="69"><f a="name">
	<c path="String"/>
	<t path="Null"><c path="haxe.test.ui.common.ClassResult"/></t>
</f></getClass>
		<classNames public="1" set="method" line="73"><f a="?errorsHavePriority">
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></classNames>
		<packageNames public="1" set="method" line="106"><f a="?errorsHavePriority">
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></packageNames>
		<createFixture set="method" line="140"><f a="method:assertations">
	<c path="String"/>
	<t path="Iterable"><e path="haxe.test.Assertation"/></t>
	<c path="haxe.test.ui.common.FixtureResult"/>
</f></createFixture>
		<getOrCreateClass set="method" line="147"><f a="pack:cls:setup:teardown">
	<c path="haxe.test.ui.common.PackageResult"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<t path="Null"><c path="haxe.test.ui.common.ClassResult"/></t>
</f></getOrCreateClass>
		<getOrCreatePackage set="method" line="154"><f a="pack:flat:ref">
	<c path="String"/>
	<e path="Bool"/>
	<c path="haxe.test.ui.common.PackageResult"/>
	<c path="haxe.test.ui.common.PackageResult"/>
</f></getOrCreatePackage>
		<new public="1" set="method" line="32"><f a="packageName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
* @todo add documentation
* @todo add tests for this class
</haxe_doc>
	</class>
	<enum path="haxe.test.ui.common.HeaderDisplayMode" params="" file="../src/main/haxe/haxe/test/ui/common/HeaderDisplayMode.hx">
		<ShowHeaderWithResults/>
		<NeverShowHeader/>
		<AlwaysShowHeader/>
	</enum>
	<enum path="haxe.test.ui.common.SuccessResultsDisplayMode" params="" file="../src/main/haxe/haxe/test/ui/common/HeaderDisplayMode.hx" module="haxe.test.ui.common.HeaderDisplayMode">
		<ShowSuccessResultsWithNoErrors/>
		<NeverShowSuccessResults/>
		<AlwaysShowSuccessResults/>
	</enum>
	<class path="haxe.reactive.SignalInt" params="" file="../src/main/haxe/haxe/reactive/SignalInt.hx">
		<plus public="1" set="method" line="23" static="1"><f a="b:value">
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="Int"/>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></plus>
		<plusS public="1" set="method" line="27" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></plusS>
		<minusS public="1" set="method" line="31" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></minusS>
		<minus public="1" set="method" line="35" static="1"><f a="b:value">
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="Int"/>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></minus>
		<timesS public="1" set="method" line="39" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></timesS>
		<times public="1" set="method" line="43" static="1"><f a="b:value">
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="Int"/>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></times>
		<modS public="1" set="method" line="47" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></modS>
		<mod public="1" set="method" line="51" static="1"><f a="b:value">
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="Int"/>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></mod>
		<dividedByS public="1" set="method" line="55" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></dividedByS>
		<dividedBy public="1" set="method" line="59" static="1"><f a="b:value">
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="Int"/>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></dividedBy>
		<abs public="1" set="method" line="63" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></abs>
		<negate public="1" set="method" line="67" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></negate>
		<toFloat public="1" set="method" line="71" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
	<c path="haxe.reactive.Signal"><c path="Float"/></c>
</f></toFloat>
		<new set="method" line="21"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/haxe/io/BytesData.hx"><c path="neko.NativeString"/></typedef>
	<typedef path="haxe.data.transcode.JExtractorFunction" params="T" file="../src/main/haxe/haxe/data/transcode/TranscodeJValue.hx" module="haxe.data.transcode.TranscodeJValue">
		<t path="Function">
			<e path="haxe.text.json.JValue"/>
			<c path="haxe.data.transcode.JExtractorFunction.T"/>
		</t>
		<haxe_doc>
 * The extractors and decomposers in this file have been created to comply with
 * the serialization requirements of XSchema.
 </haxe_doc>
	</typedef>
	<typedef path="haxe.data.transcode.JDecomposerFunction" params="T" file="../src/main/haxe/haxe/data/transcode/TranscodeJValue.hx" module="haxe.data.transcode.TranscodeJValue"><t path="Function">
	<c path="haxe.data.transcode.JDecomposerFunction.T"/>
	<e path="haxe.text.json.JValue"/>
</t></typedef>
	<typedef path="haxe.net.HttpHeader" params="" file="../src/main/haxe/haxe/net/HttpHeader.hx"><c path="Tuple2">
	<c path="String"/>
	<c path="String"/>
</c></typedef>
	<typedef path="haxe.net.HttpHeaders" params="" file="../src/main/haxe/haxe/net/HttpHeader.hx" module="haxe.net.HttpHeader"><c path="haxe.data.collections.Map">
	<c path="String"/>
	<c path="String"/>
</c></typedef>
	<class path="haxe.test.Assert" params="" file="../src/main/haxe/haxe/test/Assert.hx">
		<results public="1" static="1">
			<c path="List"><e path="haxe.test.Assertation"/></c>
			<haxe_doc>
  * A stack of results for the current testing workflow. It is used internally
  * by other classes of the utest library.
  </haxe_doc>
		</results>
		<that public="1" params="T" set="method" line="52" static="1">
			<f a="obj:cond:?msg:?pos">
				<c path="that.T"/>
				<t path="haxe.test.MustMatcher"><c path="that.T"/></t>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
   * Asserts that the specified condition holds.
   * <pre>
   * Assert.that(2, Must.equal(1).or(Must.beNull())); // Fails with: 'Expected: ((x == 1) || (x == null)), Found: x == 2'
   * </pre>
   ]]></haxe_doc>
		</that>
		<isTrue public="1" set="method" line="66" static="1">
			<f a="cond:?msg:?pos">
				<e path="Bool"/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
  * Asserts successfully when the condition is true.
  * @param cond: The condition to test
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  </haxe_doc>
		</isTrue>
		<isFalse public="1" set="method" line="82" static="1">
			<f a="value:?msg:?pos">
				<e path="Bool"/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
  * Asserts successfully when the condition is false.
  * @param cond: The condition to test
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  </haxe_doc>
		</isFalse>
		<isNull public="1" set="method" line="94" static="1">
			<f a="value:?msg:?pos">
				<d/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
  * Asserts successfully when the value is null.
  * @param value: The value to test
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  </haxe_doc>
		</isNull>
		<notNull public="1" set="method" line="106" static="1">
			<f a="value:?msg:?pos">
				<d/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
  * Asserts successfully when the value is not null.
  * @param value: The value to test
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  </haxe_doc>
		</notNull>
		<is public="1" set="method" line="119" static="1">
			<f a="value:type:?msg:?pos">
				<d/>
				<d/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
  * Asserts successfully when the 'value' parameter is of the of the passed type 'type'.
  * @param value: The value to test
  * @param type: The type to test against
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  </haxe_doc>
		</is>
		<notEquals public="1" set="method" line="135" static="1">
			<f a="expected:value:?msg:?pos">
				<d/>
				<d/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
  * Asserts successfully when the value parameter is not the same as the expected one.
  * <pre>
  * Assert.notEquals(10, age);
  * </pre>
  * @param expected: The expected value to check against
  * @param value: The value to test
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  ]]></haxe_doc>
		</notEquals>
		<equals public="1" params="T" set="method" line="151" static="1">
			<f a="expected:value:?equal:?msg:?pos">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<t path="EqualFunction"><c path="equals.T"/></t>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
  * Asserts successfully when the value parameter is equal to the expected one.
  * <pre>
  * Assert.equals(10, age);
  * </pre>
  * @param expected: The expected value to check against
  * @param value: The value to test
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  ]]></haxe_doc>
		</equals>
		<matches public="1" set="method" line="169" static="1">
			<f a="pattern:value:?msg:?pos">
				<c path="EReg"/>
				<d/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
  * Asserts successfully when the value parameter does match against the passed EReg instance.
  * <pre>
  * Assert.match(~/x/i, "haXe");
  * </pre>
  * @param pattern: The pattern to match against
  * @param value: The value to test
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  ]]></haxe_doc>
		</matches>
		<floatEquals public="1" set="method" line="187" static="1">
			<f a="expected:value:?approx:?msg:?pos">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
  * Same as Assert.equals but considering an approximation error.
  * <pre>
  * Assert.floatEquals(Math.PI, value);
  * </pre>
  * @param expected: The expected value to check against
  * @param value: The value to test
  * @param approx: The approximation tollerance. Default is 1e-5
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  * @todo test the approximation argument
  ]]></haxe_doc>
		</floatEquals>
		<getTypeName set="method" line="201" static="1"><f a="v">
	<d/>
	<c path="String"/>
</f></getTypeName>
		<isIterable set="method" line="216" static="1"><f a="v:isAnonym">
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></isIterable>
		<isIterator set="method" line="222" static="1"><f a="v:isAnonym">
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></isIterator>
		<sameAs set="method" line="228" static="1"><f a="expected:value:status">
	<d/>
	<d/>
	<t path="haxe.test._Assert.LikeStatus"/>
	<e path="Bool"/>
</f></sameAs>
		<q set="method" line="482" static="1"><f a="v">
	<d/>
	<c path="String"/>
</f></q>
		<looksLike public="1" set="method" line="506" static="1">
			<f a="expected:value:?recursive:?msg:?pos">
				<d/>
				<d/>
				<e path="Bool"/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
  * Check that value is an object with the same fields and values found in expected.
  * The default behavior is to check nested objects in fields recursively.
  * <pre>
  * Assert.same({ name : "utest"}, ob);
  * </pre>
  * @param expected: The expected value to check against
  * @param value: The value to test
  * @param recursive: States whether or not the test will apply also to sub-objects.
  * Defaults to true
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  ]]></haxe_doc>
		</looksLike>
		<throwsException public="1" set="method" line="531" static="1">
			<f a="method:?type:?msg:?pos">
				<f a=""><e path="Void"/></f>
				<c path="Class"><d/></c>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
  * It is used to test an application that under certain circumstances must
  * react throwing an error. This assert guarantees that the error is of the
  * correct type (or Dynamic if non is specified).
  * <pre>
  * Assert.throwsException(function() { throw "Error!"; }, String);
  * </pre>
  * @param method: A method that generates the exception.
  * @param type: The type of the expected error. Defaults to Dynamic (catch all).
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  * @todo test the optional type parameter
  ]]></haxe_doc>
		</throwsException>
		<equalsOneOf public="1" params="T" set="method" line="553" static="1">
			<f a="value:possibilities:?msg:?pos">
				<c path="equalsOneOf.T"/>
				<c path="Array"><c path="equalsOneOf.T"/></c>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
  * Checks that the test value matches at least one of the possibilities.
  * @param possibility: An array of mossible matches
  * @param value: The value to test
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  </haxe_doc>
		</equalsOneOf>
		<contains public="1" params="T" set="method" line="568" static="1">
			<f a="values:match:?msg:?pos">
				<t path="Iterable"><c path="contains.T"/></t>
				<c path="contains.T"/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
  * Checks that the test array contains the match parameter.
  * @param match: The element that must be included in the tested array
  * @param values: The values to test
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  </haxe_doc>
		</contains>
		<notContains public="1" params="T" set="method" line="584" static="1">
			<f a="values:match:?msg:?pos">
				<t path="Iterable"><c path="notContains.T"/></t>
				<c path="notContains.T"/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
  * Checks that the test array does not contain the match parameter.
  * @param match: The element that must NOT be included in the tested array
  * @param values: The values to test
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  </haxe_doc>
		</notContains>
		<stringContains public="1" set="method" line="599" static="1">
			<f a="match:value:?msg:?pos">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
   * Checks that the expected values is contained in value.
   * @param match: the string value that must be contained in value
   * @param value: the value to test
   * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
   </haxe_doc>
		</stringContains>
		<stringSequence public="1" set="method" line="607" static="1"><f a="sequence:value:?msg:?pos">
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></stringSequence>
		<fail public="1" set="method" line="645" static="1">
			<f a="?msg:?pos">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
  * Forces a failure.
  * @param msg: An optional error message. If not passed a default one will be used
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  </haxe_doc>
		</fail>
		<warn public="1" set="method" line="654" static="1">
			<f a="msg">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
  * Creates a warning message.
  * @param msg: A mandatory message that justifies the warning.
  * @param pos: Code position where the Assert call has been executed. Don't fill it
  * unless you know what you are doing.
  </haxe_doc>
		</warn>
		<createAsync public="1" set="dynamic" line="669" static="1">
			<f a="f:?timeout">
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<f a=""><e path="Void"/></f>
			</f>
			<haxe_doc><![CDATA[
  * Creates an asynchronous context for test execution. Assertions should be included
  * in the passed function.
  * <pre>
  * public function assertAsync() {
  *   var async = Assert.createAsync(function() Assert.isTrue(true));
  *   haxe.Timer.delay(async, 50);
  * }
  * @param f: A function that contains other Assert tests
  * @param timeout: Optional timeout value in milliseconds.
  ]]></haxe_doc>
		</createAsync>
		<delivered public="1" params="T" set="method" line="678" static="1">
			<f a="future:assertions:?timeout">
				<c path="Future"><c path="delivered.T"/></c>
				<f a="">
					<c path="delivered.T"/>
					<e path="Void"/>
				</f>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc> Asserts the future is delivered within the specified time frame. All 
   * assertions relating to the deliverable should be contained within the 
   * passed in function.
   </haxe_doc>
		</delivered>
		<canceled public="1" params="T" set="method" line="696" static="1">
			<f a="future:assertions:?timeout">
				<c path="Future"><c path="canceled.T"/></c>
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc> Asserts the future is canceled within the specified time frame. All 
   * assertions should be contained within the passed in function.
   </haxe_doc>
		</canceled>
		<notDelivered public="1" params="T" set="method" line="702" static="1">
			<f a="future:?timeout:?pos">
				<c path="Future"><c path="notDelivered.T"/></c>
				<c path="Int"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc> Asserts the future is not delivered within the specified time frame.
   </haxe_doc>
		</notDelivered>
		<createEvent public="1" params="EventArg" set="dynamic" line="736" static="1">
			<f a="f:?timeout">
				<f a="">
					<c path="createEvent.EventArg"/>
					<e path="Void"/>
				</f>
				<c path="Int"/>
				<f a="e">
					<unknown/>
					<e path="Void"/>
				</f>
			</f>
			<haxe_doc>
  * Creates an asynchronous context for test execution of an event like method.
  * Assertions should be included in the passed function.
  * It works the same way as Assert.assertAsync() but accepts a function with one
  * argument (usually some event data) instead of a function with no arguments
  * @param f: A function that contains other Assert tests
  * @param timeout: Optional timeout value in milliseconds.
  </haxe_doc>
		</createEvent>
		<typeToString set="method" line="740" static="1"><f a="t">
	<d/>
	<c path="String"/>
</f></typeToString>
		<haxe_doc><![CDATA[
* This class contains only static members used to perform assertations inside a test method.
* It's use is straight forward:
* <pre>
* public function testObvious() {
*   Assert.equals(1, 0); // fails
*   Assert.isFalse(1 == 1, "guess what?"); // fails and returns the passed message
*   Assert.isTrue(true); // successfull
* }
* </pre>
]]></haxe_doc>
	</class>
	<typedef path="haxe.test._Assert.LikeStatus" params="" file="../src/main/haxe/haxe/test/Assert.hx" private="1" module="haxe.test.Assert"><a>
	<recursive><e path="Bool"/></recursive>
	<path><c path="String"/></path>
	<error><c path="String"/></error>
</a></typedef>
	<typedef path="haxe.functional.PartialFunction" params="A:Z" file="../src/main/haxe/haxe/functional/PartialFunction.hx"><c path="haxe.functional.PartialFunction1">
	<c path="haxe.functional.PartialFunction.A"/>
	<c path="haxe.functional.PartialFunction.Z"/>
</c></typedef>
	<class path="haxe.test.ui.text.PlainTextReport" params="" file="../src/main/haxe/haxe/test/ui/text/PlainTextReport.hx">
		<implements path="haxe.test.ui.common.IReport"><c path="haxe.test.ui.text.PlainTextReport"/></implements>
		<displaySuccessResults public="1"><e path="haxe.test.ui.common.SuccessResultsDisplayMode"/></displaySuccessResults>
		<displayHeader public="1"><e path="haxe.test.ui.common.HeaderDisplayMode"/></displayHeader>
		<handler public="1"><f a="">
	<c path="haxe.test.ui.text.PlainTextReport"/>
	<e path="Void"/>
</f></handler>
		<aggregator><c path="haxe.test.ui.common.ResultAggregator"/></aggregator>
		<newline><c path="String"/></newline>
		<indent><c path="String"/></indent>
		<setHandler public="1" set="method" line="51"><f a="handler">
	<f a="">
		<c path="haxe.test.ui.text.PlainTextReport"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setHandler>
		<startTime><c path="Float"/></startTime>
		<start set="method" line="56"><f a="e">
	<c path="haxe.test.Runner"/>
	<e path="Void"/>
</f></start>
		<indents set="method" line="60"><f a="c">
	<c path="Int"/>
	<c path="String"/>
</f></indents>
		<dumpStack set="method" line="67"><f a="stack">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<c path="String"/>
</f></dumpStack>
		<addHeader set="method" line="80"><f a="buf:result">
	<c path="StringBuf"/>
	<c path="haxe.test.ui.common.PackageResult"/>
	<e path="Void"/>
</f></addHeader>
		<result><c path="haxe.test.ui.common.PackageResult"/></result>
		<getResults public="1" set="method" line="105"><f a=""><c path="String"/></f></getResults>
		<complete set="method" line="165"><f a="result">
	<c path="haxe.test.ui.common.PackageResult"/>
	<e path="Void"/>
</f></complete>
		<new public="1" set="method" line="41"><f a="runner:?outputHandler">
	<c path="haxe.test.Runner"/>
	<f a="">
		<c path="haxe.test.ui.text.PlainTextReport"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
		<haxe_doc>
* @todo add documentation
</haxe_doc>
	</class>
	<class path="haxe.test.ui.text.PrintReport" params="" file="../src/main/haxe/haxe/test/ui/text/PrintReport.hx">
		<extends path="haxe.test.ui.text.PlainTextReport"/>
		<useTrace><e path="Bool"/></useTrace>
		<_handler set="method" line="58"><f a="report">
	<c path="haxe.test.ui.text.PlainTextReport"/>
	<e path="Void"/>
</f></_handler>
		<_trace set="method" line="78"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></_trace>
		<_print set="method" line="84"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></_print>
		<new public="1" set="method" line="40"><f a="runner:?useTrace">
	<c path="haxe.test.Runner"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
* @todo add documentation
</haxe_doc>
	</class>
	<class path="DateTools" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/DateTools.hx">
		<date_format line="36" static="1"><f a=":">
	<d/>
	<unknown/>
	<unknown/>
</f></date_format>
		<format public="1" set="method" line="116" static="1">
			<f a="d:f">
				<c path="Date"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Format the date [d] according to the format [f]. The format
		is compatible with the [strftime] standard format, except that there
		is no support in Flash and JS for day and months names (due to lack
		of proper internationalization API). On haXe/Neko/Windows, some
		formats are not supported.
	</haxe_doc>
		</format>
		<delta public="1" set="method" line="129" static="1">
			<f a="d:t">
				<c path="Date"/>
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date which time has been changed by [t] milliseconds.
	</haxe_doc>
		</delta>
		<DAYS_OF_MONTH line="133" static="1"><c path="Array"><c path="Int"/></c></DAYS_OF_MONTH>
		<getMonthDays public="1" set="method" line="138" static="1">
			<f a="d">
				<c path="Date"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the number of days in a month
	</haxe_doc>
		</getMonthDays>
		<seconds public="1" set="method" line="152" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of seconds to a date-time
	</haxe_doc>
		</seconds>
		<minutes public="1" set="method" line="159" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of minutes to a date-time
	</haxe_doc>
		</minutes>
		<hours public="1" set="method" line="166" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of hours to a date-time
	</haxe_doc>
		</hours>
		<days public="1" set="method" line="173" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of days to a date-time
	</haxe_doc>
		</days>
		<parse public="1" set="method" line="180" static="1">
			<f a="t">
				<c path="Float"/>
				<a>
					<seconds><c path="Int"/></seconds>
					<ms><c path="Float"/></ms>
					<minutes><c path="Int"/></minutes>
					<hours><c path="Int"/></hours>
					<days><c path="Int"/></days>
				</a>
			</f>
			<haxe_doc>
		Separate a date-time into several components
	</haxe_doc>
		</parse>
		<make public="1" set="method" line="196" static="1">
			<f a="o">
				<a>
					<seconds><c path="Int"/></seconds>
					<ms><c path="Float"/></ms>
					<minutes><c path="Int"/></minutes>
					<hours><c path="Int"/></hours>
					<days><c path="Int"/></days>
				</a>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Build a date-time from several components
	</haxe_doc>
		</make>
		<haxe_doc>
	The DateTools class contains some extra functionalities for [Date]
	manipulation. It's stored in a different class in order to prevent
	the standard [Date] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="43" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<class path="haxe.data.collections.Maps" params="" file="../src/main/haxe/haxe/data/collections/Maps.hx"/>
	<class path="haxe.reactive.SignalCollectionExtensions" params="" file="../src/main/haxe/haxe/reactive/SignalCollectionExtensions.hx">
		<concatS public="1" params="C:T" set="method" line="31" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="concatS.C"/>
	<c path="concatS.T"/>
</c></c>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="concatS.C"/>
	<c path="concatS.T"/>
</c></c>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="concatS.C"/>
	<c path="concatS.T"/>
</c></c>
</f></concatS>
		<join public="1" params="C:T" set="method" line="35" static="1"><f a="b:char">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="join.C"/>
	<c path="join.T"/>
</c></c>
	<c path="String"/>
	<c path="haxe.reactive.Signal"><c path="String"/></c>
</f></join>
		<size public="1" params="C:T" set="method" line="39" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="size.C"/>
	<c path="size.T"/>
</c></c>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></size>
		<zipS public="1" params="C:T:B" set="method" line="43" static="1"><f a="b1:b2">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.List"><c path="zipS.T"/></c></c>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.List"><c path="zipS.B"/></c></c>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.List"><c path="Tuple2">
	<c path="zipS.T"/>
	<c path="zipS.B"/>
</c></c></c>
</f></zipS>
		<append public="1" params="C:T" set="method" line="47" static="1"><f a="b:element">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="append.C"/>
	<c path="append.T"/>
</c></c>
	<c path="append.T"/>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="append.C"/>
	<c path="append.T"/>
</c></c>
</f></append>
		<count public="1" params="C:T" set="method" line="51" static="1"><f a="b:predicate">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="count.C"/>
	<c path="count.T"/>
</c></c>
	<f a="">
		<c path="count.T"/>
		<e path="Bool"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="Int"/></c>
</f></count>
		<all public="1" params="C:T" set="method" line="55" static="1"><f a="b:tester">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="all.C"/>
	<c path="all.T"/>
</c></c>
	<f a="">
		<c path="all.T"/>
		<e path="Bool"/>
	</f>
	<c path="haxe.reactive.Signal"><e path="Bool"/></c>
</f></all>
		<any public="1" params="C:T" set="method" line="59" static="1"><f a="b:tester">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="any.C"/>
	<c path="any.T"/>
</c></c>
	<f a="">
		<c path="any.T"/>
		<e path="Bool"/>
	</f>
	<c path="haxe.reactive.Signal"><e path="Bool"/></c>
</f></any>
		<forEach public="1" params="C:T" set="method" line="63" static="1"><f a="b:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="forEach.C"/>
	<c path="forEach.T"/>
</c></c>
	<f a="">
		<c path="forEach.T"/>
		<e path="Void"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="forEach.C"/>
	<c path="forEach.T"/>
</c></c>
</f></forEach>
		<each public="1" params="C:T" set="method" line="67" static="1"><f a="b:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="each.C"/>
	<c path="each.T"/>
</c></c>
	<f a="">
		<c path="each.T"/>
		<e path="Void"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="each.C"/>
	<c path="each.T"/>
</c></c>
</f></each>
		<map public="1" params="C:T" set="method" line="71" static="1"><f a="b:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="map.C"/>
	<c path="map.T"/>
</c></c>
	<f a="">
		<c path="map.T"/>
		<c path="map.T"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="map.C"/>
	<c path="map.T"/>
</c></c>
</f></map>
		<mapTo public="1" params="C:T:Z" set="method" line="75" static="1"><f a="b:t:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="mapTo.C"/>
	<c path="mapTo.T"/>
</c></c>
	<c path="haxe.data.collections.Collection">
		<c path="mapTo.C"/>
		<c path="mapTo.Z"/>
	</c>
	<f a="">
		<c path="mapTo.T"/>
		<c path="mapTo.Z"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="mapTo.C"/>
	<c path="mapTo.Z"/>
</c></c>
</f></mapTo>
		<partition public="1" params="C:T" set="method" line="79" static="1"><f a="b:filter">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="partition.C"/>
	<c path="partition.T"/>
</c></c>
	<f a="">
		<c path="partition.T"/>
		<e path="Bool"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="Tuple2">
	<c path="haxe.data.collections.Collection">
		<c path="partition.C"/>
		<c path="partition.T"/>
	</c>
	<c path="haxe.data.collections.Collection">
		<c path="partition.C"/>
		<c path="partition.T"/>
	</c>
</c></c>
</f></partition>
		<filter public="1" params="C:T" set="method" line="83" static="1"><f a="b:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="filter.C"/>
	<c path="filter.T"/>
</c></c>
	<f a="">
		<c path="filter.T"/>
		<e path="Bool"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="filter.C"/>
	<c path="filter.T"/>
</c></c>
</f></filter>
		<flatMap public="1" params="C:T" set="method" line="87" static="1"><f a="b:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="flatMap.C"/>
	<c path="flatMap.T"/>
</c></c>
	<f a="">
		<c path="flatMap.T"/>
		<c path="haxe.data.collections.Collection">
			<c path="flatMap.C"/>
			<c path="flatMap.T"/>
		</c>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="flatMap.C"/>
	<c path="flatMap.T"/>
</c></c>
</f></flatMap>
		<toArray public="1" params="C:T" set="method" line="92" static="1"><f a="b">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="toArray.C"/>
	<c path="toArray.T"/>
</c></c>
	<c path="haxe.reactive.Signal"><c path="Array"><c path="toArray.T"/></c></c>
</f></toArray>
		<foldr public="1" params="C:T:Z" set="method" line="96" static="1"><f a="b:initial:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="foldr.C"/>
	<c path="foldr.T"/>
</c></c>
	<c path="foldr.Z"/>
	<f a=":">
		<c path="foldr.T"/>
		<c path="foldr.Z"/>
		<c path="foldr.Z"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="foldr.Z"/></c>
</f></foldr>
		<foldl public="1" params="C:T:Z" set="method" line="100" static="1"><f a="b:initial:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="foldl.C"/>
	<c path="foldl.T"/>
</c></c>
	<c path="foldl.Z"/>
	<f a=":">
		<c path="foldl.Z"/>
		<c path="foldl.T"/>
		<c path="foldl.Z"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="foldl.Z"/></c>
</f></foldl>
		<scanl public="1" params="C:T" set="method" line="104" static="1"><f a="b:initial:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="scanl.C"/>
	<c path="scanl.T"/>
</c></c>
	<c path="scanl.T"/>
	<f a=":">
		<c path="scanl.T"/>
		<c path="scanl.T"/>
		<c path="scanl.T"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="scanl.C"/>
	<c path="scanl.T"/>
</c></c>
</f></scanl>
		<scanr public="1" params="C:T" set="method" line="108" static="1"><f a="b:initial:f">
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="scanr.C"/>
	<c path="scanr.T"/>
</c></c>
	<c path="scanr.T"/>
	<f a=":">
		<c path="scanr.T"/>
		<c path="scanr.T"/>
		<c path="scanr.T"/>
	</f>
	<c path="haxe.reactive.Signal"><c path="haxe.data.collections.Collection">
	<c path="scanr.C"/>
	<c path="scanr.T"/>
</c></c>
</f></scanr>
		<new set="method" line="27"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Hash" params="T" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/Hash.hx">
		<h><d/></h>
		<set public="1" get="inline" set="null" line="34">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="38">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="42">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" get="inline" set="null" line="46">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="50">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="56">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="62">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="30"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="haxe.test.mock.Mock" params="T" file="../src/main/haxe/haxe/test/mock/Mock.hx">
		<internal_create public="1" params="T" set="method" line="152" static="1"><f a="c">
	<c path="Class"><c path="internal_create.T"/></c>
	<c path="haxe.test.mock.Mock"><c path="internal_create.T"/></c>
</f></internal_create>
		<_expects><c path="haxe.data.collections.Map">
	<c path="String"/>
	<c path="Array"><d/></c>
</c></_expects>
		<_target><c path="haxe.test.mock.Mock.T"/></_target>
		<target public="1" get="getTarget" set="null"><c path="haxe.test.mock.Mock.T"/></target>
		<expect1 public="1" params="P1:R" set="method" line="38"><f a="name:f:?times">
	<c path="String"/>
	<t path="Function">
		<c path="expect1.P1"/>
		<c path="expect1.R"/>
	</t>
	<c path="Int"/>
	<e path="Void"/>
</f></expect1>
		<expect2 public="1" params="P1:P2:R" set="method" line="50"><f a="name:f:?times">
	<c path="String"/>
	<t path="Function2">
		<c path="expect2.P1"/>
		<c path="expect2.P2"/>
		<c path="expect2.R"/>
	</t>
	<c path="Int"/>
	<e path="Void"/>
</f></expect2>
		<expect3 public="1" params="P1:P2:P3:R" set="method" line="62"><f a="name:f:?times">
	<c path="String"/>
	<t path="Function3">
		<c path="expect3.P1"/>
		<c path="expect3.P2"/>
		<c path="expect3.P3"/>
		<c path="expect3.R"/>
	</t>
	<c path="Int"/>
	<e path="Void"/>
</f></expect3>
		<expect4 public="1" params="P1:P2:P3:P4:R" set="method" line="74"><f a="name:f:?times">
	<c path="String"/>
	<t path="Function4">
		<c path="expect4.P1"/>
		<c path="expect4.P2"/>
		<c path="expect4.P3"/>
		<c path="expect4.P4"/>
		<c path="expect4.R"/>
	</t>
	<c path="Int"/>
	<e path="Void"/>
</f></expect4>
		<expect5 public="1" params="P1:P2:P3:P4:P5:R" set="method" line="86"><f a="name:f:?times">
	<c path="String"/>
	<t path="Function5">
		<c path="expect5.P1"/>
		<c path="expect5.P2"/>
		<c path="expect5.P3"/>
		<c path="expect5.P4"/>
		<c path="expect5.P5"/>
		<c path="expect5.R"/>
	</t>
	<c path="Int"/>
	<e path="Void"/>
</f></expect5>
		<allow1 public="1" params="P1:R" set="method" line="98"><f a="name:f">
	<c path="String"/>
	<t path="Function">
		<c path="allow1.P1"/>
		<c path="allow1.R"/>
	</t>
	<e path="Void"/>
</f></allow1>
		<allow2 public="1" params="P1:P2:R" set="method" line="102"><f a="name:f">
	<c path="String"/>
	<t path="Function2">
		<c path="allow2.P1"/>
		<c path="allow2.P2"/>
		<c path="allow2.R"/>
	</t>
	<e path="Void"/>
</f></allow2>
		<allow3 public="1" params="P1:P2:P3:R" set="method" line="106"><f a="name:f">
	<c path="String"/>
	<t path="Function3">
		<c path="allow3.P1"/>
		<c path="allow3.P2"/>
		<c path="allow3.P3"/>
		<c path="allow3.R"/>
	</t>
	<e path="Void"/>
</f></allow3>
		<allow4 public="1" params="P1:P2:P3:P4:R" set="method" line="110"><f a="name:f">
	<c path="String"/>
	<t path="Function4">
		<c path="allow4.P1"/>
		<c path="allow4.P2"/>
		<c path="allow4.P3"/>
		<c path="allow4.P4"/>
		<c path="allow4.R"/>
	</t>
	<e path="Void"/>
</f></allow4>
		<allow5 public="1" params="P1:P2:P3:P4:P5:R" set="method" line="114"><f a="name:f">
	<c path="String"/>
	<t path="Function5">
		<c path="allow5.P1"/>
		<c path="allow5.P2"/>
		<c path="allow5.P3"/>
		<c path="allow5.P4"/>
		<c path="allow5.P5"/>
		<c path="allow5.R"/>
	</t>
	<e path="Void"/>
</f></allow5>
		<verifyAllExpectations public="1" set="method" line="118"><f a=""><e path="Void"/></f></verifyAllExpectations>
		<getTarget set="method" line="128"><f a=""><c path="haxe.test.mock.Mock.T"/></f></getTarget>
		<internal_add set="method" line="132"><f a="name:f">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></internal_add>
		<internal_remove set="method" line="142"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></internal_remove>
		<new set="method" line="33"><f a="c">
	<c path="Class"><c path="haxe.test.mock.Mock.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.test.mock.MockTestCase" params="" file="../src/main/haxe/haxe/test/mock/Mock.hx" module="haxe.test.mock.Mock">
		<extends path="haxe.test.TestCase"/>
		<_localMocks><c path="Array"><c path="haxe.test.mock.Mock"><d/></c></c></_localMocks>
		<_globalMocks><c path="Array"><c path="haxe.test.mock.Mock"><d/></c></c></_globalMocks>
		<_runningTest><e path="Bool"/></_runningTest>
		<before public="1" set="method" line="167" override="1"><f a=""><e path="Void"/></f></before>
		<newMock public="1" params="T" set="method" line="172"><f a="c">
	<c path="Class"><c path="newMock.T"/></c>
	<c path="haxe.test.mock.Mock"><c path="newMock.T"/></c>
</f></newMock>
		<after public="1" set="method" line="185" override="1"><f a=""><e path="Void"/></f></after>
		<afterAll public="1" set="method" line="202" override="1"><f a=""><e path="Void"/></f></afterAll>
		<new public="1" set="method" line="162"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Array" params="T" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/Array.hx">
		<new1 params="T" set="method" line="36" static="1"><f a="a:l">
	<c path="neko.NativeArray"><c path="new1.T"/></c>
	<c path="Int"/>
	<c path="Array"><c path="new1.T"/></c>
</f></new1>
		<__a><c path="neko.NativeArray"><c path="Array.T"/></c></__a>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method" line="43">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<copy public="1" set="method" line="54">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method" line="58">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<insert public="1" set="method" line="73">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<join public="1" set="method" line="86">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<toString public="1" set="method" line="98">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<pop public="1" set="method" line="111">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method" line="120">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<unshift public="1" set="method" line="127">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<remove public="1" set="method" line="135">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<reverse public="1" set="method" line="152">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method" line="166">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method" line="179">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method" line="196">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method" line="219">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<__get set="method" line="246"><f a="pos">
	<c path="Int"/>
	<c path="Array.T"/>
</f></__get>
		<__set set="method" line="250"><f a="pos:v">
	<c path="Int"/>
	<c path="Array.T"/>
	<e path="Void"/>
</f></__set>
		<__double set="method" line="264"><f a="l">
	<c path="Int"/>
	<e path="Void"/>
</f></__double>
		<__neko set="method" line="279"><f a=""><c path="neko.NativeArray"><c path="Array.T"/></c></f></__neko>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="neko.Boot" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/Boot.hx">
		<__tmp_str set="method" line="29" static="1"><f a=""><c path="String"/></f></__tmp_str>
		<__enum_str set="method" line="33" static="1"><f a="e">
	<d/>
	<c path="String"/>
</f></__enum_str>
		<__interfLoop set="method" line="55" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__interfLoop>
		<__instanceof set="method" line="70" static="1"><f a="o:cl">
	<a>
		<__name__ set="null"><unknown/></__name__>
		<__enum__ set="null"><t path="#Dynamic"/></__enum__>
		<__ename__ set="null"><unknown/></__ename__>
		<__class__ set="null"><unknown/></__class__>
	</a>
	<t path="#Dynamic"/>
	<e path="Bool"/>
</f></__instanceof>
		<__serialize set="method" line="88" static="1"><f a="o">
	<a>
		<__enum__ set="null"><a><__ename__ set="null"><a><length set="null"><c path="Int"/></length></a></__ename__></a></__enum__>
		<__class__ set="null"><a><__name__ set="null"><a><length set="null"><c path="Int"/></length></a></__name__></a></__class__>
	</a>
	<c path="Array"><unknown/></c>
</f></__serialize>
		<__tagserialize set="method" line="108" static="1"><f a="o">
	<a>
		<tag set="null"><unknown/></tag>
		<__enum__ set="null"><a><__ename__ set="null"><a><length set="null"><c path="Int"/></length></a></__ename__></a></__enum__>
	</a>
	<c path="Array"><unknown/></c>
</f></__tagserialize>
		<__unserialize set="method" line="117" static="1"><f a="v">
	<c path="Array"><unknown/></c>
	<unknown/>
</f></__unserialize>
		<__init set="method" line="140" static="1"><f a=""><e path="Void"/></f></__init>
	</class>
	<class path="Std" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/Std.hx">
		<is public="1" set="method" line="28" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" line="32" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" set="method" line="36" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="41" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="52" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="59" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<class path="neko.NativeArray" params="T" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/NativeArray.hx">
		<alloc public="1" params="T" get="inline" set="null" line="29" static="1"><f a="length">
	<c path="Int"/>
	<c path="neko.NativeArray"><c path="alloc.T"/></c>
</f></alloc>
		<blit public="1" params="T" get="inline" set="null" line="33" static="1"><f a="dst:dstPos:src:srcPos:length">
	<c path="neko.NativeArray"><c path="blit.T"/></c>
	<c path="Int"/>
	<c path="neko.NativeArray"><c path="blit.T"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></blit>
		<ofArrayCopy public="1" params="T" get="inline" set="null" line="37" static="1"><f a="a">
	<c path="Array"><c path="ofArrayCopy.T"/></c>
	<c path="neko.NativeArray"><c path="ofArrayCopy.T"/></c>
</f></ofArrayCopy>
		<ofArrayRef public="1" params="T" get="inline" set="null" line="41" static="1"><f a="a">
	<c path="Array"><c path="ofArrayRef.T"/></c>
	<c path="neko.NativeArray"><c path="ofArrayRef.T"/></c>
</f></ofArrayRef>
		<sub public="1" params="T" get="inline" set="null" line="45" static="1"><f a="a:pos:len">
	<c path="neko.NativeArray"><c path="sub.T"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<c path="neko.NativeArray"><c path="sub.T"/></c>
</f></sub>
		<toArray public="1" params="T" get="inline" set="null" line="49" static="1"><f a="a">
	<c path="neko.NativeArray"><c path="toArray.T"/></c>
	<c path="Array"><c path="toArray.T"/></c>
</f></toArray>
		<length public="1" get="inline" set="null" line="53" static="1"><f a="a">
	<c path="neko.NativeArray"><d/></c>
	<c path="Int"/>
</f></length>
	</class>
	<class path="haxe.test.TestHandler" params="T" file="../src/main/haxe/haxe/test/TestHandler.hx">
		<POLLING_TIME get="inline" set="null" line="24" static="1"><c path="Int"/></POLLING_TIME>
		<exceptionStack set="method" line="57" static="1"><f a="?pops">
	<c path="Int"/>
	<c path="Array"><e path="haxe.StackItem"/></c>
</f></exceptionStack>
		<results public="1" set="null"><c path="List"><e path="haxe.test.Assertation"/></c></results>
		<fixture public="1" set="null"><c path="haxe.test.TestFixture"><c path="haxe.test.TestHandler.T"/></c></fixture>
		<asyncStack><c path="List"><d/></c></asyncStack>
		<onTested public="1" set="null"><c path="haxe.test.Dispatcher"><c path="haxe.test.TestHandler"><c path="haxe.test.TestHandler.T"/></c></c></onTested>
		<onTimeout public="1" set="null"><c path="haxe.test.Dispatcher"><c path="haxe.test.TestHandler"><c path="haxe.test.TestHandler.T"/></c></c></onTimeout>
		<onComplete public="1" set="null"><c path="haxe.test.Dispatcher"><c path="haxe.test.TestHandler"><c path="haxe.test.TestHandler.T"/></c></c></onComplete>
		<execute public="1" set="method" line="43"><f a=""><e path="Void"/></f></execute>
		<checkTested set="method" line="67"><f a=""><e path="Void"/></f></checkTested>
		<expireson public="1" set="null"><t path="Null"><c path="Float"/></t></expireson>
		<setTimeout public="1" set="method" line="85"><f a="timeout">
	<c path="Int"/>
	<e path="Void"/>
</f></setTimeout>
		<bindHandler set="method" line="90"><f a=""><e path="Void"/></f></bindHandler>
		<unbindHandler set="method" line="96"><f a=""><e path="Void"/></f></unbindHandler>
		<addAsync public="1" set="method" line="126">
			<f a="f:?timeout">
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<f a=""><e path="Void"/></f>
			</f>
			<haxe_doc><![CDATA[
  * Adds a function that is called asynchronously.
  *
  * Example:
  * <pre>
  * var fixture = new TestFixture(new TestClass(), "test");
  * var handler = new TestHandler(fixture);
  * var flag = false;
  * var async = handler.addAsync(function() {
  *   flag = true;
  * }, 50);
  * handler.onTimeout.add(function(h) {
  *   trace("TIMEOUT");
  * });
  * handler.onTested.add(function(h) {
  *   trace(flag ? "OK" : "FAILED");
  * });
  * haxe.Timer.delay(function() async(), 10);
  * handler.execute();
  * </pre>
  * @param  f, the function that is called asynchrnously
  * @param  timeout, the maximum time to wait for f() (default is 250)
  * @return  returns a function closure that must be executed asynchrnously
  ]]></haxe_doc>
		</addAsync>
		<addEvent public="1" params="EventArg" set="method" line="144"><f a="f:?timeout">
	<f a="">
		<c path="addEvent.EventArg"/>
		<e path="Void"/>
	</f>
	<c path="Int"/>
	<f a="e">
		<c path="addEvent.EventArg"/>
		<e path="Void"/>
	</f>
</f></addEvent>
		<executeMethodByName set="method" line="162"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></executeMethodByName>
		<executeMethod set="method" line="171"><f a="f">
	<f a=""><e path="Void"/></f>
	<e path="Void"/>
</f></executeMethod>
		<tested set="method" line="178"><f a=""><e path="Void"/></f></tested>
		<timeout set="method" line="185"><f a=""><e path="Void"/></f></timeout>
		<completed set="method" line="191"><f a=""><e path="Void"/></f></completed>
		<new public="1" set="method" line="33"><f a="fixture">
	<c path="haxe.test.TestFixture"><c path="haxe.test.TestHandler.T"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>
* @todo add documentation
</haxe_doc>
	</class>
	<class path="neko.NativeString" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/NativeString.hx">
		<ofString public="1" get="inline" set="null" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="neko.NativeString"/>
</f></ofString>
		<toString public="1" get="inline" set="null" line="33" static="1"><f a="s">
	<c path="neko.NativeString"/>
	<c path="String"/>
</f></toString>
		<length public="1" get="inline" set="null" line="37" static="1"><f a="s">
	<c path="neko.NativeString"/>
	<c path="Int"/>
</f></length>
	</class>
	<class path="haxe.test.ui.common.ClassResult" params="" file="../src/main/haxe/haxe/test/ui/common/ClassResult.hx">
		<fixtures><c path="Hash"><c path="haxe.test.ui.common.FixtureResult"/></c></fixtures>
		<className public="1" set="null"><c path="String"/></className>
		<setupName public="1" set="null"><c path="String"/></setupName>
		<teardownName public="1" set="null"><c path="String"/></teardownName>
		<hasSetup public="1" set="null"><e path="Bool"/></hasSetup>
		<hasTeardown public="1" set="null"><e path="Bool"/></hasTeardown>
		<methods public="1" set="null"><c path="Int"/></methods>
		<stats public="1" set="null"><c path="haxe.test.ui.common.ResultStats"/></stats>
		<add public="1" set="method" line="46"><f a="result">
	<c path="haxe.test.ui.common.FixtureResult"/>
	<e path="Void"/>
</f></add>
		<get public="1" set="method" line="55"><f a="method">
	<c path="String"/>
	<t path="Null"><c path="haxe.test.ui.common.FixtureResult"/></t>
</f></get>
		<exists public="1" set="method" line="59"><f a="method">
	<c path="String"/>
	<e path="Bool"/>
</f></exists>
		<methodNames public="1" set="method" line="63"><f a="?errorsHavePriority">
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></methodNames>
		<new public="1" set="method" line="34"><f a="className:setupName:teardownName">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
* @todo add documentation
</haxe_doc>
	</class>
	<class path="haxe.data.collections.ArrayExtensions" params="" file="../src/main/haxe/haxe/data/collections/ArrayExtensions.hx">
		<partition public="1" params="T" set="method" line="31" static="1">
			<f a="arr:f">
				<c path="Array"><c path="partition.T"/></c>
				<f a="">
					<c path="partition.T"/>
					<e path="Bool"/>
				</f>
				<c path="Tuple2">
					<c path="Array"><c path="partition.T"/></c>
					<c path="Array"><c path="partition.T"/></c>
				</c>
			</f>
			<haxe_doc> Partitions an array, returning a tuple, based on a function, where returning true places 
	 * the item in the right hand array, and returning false places the item in the left.
	 * @param arr 	Array to partition
	 * 
	 * @param f 		The function to call on each item. True places left, false right.
	 *
	 * @returns 		A tuple containing the partitioned array.
	 </haxe_doc>
		</partition>
		<partitionWhile public="1" params="T" set="method" line="51" static="1">
			<f a="arr:f">
				<c path="Array"><c path="partitionWhile.T"/></c>
				<f a="">
					<c path="partitionWhile.T"/>
					<e path="Bool"/>
				</f>
				<c path="Tuple2">
					<c path="Array"><c path="partitionWhile.T"/></c>
					<c path="Array"><c path="partitionWhile.T"/></c>
				</c>
			</f>
			<haxe_doc> Partitions an array in the following way: While the disciminator function returns true, 
	 * the array element will be placed on the left in the output. If the function returns false,
	 * all further elements will be placed right
	 * 
	 * @param array 	The array to be partitioned.
	 * 
	 * @param f 			The discriminator function.
	 *
	 * @returns 			A tuple containing the paritioned array.
	 </haxe_doc>
		</partitionWhile>
		<mapTo public="1" params="A:B" set="method" line="76" static="1">
			<f a="src:dest:f">
				<c path="Array"><c path="mapTo.A"/></c>
				<c path="Array"><c path="mapTo.B"/></c>
				<f a="">
					<c path="mapTo.A"/>
					<c path="mapTo.B"/>
				</f>
				<c path="Array"><c path="mapTo.B"/></c>
			</f>
			<haxe_doc> As with map, but pushes results to a destination array.
	 * 
	 * @param src 		An array to iterate.
	 * 
	 * @param dest 		An array to push results to.
	 * 
	 * @returns 			A reference to the dest array.
	 </haxe_doc>
		</mapTo>
		<flatMapTo public="1" params="A:B" set="method" line="90" static="1">
			<f a="src:dest:f">
				<c path="Array"><c path="flatMapTo.A"/></c>
				<c path="Array"><c path="flatMapTo.B"/></c>
				<f a="">
					<c path="flatMapTo.A"/>
					<c path="Array"><c path="flatMapTo.B"/></c>
				</f>
				<c path="Array"><c path="flatMapTo.B"/></c>
			</f>
			<haxe_doc> As with flatMap, but pushes results to a destination array.
	 *
	 * @param src 		An array to iterate.
	 * 
	 * @param dest 		An array to push results to.
	 *
	 * @returns 			A reference to dest.
	 </haxe_doc>
		</flatMapTo>
		<count public="1" params="T" set="method" line="106" static="1"><f a="arr:f">
	<c path="Array"><c path="count.T"/></c>
	<f a="">
		<c path="count.T"/>
		<e path="Bool"/>
	</f>
	<c path="Int"/>
</f></count>
		<countWhile public="1" params="T" set="method" line="119" static="1">
			<f a="arr:f">
				<c path="Array"><c path="countWhile.T"/></c>
				<f a="">
					<c path="countWhile.T"/>
					<e path="Bool"/>
				</f>
				<c path="Int"/>
			</f>
			<haxe_doc> Counts the number of times a function evaluates to true before returning false
	* for the first time.
	* @param arr 		An array to iterate.
	* 
	* @param f 			A function, taking an element, and returning a Bool.
	*
	* @returns 			The number of times f returns true until it evaluates to false.
	</haxe_doc>
		</countWhile>
		<scanl public="1" params="T" set="method" line="143" static="1">
			<f a="arr:init:f">
				<c path="Array"><c path="scanl.T"/></c>
				<c path="scanl.T"/>
				<f a=":">
					<c path="scanl.T"/>
					<c path="scanl.T"/>
					<c path="scanl.T"/>
				</f>
				<c path="Array"><c path="scanl.T"/></c>
			</f>
			<haxe_doc> Taking an initial element, iterates an array, passing each element through function f, the function allowing access to 
	* the initial value at each stage of the iteration.
	*
	* @param arr 				The array to iterate.
	*
	* @param init 			A value typed as the array, which is passed to function f.
	*
	* @param f 					A function, taking as first parameter the array element, and an initial value as the second.
	</haxe_doc>
		</scanl>
		<scanr public="1" params="T" set="method" line="157" static="1">
			<f a="arr:init:f">
				<c path="Array"><c path="scanr.T"/></c>
				<c path="scanr.T"/>
				<f a=":">
					<c path="scanr.T"/>
					<c path="scanr.T"/>
					<c path="scanr.T"/>
				</f>
				<c path="Array"><c path="scanr.T"/></c>
			</f>
			<haxe_doc> Scans an array from the right. @see scanl
	 *
	 * @param arr 			The array to iter
	</haxe_doc>
		</scanr>
		<scanl1 public="1" params="T" set="method" line="163" static="1"><f a="arr:f">
	<c path="Array"><c path="scanl1.T"/></c>
	<f a=":">
		<c path="scanl1.T"/>
		<c path="scanl1.T"/>
		<c path="scanl1.T"/>
	</f>
	<c path="Array"><c path="scanl1.T"/></c>
</f></scanl1>
		<scanr1 public="1" params="T" set="method" line="175" static="1"><f a="arr:f">
	<c path="Array"><c path="scanr1.T"/></c>
	<f a=":">
		<c path="scanr1.T"/>
		<c path="scanr1.T"/>
		<c path="scanr1.T"/>
	</f>
	<c path="Array"><c path="scanr1.T"/></c>
</f></scanr1>
		<elements public="1" params="T" set="method" line="181" static="1"><f a="arr">
	<c path="Array"><c path="elements.T"/></c>
	<t path="Iterable"><c path="elements.T"/></t>
</f></elements>
		<appendAll public="1" params="T" set="method" line="185" static="1"><f a="arr:i">
	<c path="Array"><c path="appendAll.T"/></c>
	<t path="Iterable"><c path="appendAll.T"/></t>
	<c path="Array"><c path="appendAll.T"/></c>
</f></appendAll>
		<concat public="1" params="T" set="method" line="193" static="1"><f a="arr0:arr1">
	<c path="Array"><c path="concat.T"/></c>
	<c path="Array"><c path="concat.T"/></c>
	<c path="Array"><c path="concat.T"/></c>
</f></concat>
		<isEmpty public="1" params="T" set="method" line="196" static="1"><f a="arr">
	<c path="Array"><c path="isEmpty.T"/></c>
	<e path="Bool"/>
</f></isEmpty>
		<find public="1" params="T" set="method" line="200" static="1"><f a="arr:f">
	<c path="Array"><c path="find.T"/></c>
	<f a="">
		<c path="find.T"/>
		<e path="Bool"/>
	</f>
	<e path="Option"><c path="find.T"/></e>
</f></find>
		<forAll public="1" params="T" set="method" line="209" static="1"><f a="arr:f">
	<c path="Array"><c path="forAll.T"/></c>
	<f a="">
		<c path="forAll.T"/>
		<e path="Bool"/>
	</f>
	<e path="Bool"/>
</f></forAll>
		<forAny public="1" params="T" set="method" line="218" static="1"><f a="arr:f">
	<c path="Array"><c path="forAny.T"/></c>
	<f a="">
		<c path="forAny.T"/>
		<e path="Bool"/>
	</f>
	<e path="Bool"/>
</f></forAny>
		<exists public="1" params="T" set="method" line="227" static="1"><f a="arr:f">
	<c path="Array"><c path="exists.T"/></c>
	<f a="">
		<c path="exists.T"/>
		<e path="Bool"/>
	</f>
	<e path="Bool"/>
</f></exists>
		<existsP public="1" params="T" set="method" line="234" static="1"><f a="arr:ref:f">
	<c path="Array"><c path="existsP.T"/></c>
	<c path="existsP.T"/>
	<f a=":">
		<c path="existsP.T"/>
		<c path="existsP.T"/>
		<e path="Bool"/>
	</f>
	<e path="Bool"/>
</f></existsP>
		<nubBy public="1" params="T" set="method" line="245" static="1"><f a="arr:f">
	<c path="Array"><c path="nubBy.T"/></c>
	<f a=":">
		<c path="nubBy.T"/>
		<c path="nubBy.T"/>
		<e path="Bool"/>
	</f>
	<c path="Array"><c path="nubBy.T"/></c>
</f></nubBy>
		<nub public="1" params="T" set="method" line="256" static="1"><f a="arr">
	<c path="Array"><c path="nub.T"/></c>
	<c path="Array"><c path="nub.T"/></c>
</f></nub>
		<intersectBy public="1" params="T" set="method" line="260" static="1"><f a="arr1:arr2:f">
	<c path="Array"><c path="intersectBy.T"/></c>
	<c path="Array"><c path="intersectBy.T"/></c>
	<f a=":">
		<c path="intersectBy.T"/>
		<c path="intersectBy.T"/>
		<e path="Bool"/>
	</f>
	<c path="Array"><c path="intersectBy.T"/></c>
</f></intersectBy>
		<intersect public="1" params="T" set="method" line="266" static="1"><f a="arr1:arr2">
	<c path="Array"><c path="intersect.T"/></c>
	<c path="Array"><c path="intersect.T"/></c>
	<c path="Array"><c path="intersect.T"/></c>
</f></intersect>
		<mkString public="1" params="T" set="method" line="270" static="1"><f a="arr:?sep:?show">
	<c path="Array"><c path="mkString.T"/></c>
	<c path="String"/>
	<f a="">
		<c path="mkString.T"/>
		<c path="String"/>
	</f>
	<c path="String"/>
</f></mkString>
		<groupBy public="1" params="T:K" set="method" line="281" static="1"><f a="arr:grouper">
	<c path="Array"><c path="groupBy.T"/></c>
	<f a="">
		<c path="groupBy.T"/>
		<c path="groupBy.K"/>
	</f>
	<c path="haxe.data.collections.Map">
		<c path="groupBy.K"/>
		<c path="Array"><c path="groupBy.T"/></c>
	</c>
</f></groupBy>
		<toList public="1" params="T" set="method" line="290" static="1"><f a="arr">
	<c path="Array"><c path="toList.T"/></c>
	<c path="haxe.data.collections.List"><t path="Null"><c path="toList.T"/></t></c>
</f></toList>
		<toSet public="1" params="T" set="method" line="294" static="1"><f a="arr">
	<c path="Array"><c path="toSet.T"/></c>
	<c path="haxe.data.collections.Set"><t path="Null"><c path="toSet.T"/></t></c>
</f></toSet>
		<toMap public="1" params="K:V" set="method" line="298" static="1"><f a="arr">
	<c path="Array"><c path="Tuple2">
	<c path="toMap.K"/>
	<c path="toMap.V"/>
</c></c>
	<c path="haxe.data.collections.Map">
		<c path="toMap.K"/>
		<c path="toMap.V"/>
	</c>
</f></toMap>
		<forEach public="1" params="T" set="method" line="301" static="1"><f a="arr:f">
	<c path="Array"><c path="forEach.T"/></c>
	<f a="">
		<c path="forEach.T"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></forEach>
	</class>
	<enum path="haxe.net.HttpInformational" params="" file="../src/main/haxe/haxe/net/HttpResponseCode.hx" module="haxe.net.HttpResponseCode">
		<SwitchingProtocols/>
		<Processing/>
		<Continue/>
	</enum>
	<enum path="haxe.net.HttpSuccess" params="" file="../src/main/haxe/haxe/net/HttpResponseCode.hx" module="haxe.net.HttpResponseCode">
		<ResetContent/>
		<PartialContent/>
		<OK/>
		<Non/>
		<NoContent/>
		<Multi/>
		<Created/>
		<Accepted/>
	</enum>
	<enum path="haxe.net.HttpRedirection" params="" file="../src/main/haxe/haxe/net/HttpResponseCode.hx" module="haxe.net.HttpResponseCode">
		<UseProxy/>
		<TemporaryRedirect/>
		<SeeOther/>
		<NotModified/>
		<MultipleChoices/>
		<MovedPermanently/>
		<Found/>
	</enum>
	<enum path="haxe.net.HttpClientError" params="" file="../src/main/haxe/haxe/net/HttpResponseCode.hx" module="haxe.net.HttpResponseCode">
		<UpgradeRequired/>
		<UnsupportedMediaType/>
		<UnprocessableEntity/>
		<UnorderedCollection/>
		<Unauthorized/>
		<TooManyConnections/>
		<RetryWith/>
		<RequestedRangeNotSatisfiable/>
		<RequestTimeout/>
		<RequestEntityTooLarge/>
		<Request/>
		<ProxyAuthenticationRequired/>
		<PreconditionFailed/>
		<PaymentRequired/>
		<NotFound/>
		<NotAcceptable/>
		<MethodNotAllowed/>
		<Locked/>
		<LengthRequired/>
		<Gone/>
		<Forbidden/>
		<FailedDependency/>
		<ExpectationFailed/>
		<Conflict/>
		<BadRequest/>
	</enum>
	<enum path="haxe.net.HttpServerError" params="" file="../src/main/haxe/haxe/net/HttpResponseCode.hx" module="haxe.net.HttpResponseCode">
		<VariantAlsoNegotiates/>
		<UserAccessDenied/>
		<ServiceUnavailable/>
		<NotImplemented/>
		<NotExtended/>
		<InternalServerError/>
		<InsufficientStorage/>
		<HTTPVersionNotSupported/>
		<GatewayTimeout/>
		<BandwidthLimitExceeded/>
		<BadGateway/>
	</enum>
	<enum path="haxe.net.HttpNormal" params="" file="../src/main/haxe/haxe/net/HttpResponseCode.hx" module="haxe.net.HttpResponseCode">
		<Success a="v"><e path="haxe.net.HttpSuccess"/></Success>
		<Redirection a="v"><e path="haxe.net.HttpRedirection"/></Redirection>
		<Informational a="v"><e path="haxe.net.HttpInformational"/></Informational>
	</enum>
	<enum path="haxe.net.HttpError" params="" file="../src/main/haxe/haxe/net/HttpResponseCode.hx" module="haxe.net.HttpResponseCode">
		<Server a="v"><e path="haxe.net.HttpServerError"/></Server>
		<Client a="v"><e path="haxe.net.HttpClientError"/></Client>
	</enum>
	<enum path="haxe.net.HttpResponseCode" params="" file="../src/main/haxe/haxe/net/HttpResponseCode.hx">
		<Normal a="v"><e path="haxe.net.HttpNormal"/></Normal>
		<Error a="v"><e path="haxe.net.HttpError"/></Error>
	</enum>
	<enum path="haxe.io.Error" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc> An integer value is outside its allowed range </haxe_doc></Overflow>
		<OutsideBounds><haxe_doc> An operation on Bytes is outside of its valid range </haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc> Other errors </haxe_doc>
		</Custom>
		<Blocked><haxe_doc> The IO is set into nonblocking mode and some data cannot be read or written </haxe_doc></Blocked>
		<haxe_doc>
	The possible IO errors that can occur
</haxe_doc>
	</enum>
	<class path="haxe.data.collections.Set" params="T" file="../src/main/haxe/haxe/data/collections/Set.hx">
		<implements path="haxe.data.collections.Collection">
			<c path="haxe.data.collections.Set"><c path="haxe.data.collections.Set.T"/></c>
			<c path="haxe.data.collections.Set.T"/>
		</implements>
		<create public="1" params="T" set="method" line="41" static="1"><f a="?order:?equal:?hash:?show">
	<t path="OrderFunction"><c path="create.T"/></t>
	<t path="EqualFunction"><c path="create.T"/></t>
	<t path="HashFunction"><c path="create.T"/></t>
	<t path="ShowFunction"><c path="create.T"/></t>
	<c path="haxe.data.collections.Set"><c path="create.T"/></c>
</f></create>
		<factory public="1" params="T" set="method" line="46" static="1">
			<f a="?order:?equal:?hash:?show">
				<t path="OrderFunction"><c path="factory.T"/></t>
				<t path="EqualFunction"><c path="factory.T"/></t>
				<t path="HashFunction"><c path="factory.T"/></t>
				<t path="ShowFunction"><c path="factory.T"/></t>
				<t path="Factory"><c path="haxe.data.collections.Set"><c path="factory.T"/></c></t>
			</f>
			<haxe_doc> Creates a factory for sets of the specified type. </haxe_doc>
		</factory>
		<extract public="1" params="T" set="method" line="124" static="1"><f a="v:e:?order:?equal:?hash:?show">
	<e path="haxe.text.json.JValue"/>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.T"/></t>
	<t path="OrderFunction"><c path="extract.T"/></t>
	<t path="EqualFunction"><c path="extract.T"/></t>
	<t path="HashFunction"><c path="extract.T"/></t>
	<t path="ShowFunction"><c path="extract.T"/></t>
	<c path="haxe.data.collections.Set"><c path="extract.T"/></c>
</f></extract>
		<equal public="1" get="getEqual" set="null"><t path="EqualFunction"><c path="haxe.data.collections.Set.T"/></t></equal>
		<order public="1" get="getOrder" set="null"><t path="OrderFunction"><c path="haxe.data.collections.Set.T"/></t></order>
		<hash public="1" get="getHash" set="null"><t path="HashFunction"><c path="haxe.data.collections.Set.T"/></t></hash>
		<show public="1" get="getShow" set="null"><t path="ShowFunction"><c path="haxe.data.collections.Set.T"/></t></show>
		<_map><c path="haxe.data.collections.Map">
	<c path="haxe.data.collections.Set.T"/>
	<c path="haxe.data.collections.Set.T"/>
</c></_map>
		<contains public="1" set="method" line="56"><f a="e">
	<c path="haxe.data.collections.Set.T"/>
	<e path="Bool"/>
</f></contains>
		<empty public="1" params="C:D" set="method" line="60"><f a=""><c path="haxe.functional.Foldable">
	<c path="empty.C"/>
	<c path="empty.D"/>
</c></f></empty>
		<append public="1" set="method" line="64"><f a="t">
	<c path="haxe.data.collections.Set.T"/>
	<c path="haxe.data.collections.Set"><c path="haxe.data.collections.Set.T"/></c>
</f></append>
		<foldl public="1" params="Z" set="method" line="68"><f a="z:f">
	<c path="foldl.Z"/>
	<f a=":">
		<c path="foldl.Z"/>
		<c path="haxe.data.collections.Set.T"/>
		<c path="foldl.Z"/>
	</f>
	<c path="foldl.Z"/>
</f></foldl>
		<add public="1" set="method" line="78"><f a="t">
	<c path="haxe.data.collections.Set.T"/>
	<c path="haxe.data.collections.Set"><c path="haxe.data.collections.Set.T"/></c>
</f></add>
		<addAll public="1" set="method" line="82"><f a="it">
	<t path="Iterable"><c path="haxe.data.collections.Set.T"/></t>
	<c path="haxe.data.collections.Set"><c path="haxe.data.collections.Set.T"/></c>
</f></addAll>
		<remove public="1" set="method" line="90"><f a="t">
	<c path="haxe.data.collections.Set.T"/>
	<c path="haxe.data.collections.Set"><c path="haxe.data.collections.Set.T"/></c>
</f></remove>
		<removeAll public="1" set="method" line="94"><f a="it">
	<t path="Iterable"><c path="haxe.data.collections.Set.T"/></t>
	<c path="haxe.data.collections.Set"><c path="haxe.data.collections.Set.T"/></c>
</f></removeAll>
		<iterator public="1" set="method" line="102"><f a=""><t path="Iterator"><c path="haxe.data.collections.Set.T"/></t></f></iterator>
		<equals public="1" set="method" line="106"><f a="other">
	<c path="haxe.data.collections.Set"><c path="haxe.data.collections.Set.T"/></c>
	<e path="Bool"/>
</f></equals>
		<compare public="1" set="method" line="111"><f a="other">
	<c path="haxe.data.collections.Set"><c path="haxe.data.collections.Set.T"/></c>
	<c path="Int"/>
</f></compare>
		<hashCode public="1" set="method" line="115"><f a=""><c path="Int"/></f></hashCode>
		<decompose public="1" set="method" line="120"><f a=""><e path="haxe.text.json.JValue"/></f></decompose>
		<toString public="1" set="method" line="132"><f a=""><c path="String"/></f></toString>
		<withOrderFunction public="1" set="method" line="136"><f a="order">
	<t path="OrderFunction"><c path="haxe.data.collections.Set.T"/></t>
	<c path="haxe.data.collections.Set"><c path="haxe.data.collections.Set.T"/></c>
</f></withOrderFunction>
		<withEqualFunction public="1" set="method" line="141"><f a="equal">
	<t path="EqualFunction"><c path="haxe.data.collections.Set.T"/></t>
	<c path="haxe.data.collections.Set"><c path="haxe.data.collections.Set.T"/></c>
</f></withEqualFunction>
		<withHashFunction public="1" set="method" line="146"><f a="hash">
	<t path="HashFunction"><c path="haxe.data.collections.Set.T"/></t>
	<c path="haxe.data.collections.Set"><c path="haxe.data.collections.Set.T"/></c>
</f></withHashFunction>
		<withShowFunction public="1" set="method" line="151"><f a="show">
	<t path="ShowFunction"><c path="haxe.data.collections.Set.T"/></t>
	<c path="haxe.data.collections.Set"><c path="haxe.data.collections.Set.T"/></c>
</f></withShowFunction>
		<copyWithMod set="method" line="159">
			<f a="newMap">
				<c path="haxe.data.collections.Map">
					<c path="haxe.data.collections.Set.T"/>
					<c path="haxe.data.collections.Set.T"/>
				</c>
				<c path="haxe.data.collections.Set"><c path="haxe.data.collections.Set.T"/></c>
			</f>
			<haxe_doc>
   *  @todo inject *Functions here?
   </haxe_doc>
		</copyWithMod>
		<size public="1" set="method" line="163"><f a=""><c path="Int"/></f></size>
		<getOrder set="method" line="167"><f a=""><t path="OrderFunction"><c path="haxe.data.collections.Set.T"/></t></f></getOrder>
		<getEqual set="method" line="171"><f a=""><t path="EqualFunction"><c path="haxe.data.collections.Set.T"/></t></f></getEqual>
		<getHash set="method" line="175"><f a=""><t path="HashFunction"><c path="haxe.data.collections.Set.T"/></t></f></getHash>
		<getShow set="method" line="179"><f a=""><t path="ShowFunction"><c path="haxe.data.collections.Set.T"/></t></f></getShow>
		<new set="method" line="52"><f a="map">
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Set.T"/>
		<c path="haxe.data.collections.Set.T"/>
	</c>
	<e path="Void"/>
</f></new>
		<haxe_doc> A cross-platform, immutable Set built on Map. </haxe_doc>
	</class>
	<typedef path="haxe.data.collections._Set.FriendMap" params="K" file="../src/main/haxe/haxe/data/collections/Set.hx" private="1" module="haxe.data.collections.Set"><a>
	<_keyShow><t path="ShowFunction"><c path="haxe.data.collections._Set.FriendMap.K"/></t></_keyShow>
	<_keyOrder><t path="OrderFunction"><c path="haxe.data.collections._Set.FriendMap.K"/></t></_keyOrder>
	<_keyHash><t path="HashFunction"><c path="haxe.data.collections._Set.FriendMap.K"/></t></_keyHash>
	<_keyEqual><t path="EqualFunction"><c path="haxe.data.collections._Set.FriendMap.K"/></t></_keyEqual>
</a></typedef>
	<class path="haxe.test.ui.common.ReportTools" params="" file="../src/main/haxe/haxe/test/ui/common/ReportTools.hx">
		<hasHeader public="1" set="method" line="22" static="1"><f a="report:stats">
	<c path="haxe.test.ui.common.IReport"><d/></c>
	<c path="haxe.test.ui.common.ResultStats"/>
	<e path="Bool"/>
</f></hasHeader>
		<skipResult public="1" set="method" line="41" static="1"><f a="report:stats:isOk">
	<c path="haxe.test.ui.common.IReport"><d/></c>
	<c path="haxe.test.ui.common.ResultStats"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></skipResult>
		<hasOutput public="1" set="method" line="50" static="1"><f a="report:stats">
	<c path="haxe.test.ui.common.IReport"><d/></c>
	<c path="haxe.test.ui.common.ResultStats"/>
	<e path="Bool"/>
</f></hasOutput>
	</class>
	<class path="haxe.test.Runner" params="" file="../src/main/haxe/haxe/test/Runner.hx">
		<findMethodByName set="method" line="212" static="1"><f a="test:name">
	<d/>
	<c path="String"/>
	<f a=""><e path="Void"/></f>
</f></findMethodByName>
		<fixtures set="null"><c path="Array"><c path="haxe.test.TestFixture"><d/></c></c></fixtures>
		<onProgress public="1" set="null">
			<c path="haxe.test.Dispatcher"><a>
	<totals><c path="Int"/></totals>
	<result><c path="haxe.test.TestResult"/></result>
	<done><c path="Int"/></done>
</a></c>
			<haxe_doc>
  * Event object that monitors the progress of the runner.
  </haxe_doc>
		</onProgress>
		<onStart public="1" set="null">
			<c path="haxe.test.Dispatcher"><c path="haxe.test.Runner"/></c>
			<haxe_doc>
  * Event object that monitors when the runner starts.
  </haxe_doc>
		</onStart>
		<onComplete public="1" set="null">
			<c path="haxe.test.Dispatcher"><c path="haxe.test.Runner"/></c>
			<haxe_doc>
  * Event object that monitors when the runner ends. This event takes into account async calls
  * performed during the tests.
  </haxe_doc>
		</onComplete>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
  * The number of fixtures registered.
  </haxe_doc>
		</length>
		<addAll public="1" set="method" line="63"><f a="tests:?prefix:?pattern">
	<t path="Iterable"><d/></t>
	<c path="String"/>
	<c path="EReg"/>
	<c path="haxe.test.Runner"/>
</f></addAll>
		<add public="1" set="method" line="78">
			<f a="test:?prefix:?pattern">
				<d/>
				<c path="String"/>
				<c path="EReg"/>
				<c path="haxe.test.Runner"/>
			</f>
			<haxe_doc>
  * Adds a new test case.
  * @param  test: must be a not null object
  * @param  prefix: prefix for methods that are tests (defaults to "test")
  * @param  pattern: a regular expression that discriminates the names of test
  *         functions; when set, the prefix parameter is meaningless
  </haxe_doc>
		</add>
		<addFixture public="1" set="method" line="100"><f a="fixture">
	<c path="haxe.test.TestFixture"><d/></c>
	<c path="haxe.test.Runner"/>
</f></addFixture>
		<addFixtures public="1" set="method" line="107"><f a="fixtures">
	<t path="Iterable"><c path="haxe.test.TestFixture"><d/></c></t>
	<c path="haxe.test.Runner"/>
</f></addFixtures>
		<getFixture public="1" set="method" line="113"><f a="index">
	<c path="Int"/>
	<c path="haxe.test.TestFixture"><d/></c>
</f></getFixture>
		<isMethod set="method" line="117"><f a="test:name">
	<d/>
	<c path="String"/>
	<e path="Bool"/>
</f></isMethod>
		<pos><c path="Int"/></pos>
		<run public="1" set="method" line="126"><f a=""><c path="haxe.test.Runner"/></f></run>
		<runNext set="method" line="134"><f a=""><e path="Void"/></f></runNext>
		<runFixture set="method" line="141"><f a="fixture">
	<c path="haxe.test.TestFixture"><d/></c>
	<e path="Void"/>
</f></runFixture>
		<testComplete set="method" line="147"><f a="h">
	<c path="haxe.test.TestHandler"><d/></c>
	<e path="Void"/>
</f></testComplete>
		<addBeforeAll set="method" line="152"><f a="test:f">
	<d/>
	<f a="">
		<c path="String"/>
		<f a=""><e path="Void"/></f>
	</f>
	<f a="">
		<c path="String"/>
		<f a=""><e path="Void"/></f>
	</f>
</f></addBeforeAll>
		<addAfterAll set="method" line="179"><f a="test:totalTestsHolder:f">
	<d/>
	<c path="Array"><c path="Int"/></c>
	<f a="">
		<c path="String"/>
		<f a=""><e path="Void"/></f>
	</f>
	<f a="">
		<c path="String"/>
		<f a=""><e path="Void"/></f>
	</f>
</f></addAfterAll>
		<new public="1" set="method" line="55">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
  * Instantiates a Runner onject.
  </haxe_doc>
		</new>
		<haxe_doc>
* The Runner class performs a set of tests. The tests can be added using add or addFixtures.
* Once all the tests are register they are axecuted on the run() call.
* Note that Runner does not provide any visual output. To visualize the test results use one of
* the classes in the utest.ui package.
* @todo complete documentation
</haxe_doc>
	</class>
	<class path="haxe.io.Bytes" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="225" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="253" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="292" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><c path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="51"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<blit public="1" set="method" line="65"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<sub public="1" set="method" line="93"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="112"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<readString public="1" set="method" line="148"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" set="method" line="192"><f a=""><c path="String"/></f></toString>
		<toHex public="1" set="method" line="207"><f a=""><c path="String"/></f></toHex>
		<getData public="1" get="inline" set="null" line="221"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.test.ui.Report" params="" file="../src/main/haxe/haxe/test/ui/Report.hx"><create public="1" set="method" line="31" static="1"><f a="runner:?displaySuccessResults:?headerDisplayMode">
	<c path="haxe.test.Runner"/>
	<e path="haxe.test.ui.common.SuccessResultsDisplayMode"/>
	<e path="haxe.test.ui.common.HeaderDisplayMode"/>
	<c path="haxe.test.ui.common.IReport"><d/></c>
</f></create></class>
	<class path="haxe.text.json.Json" params="" file="../src/main/haxe/haxe/text/json/Json.hx">
		<encodeObject public="1" line="26" static="1"><t path="Function">
	<unknown/>
	<c path="String"/>
</t></encodeObject>
		<decodeObject public="1" line="27" static="1"><t path="Function">
	<c path="String"/>
	<unknown/>
</t></decodeObject>
		<toObject public="1" set="method" line="29" static="1"><f a="v">
	<e path="haxe.text.json.JValue"/>
	<d/>
</f></toObject>
		<fromObject public="1" set="method" line="47" static="1"><f a="d">
	<d/>
	<e path="haxe.text.json.JValue"/>
</f></fromObject>
		<encode public="1" set="method" line="65" static="1"><f a="v">
	<e path="haxe.text.json.JValue"/>
	<c path="String"/>
</f></encode>
		<decode public="1" set="method" line="84" static="1"><f a="s">
	<c path="String"/>
	<e path="haxe.text.json.JValue"/>
</f></decode>
	</class>
	<class path="haxe.functional.FoldableExtensions" params="" file="../src/main/haxe/haxe/functional/FoldableExtensions.hx">
		<foldr public="1" params="A:B:Z" set="method" line="29" static="1"><f a="foldable:z:f">
	<c path="haxe.functional.Foldable">
		<c path="foldr.A"/>
		<c path="foldr.B"/>
	</c>
	<c path="foldr.Z"/>
	<f a=":">
		<c path="foldr.B"/>
		<c path="foldr.Z"/>
		<c path="foldr.Z"/>
	</f>
	<c path="foldr.Z"/>
</f></foldr>
		<filter public="1" params="A:B" set="method" line="43" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="filter.A"/>
		<c path="filter.B"/>
	</c>
	<f a="">
		<c path="filter.B"/>
		<e path="Bool"/>
	</f>
	<c path="filter.A"/>
</f></filter>
		<partition public="1" params="A:B" set="method" line="49" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="partition.A"/>
		<c path="partition.B"/>
	</c>
	<f a="">
		<c path="partition.B"/>
		<e path="Bool"/>
	</f>
	<c path="Tuple2">
		<c path="partition.A"/>
		<c path="partition.A"/>
	</c>
</f></partition>
		<partitionWhile public="1" params="A:B" set="method" line="55" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="partitionWhile.A"/>
		<c path="partitionWhile.B"/>
	</c>
	<f a="">
		<c path="partitionWhile.B"/>
		<e path="Bool"/>
	</f>
	<c path="Tuple2">
		<c path="partitionWhile.A"/>
		<c path="partitionWhile.A"/>
	</c>
</f></partitionWhile>
		<map public="1" params="A:B:C:D" set="method" line="75" static="1"><f a="src:f">
	<c path="haxe.functional.Foldable">
		<c path="map.A"/>
		<c path="map.B"/>
	</c>
	<f a="">
		<c path="map.B"/>
		<c path="map.D"/>
	</f>
	<c path="haxe.functional.Foldable">
		<c path="map.C"/>
		<c path="map.D"/>
	</c>
</f></map>
		<mapTo public="1" params="A:B:C:D" set="method" line="79" static="1"><f a="src:dest:f">
	<c path="haxe.functional.Foldable">
		<c path="mapTo.A"/>
		<c path="mapTo.B"/>
	</c>
	<c path="haxe.functional.Foldable">
		<c path="mapTo.C"/>
		<c path="mapTo.D"/>
	</c>
	<f a="">
		<c path="mapTo.B"/>
		<c path="mapTo.D"/>
	</f>
	<c path="mapTo.C"/>
</f></mapTo>
		<flatMap public="1" params="A:B:C:D" set="method" line="85" static="1"><f a="src:f">
	<c path="haxe.functional.Foldable">
		<c path="flatMap.A"/>
		<c path="flatMap.B"/>
	</c>
	<f a="">
		<c path="flatMap.B"/>
		<c path="haxe.functional.Foldable">
			<c path="flatMap.C"/>
			<c path="flatMap.D"/>
		</c>
	</f>
	<c path="flatMap.C"/>
</f></flatMap>
		<flatMapTo public="1" params="A:B:C:D" set="method" line="89" static="1"><f a="src:dest:f">
	<c path="haxe.functional.Foldable">
		<c path="flatMapTo.A"/>
		<c path="flatMapTo.B"/>
	</c>
	<c path="haxe.functional.Foldable">
		<c path="flatMapTo.C"/>
		<c path="flatMapTo.D"/>
	</c>
	<f a="">
		<c path="flatMapTo.B"/>
		<c path="haxe.functional.Foldable">
			<c path="flatMapTo.C"/>
			<c path="flatMapTo.D"/>
		</c>
	</f>
	<c path="flatMapTo.C"/>
</f></flatMapTo>
		<take public="1" params="A:B" set="method" line="97" static="1"><f a="foldable:n">
	<c path="haxe.functional.Foldable">
		<c path="take.A"/>
		<c path="take.B"/>
	</c>
	<c path="Int"/>
	<c path="take.A"/>
</f></take>
		<takeWhile public="1" params="A:B" set="method" line="103" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="takeWhile.A"/>
		<c path="takeWhile.B"/>
	</c>
	<f a="">
		<c path="takeWhile.B"/>
		<e path="Bool"/>
	</f>
	<c path="takeWhile.A"/>
</f></takeWhile>
		<drop public="1" params="A:B" set="method" line="111" static="1"><f a="foldable:n">
	<c path="haxe.functional.Foldable">
		<c path="drop.A"/>
		<c path="drop.B"/>
	</c>
	<c path="Int"/>
	<c path="drop.A"/>
</f></drop>
		<dropWhile public="1" params="A:B" set="method" line="117" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="dropWhile.A"/>
		<c path="dropWhile.B"/>
	</c>
	<f a="">
		<c path="dropWhile.B"/>
		<e path="Bool"/>
	</f>
	<c path="dropWhile.A"/>
</f></dropWhile>
		<count public="1" params="A:B" set="method" line="125" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="count.A"/>
		<c path="count.B"/>
	</c>
	<f a="">
		<c path="count.B"/>
		<e path="Bool"/>
	</f>
	<c path="Int"/>
</f></count>
		<countWhile public="1" params="A:B" set="method" line="131" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="countWhile.A"/>
		<c path="countWhile.B"/>
	</c>
	<f a="">
		<c path="countWhile.B"/>
		<e path="Bool"/>
	</f>
	<c path="Int"/>
</f></countWhile>
		<scanl public="1" params="A:B" set="method" line="147" static="1"><f a="foldable:init:f">
	<c path="haxe.functional.Foldable">
		<c path="scanl.A"/>
		<c path="scanl.B"/>
	</c>
	<c path="scanl.B"/>
	<f a=":">
		<c path="scanl.B"/>
		<c path="scanl.B"/>
		<c path="scanl.B"/>
	</f>
	<c path="scanl.A"/>
</f></scanl>
		<scanr public="1" params="A:B" set="method" line="158" static="1"><f a="foldable:init:f">
	<c path="haxe.functional.Foldable">
		<c path="scanr.A"/>
		<c path="scanr.B"/>
	</c>
	<c path="scanr.B"/>
	<f a=":">
		<c path="scanr.B"/>
		<c path="scanr.B"/>
		<c path="scanr.B"/>
	</f>
	<c path="scanr.A"/>
</f></scanr>
		<scanl1 public="1" params="A:B" set="method" line="171" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="scanl1.A"/>
		<c path="scanl1.B"/>
	</c>
	<f a=":">
		<c path="scanl1.B"/>
		<c path="scanl1.B"/>
		<c path="scanl1.B"/>
	</f>
	<c path="scanl1.A"/>
</f></scanl1>
		<scanr1 public="1" params="A:B" set="method" line="187" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="scanr1.A"/>
		<c path="scanr1.B"/>
	</c>
	<f a=":">
		<c path="scanr1.B"/>
		<c path="scanr1.B"/>
		<c path="scanr1.B"/>
	</f>
	<c path="scanr1.A"/>
</f></scanr1>
		<elements public="1" params="A:B" set="method" line="205" static="1"><f a="foldable">
	<c path="haxe.functional.Foldable">
		<c path="elements.A"/>
		<c path="elements.B"/>
	</c>
	<t path="Iterable"><c path="elements.B"/></t>
</f></elements>
		<concat public="1" params="A:B" set="method" line="209" static="1"><f a="foldable:rest">
	<c path="haxe.functional.Foldable">
		<c path="concat.A"/>
		<c path="concat.B"/>
	</c>
	<c path="haxe.functional.Foldable">
		<c path="concat.A"/>
		<c path="concat.B"/>
	</c>
	<c path="concat.A"/>
</f></concat>
		<append public="1" params="A:B" set="method" line="215" static="1"><f a="foldable:e">
	<c path="haxe.functional.Foldable">
		<c path="append.A"/>
		<c path="append.B"/>
	</c>
	<c path="append.B"/>
	<c path="append.A"/>
</f></append>
		<appendAll public="1" params="A:B" set="method" line="219" static="1"><f a="foldable:i">
	<c path="haxe.functional.Foldable">
		<c path="appendAll.A"/>
		<c path="appendAll.B"/>
	</c>
	<t path="Iterable"><c path="appendAll.B"/></t>
	<c path="appendAll.A"/>
</f></appendAll>
		<iterator public="1" params="A:B" set="method" line="227" static="1"><f a="foldable">
	<c path="haxe.functional.Foldable">
		<c path="iterator.A"/>
		<c path="iterator.B"/>
	</c>
	<t path="Iterator"><c path="iterator.B"/></t>
</f></iterator>
		<isEmpty public="1" params="A:B" set="method" line="231" static="1"><f a="foldable">
	<c path="haxe.functional.Foldable">
		<c path="isEmpty.A"/>
		<c path="isEmpty.B"/>
	</c>
	<e path="Bool"/>
</f></isEmpty>
		<forEach public="1" params="A:B" set="method" line="235" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="forEach.A"/>
		<c path="forEach.B"/>
	</c>
	<f a="">
		<c path="forEach.B"/>
		<e path="Void"/>
	</f>
	<c path="haxe.functional.Foldable">
		<c path="forEach.A"/>
		<c path="forEach.B"/>
	</c>
</f></forEach>
		<find public="1" params="A:B" set="method" line="241" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="find.A"/>
		<c path="find.B"/>
	</c>
	<f a="">
		<c path="find.B"/>
		<e path="Bool"/>
	</f>
	<e path="Option"><c path="find.B"/></e>
</f></find>
		<forAll public="1" params="A:B" set="method" line="251" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="forAll.A"/>
		<c path="forAll.B"/>
	</c>
	<f a="">
		<c path="forAll.B"/>
		<e path="Bool"/>
	</f>
	<e path="Bool"/>
</f></forAll>
		<forAny public="1" params="A:B" set="method" line="260" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="forAny.A"/>
		<c path="forAny.B"/>
	</c>
	<f a="">
		<c path="forAny.B"/>
		<e path="Bool"/>
	</f>
	<e path="Bool"/>
</f></forAny>
		<exists public="1" params="A:B" set="method" line="269" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="exists.A"/>
		<c path="exists.B"/>
	</c>
	<f a="">
		<c path="exists.B"/>
		<e path="Bool"/>
	</f>
	<e path="Bool"/>
</f></exists>
		<existsP public="1" params="A:B" set="method" line="276" static="1"><f a="foldable:ref:f">
	<c path="haxe.functional.Foldable">
		<c path="existsP.A"/>
		<c path="existsP.B"/>
	</c>
	<c path="existsP.B"/>
	<f a=":">
		<c path="existsP.B"/>
		<c path="existsP.B"/>
		<e path="Bool"/>
	</f>
	<e path="Bool"/>
</f></existsP>
		<contains public="1" params="A:B" set="method" line="288" static="1"><f a="foldable:member">
	<c path="haxe.functional.Foldable">
		<c path="contains.A"/>
		<c path="contains.B"/>
	</c>
	<c path="contains.B"/>
	<e path="Bool"/>
</f></contains>
		<nubBy public="1" params="A:B" set="method" line="292" static="1"><f a="foldable:f">
	<c path="haxe.functional.Foldable">
		<c path="nubBy.A"/>
		<c path="nubBy.B"/>
	</c>
	<f a=":">
		<c path="nubBy.B"/>
		<c path="nubBy.B"/>
		<e path="Bool"/>
	</f>
	<c path="nubBy.A"/>
</f></nubBy>
		<nub public="1" params="A:B" set="method" line="303" static="1"><f a="foldable">
	<c path="haxe.functional.Foldable">
		<c path="nub.A"/>
		<c path="nub.B"/>
	</c>
	<c path="nub.A"/>
</f></nub>
		<intersectBy public="1" params="A:B" set="method" line="309" static="1"><f a="foldable1:foldable2:f">
	<c path="haxe.functional.Foldable">
		<c path="intersectBy.A"/>
		<c path="intersectBy.B"/>
	</c>
	<c path="haxe.functional.Foldable">
		<c path="intersectBy.A"/>
		<c path="intersectBy.B"/>
	</c>
	<f a=":">
		<c path="intersectBy.B"/>
		<c path="intersectBy.B"/>
		<e path="Bool"/>
	</f>
	<c path="intersectBy.A"/>
</f></intersectBy>
		<intersect public="1" params="A:B" set="method" line="315" static="1"><f a="foldable1:foldable2">
	<c path="haxe.functional.Foldable">
		<c path="intersect.A"/>
		<c path="intersect.B"/>
	</c>
	<c path="haxe.functional.Foldable">
		<c path="intersect.A"/>
		<c path="intersect.B"/>
	</c>
	<c path="intersect.A"/>
</f></intersect>
		<mkString public="1" params="A:B" set="method" line="321" static="1"><f a="foldable:?sep:?show">
	<c path="haxe.functional.Foldable">
		<c path="mkString.A"/>
		<c path="mkString.B"/>
	</c>
	<c path="String"/>
	<f a="">
		<c path="mkString.B"/>
		<c path="String"/>
	</f>
	<c path="String"/>
</f></mkString>
		<groupBy public="1" params="C:T:K" set="method" line="332" static="1"><f a="foldable:grouper">
	<c path="haxe.functional.Foldable">
		<c path="groupBy.C"/>
		<c path="groupBy.T"/>
	</c>
	<f a="">
		<c path="groupBy.T"/>
		<c path="groupBy.K"/>
	</f>
	<c path="haxe.data.collections.Map">
		<c path="groupBy.K"/>
		<c path="groupBy.C"/>
	</c>
</f></groupBy>
		<toArray public="1" params="A:B" set="method" line="341" static="1"><f a="foldable">
	<c path="haxe.functional.Foldable">
		<c path="toArray.A"/>
		<c path="toArray.B"/>
	</c>
	<c path="Array"><c path="toArray.B"/></c>
</f></toArray>
		<toMap public="1" params="A:K:V" set="method" line="349" static="1"><f a="foldable">
	<c path="haxe.functional.Foldable">
		<c path="toMap.A"/>
		<c path="Tuple2">
			<c path="toMap.K"/>
			<c path="toMap.V"/>
		</c>
	</c>
	<c path="haxe.data.collections.Map">
		<c path="toMap.K"/>
		<c path="toMap.V"/>
	</c>
</f></toMap>
		<toList public="1" params="A:B" set="method" line="356" static="1"><f a="foldable">
	<c path="haxe.functional.Foldable">
		<c path="toList.A"/>
		<c path="toList.B"/>
	</c>
	<c path="haxe.data.collections.List"><c path="toList.B"/></c>
</f></toList>
		<toSet public="1" params="A:B" set="method" line="363" static="1"><f a="foldable">
	<c path="haxe.functional.Foldable">
		<c path="toSet.A"/>
		<c path="toSet.B"/>
	</c>
	<c path="haxe.data.collections.Set"><c path="toSet.B"/></c>
</f></toSet>
	</class>
	<class path="haxe.reactive.StreamBool" params="" file="../src/main/haxe/haxe/reactive/StreamBool.hx">
		<not public="1" set="method" line="29" static="1">
			<f a="stream">
				<c path="haxe.reactive.Stream"><e path="Bool"/></c>
				<c path="haxe.reactive.Stream"><e path="Bool"/></c>
			</f>
			<haxe_doc>
     * Returns a stream with the Bool of each value mapped to the
     * opposite of the original stream.
     </haxe_doc>
		</not>
		<ifTrue public="1" params="T" set="method" line="52" static="1">
			<f a="stream:thenE:elseE">
				<c path="haxe.reactive.Stream"><e path="Bool"/></c>
				<c path="haxe.reactive.Stream"><c path="ifTrue.T"/></c>
				<c path="haxe.reactive.Stream"><c path="ifTrue.T"/></c>
				<c path="haxe.reactive.Stream"><c path="ifTrue.T"/></c>
			</f>
			<haxe_doc><![CDATA[
     * Switches off of an Stream of Bools, returning
     * either a thenE Stream<T> when true or an elseE 
     * when falseStream<T>.
     * 
     *
     * @param stream        An Stream of Bools that will 
     *                      be used to determine which 
     *                      Stream to return.
     *
     * @param thenE         The Stream that will be returned 
     *                      if stream == true;
     *
     * @param elseE         The Stream that will be returned 
      *                      if stream == false;
     *
     * @return              If an event from stream == true
     *                      stream thenE, else stream elseE
     ]]></haxe_doc>
		</ifTrue>
		<and public="1" set="method" line="99" static="1">
			<f a="streams">
				<t path="Iterable"><c path="haxe.reactive.Stream"><e path="Bool"/></c></t>
				<c path="haxe.reactive.Stream"><e path="Bool"/></c>
			</f>
			<haxe_doc><![CDATA[
     * Returns an Stream, the events of which are either
     * true or false, depending on whether or not the supplied 
     * Iterable<Stream<Bool>>'s values are all true for a 
     * given time step.
     *
     * @param streams       An Iterable of the Streams to 
     *                      be evaluated
     *
     * @return              An Stream of Bools, where each 
     *                      Bool event represents whether or not 
     *                      all events in the supplied 
     *                      Iterable<Stream<Bool>> are true 
     *                      on a given time step.
     ]]></haxe_doc>
		</and>
		<or public="1" set="method" line="131" static="1">
			<f a="streams">
				<t path="Iterable"><c path="haxe.reactive.Stream"><e path="Bool"/></c></t>
				<c path="haxe.reactive.Stream"><e path="Bool"/></c>
			</f>
			<haxe_doc><![CDATA[
     * Returns an Stream, the events of which are either
     * true or false, depending on whether or not any of the 
     * values in the supplied Iterable<Stream<Bool>> 
     * are all true for a given time step.
     *
     * @param streams       An Iterable of the Streams to 
     *                      be evaluated
     *
     * @return              An Stream of Bools, where each 
     *                      Bool event represents whether or not 
     *                      any events in the supplied 
     *                      Iterable<Stream<Bool>> are true 
     *                      on a given time step.
     ]]></haxe_doc>
		</or>
		<new set="method" line="23"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.data.collections.MapExtensions" params="" file="../src/main/haxe/haxe/data/collections/MapExtensions.hx"><toObject public="1" params="V" set="method" line="29" static="1"><f a="map">
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="toObject.V"/>
	</c>
	<d><c path="toObject.V"/></d>
</f></toObject></class>
	<class path="Date" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/neko/_std/Date.hx">
		<now public="1" set="method" line="72" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromTime public="1" set="method" line="76" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="84" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<new1 set="method" line="88" static="1"><f a="t">
	<d/>
	<c path="Date"/>
</f></new1>
		<date_new line="94" static="1"><f a="">
	<unknown/>
	<unknown/>
</f></date_new>
		<date_now line="95" static="1"><f a=""><unknown/></f></date_now>
		<date_format line="96" static="1"><f a=":">
	<d/>
	<unknown/>
	<c path="String"/>
</f></date_format>
		<date_set_hour line="97" static="1"><f a=":::">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></date_set_hour>
		<date_set_day line="98" static="1"><f a=":::">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></date_set_day>
		<date_get_day line="99" static="1"><f a="">
	<d/>
	<a>
		<y><c path="Int"/></y>
		<m><c path="Int"/></m>
		<d><c path="Int"/></d>
	</a>
</f></date_get_day>
		<date_get_hour line="100" static="1"><f a="">
	<d/>
	<a>
		<s><c path="Int"/></s>
		<m><c path="Int"/></m>
		<h><c path="Int"/></h>
	</a>
</f></date_get_hour>
		<int32_to_float line="101" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></int32_to_float>
		<int32_add line="102" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<unknown/>
</f></int32_add>
		<int32_shl line="103" static="1"><f a=":">
	<unknown/>
	<c path="Int"/>
	<unknown/>
</f></int32_shl>
		<__string set="method" line="104" static="1"><f a=""><c path="String"/></f></__string>
		<__t><d/></__t>
		<getTime public="1" set="method" line="36">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getFullYear public="1" set="method" line="40">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method" line="44">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1" set="method" line="48">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getHours public="1" set="method" line="52">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method" line="56">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method" line="60">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getDay public="1" set="method" line="64">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1" set="method" line="68">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1" set="method" line="31"><f a="year:month:day:hour:min:sec">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="StringTools" params="" file="C:\World\Stack\os\win\programs\lingos\haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="38" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="80" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="87" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="98" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="105" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="114" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="122" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="141" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="161" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="172" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="194" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="219" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" set="method" line="230" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="253" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.
	</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="270" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<_urlEncode line="285" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></_urlEncode>
		<_urlDecode line="286" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></_urlDecode>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<class path="haxe.data.collections.Map" params="K:V" file="../src/main/haxe/haxe/data/collections/Map.hx">
		<implements path="haxe.functional.PartialFunction1">
			<c path="haxe.data.collections.Map.K"/>
			<c path="haxe.data.collections.Map.V"/>
		</implements>
		<implements path="haxe.data.collections.Collection">
			<c path="haxe.data.collections.Map">
				<c path="haxe.data.collections.Map.K"/>
				<c path="haxe.data.collections.Map.V"/>
			</c>
			<c path="Tuple2">
				<c path="haxe.data.collections.Map.K"/>
				<c path="haxe.data.collections.Map.V"/>
			</c>
		</implements>
		<MaxLoad public="1" line="38" static="1"><c path="Int"/></MaxLoad>
		<MinLoad public="1" line="39" static="1"><c path="Int"/></MinLoad>
		<create public="1" params="K:V" set="method" line="55" static="1"><f a="?korder:?kequal:?khash:?kshow:?vorder:?vequal:?vhash:?vshow">
	<t path="OrderFunction"><c path="create.K"/></t>
	<t path="EqualFunction"><c path="create.K"/></t>
	<t path="HashFunction"><c path="create.K"/></t>
	<t path="ShowFunction"><c path="create.K"/></t>
	<t path="OrderFunction"><c path="create.V"/></t>
	<t path="EqualFunction"><c path="create.V"/></t>
	<t path="HashFunction"><c path="create.V"/></t>
	<t path="ShowFunction"><c path="create.V"/></t>
	<c path="haxe.data.collections.Map">
		<c path="create.K"/>
		<c path="create.V"/>
	</c>
</f></create>
		<factory public="1" params="K:V" set="method" line="60" static="1">
			<f a="?korder:?kequal:?khash:?kshow:?vorder:?vequal:?vhash:?vshow">
				<t path="OrderFunction"><c path="factory.K"/></t>
				<t path="EqualFunction"><c path="factory.K"/></t>
				<t path="HashFunction"><c path="factory.K"/></t>
				<t path="ShowFunction"><c path="factory.K"/></t>
				<t path="OrderFunction"><c path="factory.V"/></t>
				<t path="EqualFunction"><c path="factory.V"/></t>
				<t path="HashFunction"><c path="factory.V"/></t>
				<t path="ShowFunction"><c path="factory.V"/></t>
				<t path="Factory"><c path="haxe.data.collections.Map">
	<c path="factory.K"/>
	<c path="factory.V"/>
</c></t>
			</f>
			<haxe_doc> Creates a factory for maps of the specified types. </haxe_doc>
		</factory>
		<extract public="1" params="K:V" set="method" line="340" static="1"><f a="v:ke:ve:?korder:?kequal:?khash:?kshow:?vorder:?vequal:?vhash:?vshow">
	<e path="haxe.text.json.JValue"/>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.K"/></t>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extract.V"/></t>
	<t path="OrderFunction"><c path="extract.K"/></t>
	<t path="EqualFunction"><c path="extract.K"/></t>
	<t path="HashFunction"><c path="extract.K"/></t>
	<t path="ShowFunction"><c path="extract.K"/></t>
	<t path="OrderFunction"><c path="extract.V"/></t>
	<t path="EqualFunction"><c path="extract.V"/></t>
	<t path="HashFunction"><c path="extract.V"/></t>
	<t path="ShowFunction"><c path="extract.V"/></t>
	<c path="haxe.data.collections.Map">
		<c path="extract.K"/>
		<c path="extract.V"/>
	</c>
</f></extract>
		<keyEqual public="1" get="getKeyEqual" set="null"><t path="EqualFunction"><c path="haxe.data.collections.Map.K"/></t></keyEqual>
		<keyOrder public="1" get="getKeyOrder" set="null"><t path="OrderFunction"><c path="haxe.data.collections.Map.K"/></t></keyOrder>
		<keyHash public="1" get="getKeyHash" set="null"><t path="HashFunction"><c path="haxe.data.collections.Map.K"/></t></keyHash>
		<keyShow public="1" get="getKeyShow" set="null"><t path="ShowFunction"><c path="haxe.data.collections.Map.K"/></t></keyShow>
		<valueEqual public="1" get="getValueEqual" set="null"><t path="EqualFunction"><c path="haxe.data.collections.Map.V"/></t></valueEqual>
		<valueOrder public="1" get="getValueOrder" set="null"><t path="OrderFunction"><c path="haxe.data.collections.Map.V"/></t></valueOrder>
		<valueHash public="1" get="getValueHash" set="null"><t path="HashFunction"><c path="haxe.data.collections.Map.V"/></t></valueHash>
		<valueShow public="1" get="getValueShow" set="null"><t path="ShowFunction"><c path="haxe.data.collections.Map.V"/></t></valueShow>
		<_buckets><c path="Array"><c path="Array"><c path="Tuple2">
	<c path="haxe.data.collections.Map.K"/>
	<c path="haxe.data.collections.Map.V"/>
</c></c></c></_buckets>
		<_size><c path="Int"/></_size>
		<_pf><c path="haxe.functional.PartialFunction1">
	<c path="haxe.data.collections.Map.K"/>
	<c path="haxe.data.collections.Map.V"/>
</c></_pf>
		<isDefinedAt public="1" set="method" line="85"><f a="k">
	<c path="haxe.data.collections.Map.K"/>
	<e path="Bool"/>
</f></isDefinedAt>
		<orElse public="1" set="method" line="89"><f a="that">
	<c path="haxe.functional.PartialFunction1">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
	<c path="haxe.functional.PartialFunction1">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></orElse>
		<orAlways public="1" set="method" line="93"><f a="f">
	<f a="">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</f>
	<c path="haxe.functional.PartialFunction1">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></orAlways>
		<orAlwaysC public="1" set="method" line="97"><f a="v">
	<t path="Thunk"><c path="haxe.data.collections.Map.V"/></t>
	<c path="haxe.functional.PartialFunction1">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></orAlwaysC>
		<call public="1" set="method" line="101"><f a="k">
	<c path="haxe.data.collections.Map.K"/>
	<c path="haxe.data.collections.Map.V"/>
</f></call>
		<toFunction public="1" set="method" line="105"><f a=""><f a="">
	<c path="haxe.data.collections.Map.K"/>
	<e path="Option"><c path="haxe.data.collections.Map.V"/></e>
</f></f></toFunction>
		<empty public="1" params="C:D" set="method" line="109"><f a=""><c path="haxe.functional.Foldable">
	<c path="empty.C"/>
	<c path="empty.D"/>
</c></f></empty>
		<append public="1" set="method" line="113"><f a="t">
	<c path="Tuple2">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></append>
		<foldl public="1" params="Z" set="method" line="117"><f a="z:f">
	<c path="foldl.Z"/>
	<f a=":">
		<c path="foldl.Z"/>
		<c path="Tuple2">
			<c path="haxe.data.collections.Map.K"/>
			<c path="haxe.data.collections.Map.V"/>
		</c>
		<c path="foldl.Z"/>
	</f>
	<c path="foldl.Z"/>
</f></foldl>
		<set public="1" set="method" line="127"><f a="k:v">
	<c path="haxe.data.collections.Map.K"/>
	<c path="haxe.data.collections.Map.V"/>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></set>
		<add public="1" set="method" line="131"><f a="t">
	<c path="Tuple2">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></add>
		<addAll public="1" set="method" line="171"><f a="i">
	<t path="Iterable"><c path="Tuple2">
	<c path="haxe.data.collections.Map.K"/>
	<c path="haxe.data.collections.Map.V"/>
</c></t>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></addAll>
		<remove public="1" set="method" line="179"><f a="t">
	<c path="Tuple2">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></remove>
		<removeAll public="1" set="method" line="183"><f a="i">
	<t path="Iterable"><c path="Tuple2">
	<c path="haxe.data.collections.Map.K"/>
	<c path="haxe.data.collections.Map.V"/>
</c></t>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></removeAll>
		<removeByKey public="1" set="method" line="191"><f a="k">
	<c path="haxe.data.collections.Map.K"/>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></removeByKey>
		<removeAllByKey public="1" set="method" line="195"><f a="i">
	<t path="Iterable"><c path="haxe.data.collections.Map.K"/></t>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></removeAllByKey>
		<get public="1" set="method" line="203"><f a="k">
	<c path="haxe.data.collections.Map.K"/>
	<e path="Option"><c path="haxe.data.collections.Map.V"/></e>
</f></get>
		<getOrElse public="1" set="method" line="213"><f a="k:def">
	<c path="haxe.data.collections.Map.K"/>
	<t path="Thunk"><c path="haxe.data.collections.Map.V"/></t>
	<c path="haxe.data.collections.Map.V"/>
</f></getOrElse>
		<getOrElseC public="1" set="method" line="220"><f a="k:c">
	<c path="haxe.data.collections.Map.K"/>
	<c path="haxe.data.collections.Map.V"/>
	<c path="haxe.data.collections.Map.V"/>
</f></getOrElseC>
		<contains public="1" set="method" line="227"><f a="t">
	<c path="Tuple2">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
	<e path="Bool"/>
</f></contains>
		<containsKey public="1" set="method" line="237"><f a="k">
	<c path="haxe.data.collections.Map.K"/>
	<e path="Bool"/>
</f></containsKey>
		<keys public="1" set="method" line="244"><f a=""><t path="Iterable"><c path="haxe.data.collections.Map.K"/></t></f></keys>
		<keySet public="1" set="method" line="262"><f a=""><c path="haxe.data.collections.Set"><c path="haxe.data.collections.Map.K"/></c></f></keySet>
		<values public="1" set="method" line="266"><f a=""><t path="Iterable"><c path="haxe.data.collections.Map.V"/></t></f></values>
		<iterator public="1" set="method" line="284"><f a=""><t path="Iterator"><c path="Tuple2">
	<c path="haxe.data.collections.Map.K"/>
	<c path="haxe.data.collections.Map.V"/>
</c></t></f></iterator>
		<compare public="1" set="method" line="288"><f a="other">
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
	<c path="Int"/>
</f></compare>
		<equals public="1" set="method" line="309"><f a="other">
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
	<e path="Bool"/>
</f></equals>
		<toString public="1" set="method" line="324"><f a=""><c path="String"/></f></toString>
		<hashCode public="1" set="method" line="330"><f a=""><c path="Int"/></f></hashCode>
		<decompose public="1" set="method" line="336"><f a=""><e path="haxe.text.json.JValue"/></f></decompose>
		<load public="1" set="method" line="350"><f a=""><c path="Int"/></f></load>
		<withKeyOrderFunction public="1" set="method" line="355"><f a="order">
	<t path="OrderFunction"><c path="haxe.data.collections.Map.K"/></t>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></withKeyOrderFunction>
		<withKeyEqualFunction public="1" set="method" line="359"><f a="equal">
	<t path="EqualFunction"><c path="haxe.data.collections.Map.K"/></t>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></withKeyEqualFunction>
		<withKeyHashFunction public="1" set="method" line="363"><f a="hash">
	<t path="HashFunction"><c path="haxe.data.collections.Map.K"/></t>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></withKeyHashFunction>
		<withKeyShowFunction public="1" set="method" line="367"><f a="show">
	<t path="ShowFunction"><c path="haxe.data.collections.Map.K"/></t>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></withKeyShowFunction>
		<withValueOrderFunction public="1" set="method" line="371"><f a="order">
	<t path="OrderFunction"><c path="haxe.data.collections.Map.V"/></t>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></withValueOrderFunction>
		<withValueEqualFunction public="1" set="method" line="375"><f a="equal">
	<t path="EqualFunction"><c path="haxe.data.collections.Map.V"/></t>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></withValueEqualFunction>
		<withValueHashFunction public="1" set="method" line="379"><f a="hash">
	<t path="HashFunction"><c path="haxe.data.collections.Map.V"/></t>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></withValueHashFunction>
		<withValueShowFunction public="1" set="method" line="383"><f a="show">
	<t path="ShowFunction"><c path="haxe.data.collections.Map.V"/></t>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></withValueShowFunction>
		<entries set="method" line="387"><f a=""><t path="Iterable"><c path="Tuple2">
	<c path="haxe.data.collections.Map.K"/>
	<c path="haxe.data.collections.Map.V"/>
</c></t></f></entries>
		<removeInternal set="method" line="429"><f a="k:v:ignoreValue">
	<c path="haxe.data.collections.Map.K"/>
	<c path="haxe.data.collections.Map.V"/>
	<e path="Bool"/>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></removeInternal>
		<copyWithMod set="method" line="462"><f a="index">
	<c path="Int"/>
	<c path="haxe.data.collections.Map">
		<c path="haxe.data.collections.Map.K"/>
		<c path="haxe.data.collections.Map.V"/>
	</c>
</f></copyWithMod>
		<rebalance set="method" line="478"><f a=""><e path="Void"/></f></rebalance>
		<bucketFor set="method" line="498"><f a="k">
	<c path="haxe.data.collections.Map.K"/>
	<c path="Int"/>
</f></bucketFor>
		<listFor set="method" line="502"><f a="k">
	<c path="haxe.data.collections.Map.K"/>
	<c path="Array"><c path="Tuple2">
	<c path="haxe.data.collections.Map.K"/>
	<c path="haxe.data.collections.Map.V"/>
</c></c>
</f></listFor>
		<size public="1" set="method" line="507"><f a=""><c path="Int"/></f></size>
		<_keyEqual><t path="EqualFunction"><c path="haxe.data.collections.Map.K"/></t></_keyEqual>
		<_keyOrder><t path="OrderFunction"><c path="haxe.data.collections.Map.K"/></t></_keyOrder>
		<_keyHash><t path="HashFunction"><c path="haxe.data.collections.Map.K"/></t></_keyHash>
		<_keyShow><t path="ShowFunction"><c path="haxe.data.collections.Map.K"/></t></_keyShow>
		<_valueEqual><t path="EqualFunction"><c path="haxe.data.collections.Map.V"/></t></_valueEqual>
		<_valueOrder><t path="OrderFunction"><c path="haxe.data.collections.Map.V"/></t></_valueOrder>
		<_valueHash><t path="HashFunction"><c path="haxe.data.collections.Map.V"/></t></_valueHash>
		<_valueShow><t path="ShowFunction"><c path="haxe.data.collections.Map.V"/></t></_valueShow>
		<getKeyOrder set="method" line="519"><f a=""><t path="OrderFunction"><c path="haxe.data.collections.Map.K"/></t></f></getKeyOrder>
		<getKeyEqual set="method" line="529"><f a=""><t path="EqualFunction"><c path="haxe.data.collections.Map.K"/></t></f></getKeyEqual>
		<getKeyHash set="method" line="539"><f a=""><t path="HashFunction"><c path="haxe.data.collections.Map.K"/></t></f></getKeyHash>
		<getKeyShow set="method" line="549"><f a=""><t path="ShowFunction"><c path="haxe.data.collections.Map.K"/></t></f></getKeyShow>
		<getValueOrder set="method" line="559"><f a=""><t path="OrderFunction"><c path="haxe.data.collections.Map.V"/></t></f></getValueOrder>
		<getValueEqual set="method" line="569"><f a=""><t path="EqualFunction"><c path="haxe.data.collections.Map.V"/></t></f></getValueEqual>
		<getValueHash set="method" line="579"><f a=""><t path="HashFunction"><c path="haxe.data.collections.Map.V"/></t></f></getValueHash>
		<getValueShow set="method" line="589"><f a=""><t path="ShowFunction"><c path="haxe.data.collections.Map.V"/></t></f></getValueShow>
		<new set="method" line="66"><f a="korder:kequal:khash:kshow:vorder:vequal:vhash:vshow:buckets:size">
	<t path="OrderFunction"><c path="haxe.data.collections.Map.K"/></t>
	<t path="EqualFunction"><c path="haxe.data.collections.Map.K"/></t>
	<t path="HashFunction"><c path="haxe.data.collections.Map.K"/></t>
	<t path="ShowFunction"><c path="haxe.data.collections.Map.K"/></t>
	<t path="OrderFunction"><c path="haxe.data.collections.Map.V"/></t>
	<t path="EqualFunction"><c path="haxe.data.collections.Map.V"/></t>
	<t path="HashFunction"><c path="haxe.data.collections.Map.V"/></t>
	<t path="ShowFunction"><c path="haxe.data.collections.Map.V"/></t>
	<c path="Array"><c path="Array"><c path="Tuple2">
	<c path="haxe.data.collections.Map.K"/>
	<c path="haxe.data.collections.Map.V"/>
</c></c></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc> A cross-platform, immutable map with support for arbitrary keys.
 * TODO: Use an array of lists to avoid unnecessary copying when adding/removing elements.
 </haxe_doc>
	</class>
	<class path="haxe.data.transcode.ExtractorHelpers" params="" file="../src/main/haxe/haxe/data/transcode/TranscodeJValueExtensions.hx" module="haxe.data.transcode.TranscodeJValueExtensions"><extractFieldValue public="1" params="T" set="method" line="35" static="1"><f a="j:n:e:def">
	<e path="haxe.text.json.JValue"/>
	<c path="String"/>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="extractFieldValue.T"/></t>
	<e path="haxe.text.json.JValue"/>
	<c path="extractFieldValue.T"/>
</f></extractFieldValue></class>
	<class path="haxe.data.transcode.MapExtensions" params="" file="../src/main/haxe/haxe/data/transcode/TranscodeJValueExtensions.hx" module="haxe.data.transcode.TranscodeJValueExtensions">
		<stringKeyDecompose public="1" params="V" set="method" line="48" static="1"><f a="v">
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="stringKeyDecompose.V"/>
	</c>
	<e path="haxe.text.json.JValue"/>
</f></stringKeyDecompose>
		<stringKeyExtract public="1" params="V" set="method" line="59" static="1"><f a="v:ve:?vorder:?vequal:?vhash:?vshow">
	<e path="haxe.text.json.JValue"/>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="stringKeyExtract.V"/></t>
	<t path="OrderFunction"><c path="stringKeyExtract.V"/></t>
	<t path="EqualFunction"><c path="stringKeyExtract.V"/></t>
	<t path="HashFunction"><c path="stringKeyExtract.V"/></t>
	<t path="ShowFunction"><c path="stringKeyExtract.V"/></t>
	<c path="haxe.data.collections.Map">
		<c path="String"/>
		<c path="stringKeyExtract.V"/>
	</c>
</f></stringKeyExtract>
	</class>
	<class path="haxe.data.transcode.TranscodeJValue" params="" file="../src/main/haxe/haxe/data/transcode/TranscodeJValueExtensions.hx" module="haxe.data.transcode.TranscodeJValueExtensions">
		<_createDecomposeImpl params="T" set="method" line="80" static="1"><f a="impl">
	<t path="haxe.data.transcode.JDecomposerFunction"><d/></t>
	<f a="v">
		<c path="_createDecomposeImpl.T"/>
		<e path="haxe.text.json.JValue"/>
	</f>
</f></_createDecomposeImpl>
		<getDecomposerFor public="1" params="T" set="method" line="82" static="1"><f a="v">
	<e path="ValueType"/>
	<t path="haxe.data.transcode.JDecomposerFunction"><c path="getDecomposerFor.T"/></t>
</f></getDecomposerFor>
		<_createExtractorImpl params="T" set="method" line="130" static="1"><f a="impl">
	<t path="haxe.data.transcode.JExtractorFunction"><d/></t>
	<f a="v">
		<e path="haxe.text.json.JValue"/>
		<c path="getExtractorFor.T"/>
	</f>
</f></_createExtractorImpl>
		<getExtractorFor public="1" params="T" set="method" line="132" static="1"><f a="valueType:?extractorArgs">
	<e path="ValueType"/>
	<c path="Array"><d/></c>
	<t path="haxe.data.transcode.JExtractorFunction"><c path="getExtractorFor.T"/></t>
</f></getExtractorFor>
	</class>
</haxe>