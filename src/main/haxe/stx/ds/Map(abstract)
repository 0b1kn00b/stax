package stx.ds;

import stx.plus.Order;
import stx.plus.Hasher;

import stx.Fails.*;
import stx.Tuples;
import stx.Prelude;
import stx.ds.Collection;
import stx.ds.ListUtil;
import stx.Anys;
import stx.Functions;
import stx.Compare;
import haxe.ds.IntMap;

using stx.Iterators;
using stx.Iterables;
using stx.ds.List;
using stx.Options;
using stx.Tuples;
using stx.Compose;

/**
*/
typedef MapType<K,V> = IntMap<Tuple2<K,V>>;

abstract Map<K,V>(MapType<K, V>) from MapType<K, V> to MapType<K, V> {

    @:noUsing static public function create<K,V>():Map<K,V>{
        return new Map();
    }
    inline function new(?map : MapType<K, V>) {
        this = Options.orDefault(map,new IntMap());
    }

    inline public function iterator() : Iterator<Tuple2<K, V>> return MapTypes.iterator(this);

    @:to
    inline public static function toMap<K,V>(map : MapType<K, V>) : IntMap<Tuple2<K,V>> return MapTypes.toMap(map);

    @:to
    inline public static function toArray<K,V>(map : MapType<K, V>) : Array<Tuple2<K, V>> {
        var stack = [];
        for(i in MapTypes.iterator(map)) stack.push(i);
        return stack;
    }

    @:to
    inline public static function toCollection<K,V>(map : MapType<K, V>) : Collection<Tuple2<K, V>> {
        return new IntMapPlus(map);
    }

    @:to
    inline public static function toString<K,V>(map : MapType<K, V>) : String return MapTypes.toString(map);

    @:from
    inline public static function fromArray<K,V>(arr : Array<Tuple2<K,V>> ) : Map<K,V>{
        var m = new Map();
        arr.foreach(MapTypes.add.bind(m).tupled());
        return m;
    }
}

class MapTypes {
    public static function equals<K,V>(self:Map<K,V>,other:Map<K,V>):Bool{
        var o_hsh = null;
        var o_val = null;

        var g_o_hsh = function(x) {return o_hsh == null ? o_hsh = Equal.getEqualFor(x) : o_hsh ;}
        var g_o_val = function(x) {return o_val == null ? o_val = Equal.getEqualFor(x) : o_val ;}


        var hsh = null;
        var val = null;

        var g_hsh = function(x) {return hsh == null ? hsh = Equal.getEqualFor(x) : hsh ;}
        var g_val = function(x) {return val == null ? val = Equal.getEqualFor(x) : val ;}


        for(key in keys(self)) {
            var v1 = this.get(key);
            var v2 = other.get(key);
        }
    }
    public static function add<K,V>(map : Map<K, V>, key : K, value : V) : Map<K, V> {
        return nativeMap(map, key, value, function(m) {
            m.set(Hasher.getHashFor(key)(key), tuple2(key,value));
            return m;
        });
    }

    public static function append<K,V>(map : Map<K, V>, maps : Map<K, V>) : Map<K, V> {
        foreach(maps, function(tuple : Tuple2<K, V>) {
            map = add(map, tuple.fst(), tuple.snd());
        });
        return map;
    }

    public static function exists<K,V>(map : Map<K, V>, key : K) : Bool {
        return switch (map) {
            case Cons(k, _, _) if(k == key): true;
            case Cons(_, _, m): m.exists(key);
            case _: false;
        }
    }

    public static function get<K,V>(map : Map<K, V>, key : K) : Option<V> {
        var ky = Hasher.getHashFor(key)(key);
        return switch (map) {
            case Cons(k, v, _) if(ky == key): Some(v);
            case Cons(_, _, m): Options.toOption(m.get(ky)).map(T2s.snd);
            case _: None;
        }
    }

    public static function forall<K,V>(map : Map<K, V>, func : Predicate1<Tuple2<K, V>>) : Bool {
        var result = false;
        for(i in nativeKeys(map)) {
            if(func(tuple2(i, nativeGet(map, i)))){
                result = true;
                break;
            }
        }
        return result;
    }

    public static function foreach<K,V>(map : Map<K, V>, func : Function1<Tuple2<K, V>, Void>) : Void {
        for(i in nativeKeys(map)) {
            func(tuple2(i, nativeGet(map, i)));
        }
    }

    public static function indices<K,V>(map : Map<K, V>) : List<K> {
        return ListType.Nil.prependIterator(nativeKeys(map));
    }

    public static function values<K,V>(map : Map<K, V>) : List<V> {
        return ListType.Nil.prependIterator(nativeValues(map));
    }

    public static function map<K1 : String, V1, K2 : String, V2>(   map : Map<K1, V1>,
                                                                    func : Function1<Tuple2<K1, V1>, Tuple2<K2, V2>>
                                                                    ) : Map<K2, V2> {
        var result = Nil;
        for(i in nativeKeys(map)) {
            var f = func(tuple2(i, nativeGet(map, i)));
            result = add(result, f.fst(), f.snd());
        }
        return result;
    }

    public static function remove<K,V>(map : Map<K, V>, key : K) : Map<K, V> {
        var result = Nil;
        for(i in nativeKeys(map)) {
            if(i != key) {
                result = add(result, i, nativeGet(map, i));
            }
        }
        return result;
    }
    public static function contains<K,V>(map : Map<K,V>, key : K ) : Bool{
        return get.bind(map).then(Predicates.isNotNull())(key);
    }
    public static function filter<K,V>(map : Map<K,V>, fn :Tuple2<K,V> -> Bool) : Map<K,V> {
        var n : Map<K,V> = Nil;
        SIterables.foreach(iterable(map),
            function(kv:Tuple2<K,V>){
                if(fn(kv)){
                    MapTypes.add(n,kv.fst(),kv.snd());
                }
            }
        );
        return n;
    }
    public static function hashCode<K,V>(map:Map<K, V>):Int{
        var hsh = null;
        var val = null;
        var g_hsh = function(x) {return hsh == null ? hsh = Hasher.getHashFor(x) : hsh ;}
        var g_val = function(x) {return val == null ? val = Hasher.getHashFor(x) : val ;}
        return SIterables.foldl(iterable(map),786433, function(a, b) return a + (g_hsh(b.fst())(b.fst()) * 49157 + 6151) * g_val(b.snd())(b.snd()));
    }
    public static function compare<K,V>(self: Map<K,V>, other : Map<K, V>) : Int{
        var kodr = null;
        var vodr = null;
        var g_hsh = inline function(x) {return kodr == null ? kodr = Order.getOrderFor(x) : kodr;}
        var g_val = inline function(x) {return vodr == null ? vodr = Order.getOrderFor(x) : vodr;}
    
        var a1 = self.toArray();
        var a2 = other.toArray(); 
    
        var sorter = function(t1: Tuple2<K, V>, t2: Tuple2<K, V>): Int {
          var c = g_hsh(t1.fst())(t1.fst(), t2.fst());
          return if(c != 0)
            c;
          else
            g_val(t1.snd())(t1.snd(), t2.snd());
        }
        a1.sort(sorter);
        a2.sort(sorter);
        return ArrayOrder.compare(a1,a2);
    }
    public static function isEmpty<K,V>(map : Map<K, V>) : Bool {
        return switch(map) {
            case Cons(_, _, _): false;
            case _: true;
        }
    }

    public static function nonEmpty<K,V>(map : Map<K, V>) : Bool return !isEmpty(map);

    public static function collection<K,V>(map : Map<K, V>) : Collection<Tuple2<K, V>> {
        return new MapInstanceImpl(map);
    }

    public static function asMap<K,V>(map : Map<K, V>) : IntMap<Tuple2<K,V>> {
        return map;
    }

    public static function list<K,V>(map : Map<K, V>) : List<Tuple2<K, V>> {
        var result = ListType.Nil;
        MapTypes.foreach(map, function(value) result = result.prepend(value));
        return result;
    }

    inline public static function iterable<K,V>(map : Map<K, V>) : Iterable<Tuple2<K, V>> {
        return map;
    }

    inline public static function size<K,V>(map : Map<K, V>) : Int{
        return SIterables.size(map);
    }
    inline public static function iterator<K,V>(map : Map<K, V>) : Iterator<Tuple2<K, V>> {
        return iterable(map).iterator();
    }

    public static function toString<K,V>(map : Map<K, V>, ?func : Function1<Tuple2<K, V>, String>) : String {
        var p = map;
        return switch(p) {
            case Cons(_, _, _):
                var mappedFunc : Function1<Tuple2<K, V>, String> = Anys.toBool(func) ? func : function(tuple) {
                    return '${tuple.fst()} => ${tuple.fst()}';
                };
                var mapped : Collection<String> = CollectionTypes.map(collection(p), function(value) {
                    return Anys.toString(value, mappedFunc);
                });
                var folded : Option<String> = CollectionTypes.foldlWithIndex(mapped, '', function(a, b, index) {
                    return index < 1 ? b : '$a, $b';
                });
                'Map(${folded.get()})';
            case _: 'Nil';
        }
    }
    /**
     * Private methods to make working with a map more easier.
     */
    private static function nativeClone<K,V>(map : IntMap<Tuple2<K,V>>) : IntMap<Tuple2<K,V>> {
        // Surely this can be optimized.
        var result = new IntMap();
        for(i in map.keys()) {
            result.set(i, map.get(i));
        }
        return result;
    }

    private static function nativeKeys<K,V>(map : Map<K, V>) : Iterator<K> {
        return iterator(map).map(Tuple2s.fst);
    }

    private static function nativeValues<K,V>(map : Map<K, V>) : Iterator<V> {
        return iterator(map).map(Tuple2s.snd);
    }

    private static function nativeGet<K,V>(map : Map<K, V>, key : K) : V {
        var v = map.get(Hasher.getHashFor(key)(key));
        Anys.toBool(v) ? v.snd() : Prelude.fail()(out_of_bounds_error());
    }

    private static function nativeMap<K,V>(     map : Map<K, V>,
                                                key : K,
                                                value : V,
                                                func : Function1<IntMap<Tuple2<K,V>>, IntMap<Tuple2<K,V>>>) : Map<K, V> {
        var m = nativeClone(map);
            m = func(m);
        var k = Hasher.getHashFor(key)(key);
        return m;
    }
}
class IntMapType<T> {
    public var 
    public var length(default,null) : Int;
    public var impl(default,null)   : IntMap<T>;

    public function new(mp:IntMap<T>){
        this.impl       = mp;
        this.length     = this.impl.fold(0,function(memo,next) return memo++);
    }
    public inline function set(key:Int, value:T) : Void{
        if(!exists){
            length++;
        } 
        this.impl.set(key,value)
    }
    public inline function get( key : Int ) : Null<T>{
        return impl.get(key);
    }
    public inline function exists( key : Int ) : Bool{
        return impl.exists(key);
    }
    public inline function remove( key : Int ) : Bool{
        var o = impl.remove(key);
        if(o){
            length--;
        }
        return o;
    }
    public inline function keys() : Iterator<Int>{
        return impl.keys();
    }
    public inline function iterator() : Iterator<T>{
        return implt.iterator();
    }
    public inline function toString() : String{
        return impl.toString();
    }
}